<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MintWaterfall - Analytical Enhancement Features Demo</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="dist/mintwaterfall.umd.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #147B58;
            color: #333;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            padding: 30px;
            border-bottom: 3px solid #1a9d6b;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }

        .header p {
            margin: 10px 0 0 0;
            font-size: 1.2em;
            opacity: 0.9;
        }

        .demo-section {
            background: white;
            margin: 20px 0;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .demo-title {
            color: #4A5568;
            font-size: 1.8em;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .demo-description {
            color: #666;
            margin-bottom: 25px;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            background: linear-gradient(45deg, #147B58, #1a9d6b);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(20, 123, 88, 0.2);
        }

        button:hover {
            background: linear-gradient(45deg, #1a9d6b, #20b377);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(20, 123, 88, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: #147B58;
        }

        .chart-container {
            width: 100%;
            height: 580px;
            margin: 20px 0;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            position: relative;
            overflow: hidden;
        }

        .large-chart {
            height: 700px;
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #147B58;
        }

        .feature-card h4 {
            color: #147B58;
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }

        .feature-card p {
            color: #666;
            margin: 0;
            line-height: 1.5;
        }

        .metrics-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .metrics-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .metric-label {
            font-weight: 600;
            color: #4A5568;
        }

        .metric-value {
            color: #147B58;
            font-weight: 700;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-active { background: #4ade80; }
        .status-inactive { background: #e5e7eb; }

        .interaction-panel {
            background: #f0f9ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #0ea5e9;
        }

        .layout-showcase {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .layout-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }

        .layout-header {
            background: #147B58;
            color: white;
            padding: 15px;
            font-weight: 600;
        }

        .layout-content {
            height: 300px;
            position: relative;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>MintWaterfall Analytical Enhancement Features</h1>
        <p>MEDIUM PRIORITY D3.js Features: Advanced Data Manipulation, Sophisticated Interactions & Hierarchical Layouts</p>
    </div>

    <!-- Advanced Color Scales Demo -->
    <div class="demo-section">
        <h2 class="demo-title">üé® Advanced Color Scales & Themes</h2>
        <p class="demo-description">
            Professional <strong>sequential</strong>, <strong>diverging</strong>, and <strong>conditional formatting</strong> color scales 
            with multiple theme options for enhanced waterfall visualization and financial data presentation.
        </p>

        <div class="controls">
            <button onclick="enableConditionalColors()">Conditional Formatting</button>
            <button onclick="enableSequentialColors()">Sequential Scale</button>
            <button onclick="enableDivergingColors()">Diverging Scale</button>
            <button onclick="switchTheme('financial')">Financial Theme</button>
            <button onclick="switchTheme('professional')">Professional Theme</button>
            
            <select id="colorTheme" onchange="updateColorTheme()">
                <option value="default">Default Theme</option>
                <option value="financial">Financial Theme</option>
                <option value="professional">Professional Theme</option>
                <option value="heatmap">Heat Map Theme</option>
                <option value="dark">Dark Theme</option>
                <option value="accessible">Accessible Theme</option>
            </select>
        </div>

        <div class="features-grid">
            <div class="feature-card">
                <h4>Conditional Formatting</h4>
                <p>Automatic color coding based on positive/negative values with customizable neutral thresholds.</p>
            </div>
            <div class="feature-card">
                <h4>Sequential Scales (d3.interpolateRdYlGn)</h4>
                <p>Smooth color gradients for showing data intensity and magnitude relationships.</p>
            </div>
            <div class="feature-card">
                <h4>Diverging Scales (d3.interpolateRdYlBu)</h4>
                <p>Professional two-color gradients emphasizing positive/negative value distinctions.</p>
            </div>
            <div class="feature-card">
                <h4>Professional Themes</h4>
                <p>Multiple color schemes optimized for financial reporting and business presentations.</p>
            </div>
        </div>

        <div class="chart-container" id="advancedColorChart"></div>

        <div class="metrics-panel" id="colorMetrics">
            <h4>Color Scale Information</h4>
            <div id="colorMetricsContent">
                Click a color mode button to see color scale details...
            </div>
        </div>
    </div>

    <!-- Advanced Data Manipulation Demo -->
    <div class="demo-section">
        <h2 class="demo-title">Advanced Data Manipulation</h2>
        <p class="demo-description">
            Leveraging <strong>d3.pairs()</strong>, <strong>d3.permute()</strong>, <strong>d3.merge()</strong>, and <strong>d3.ticks()</strong> 
            for sophisticated waterfall data analysis and optimization.
        </p>

        <div class="controls">
            <button onclick="analyzeSequence()">Analyze Sequence Flow</button>
            <button onclick="optimizeOrder()">Optimize Data Order</button>
            <button onclick="mergeDatasets()">Merge Multiple Datasets</button>
            <button onclick="generateCustomTicks()">Custom Tick Generation</button>
            
            <select id="orderStrategy" onchange="updateOrderStrategy()">
                <option value="value">Order by Value</option>
                <option value="cumulative">Order by Cumulative Impact</option>
                <option value="magnitude">Order by Magnitude</option>
                <option value="alphabetical">Order Alphabetically</option>
            </select>
        </div>

        <div class="features-grid">
            <div class="feature-card">
                <h4>Sequential Analysis (d3.pairs)</h4>
                <p>Analyze relationships between consecutive waterfall items to identify flow patterns and change magnitudes.</p>
            </div>
            <div class="feature-card">
                <h4>Data Reordering (d3.permute)</h4>
                <p>Intelligently reorder waterfall data for optimal visualization using various sorting strategies.</p>
            </div>
            <div class="feature-card">
                <h4>Dataset Merging (d3.merge)</h4>
                <p>Combine multiple waterfall datasets with sophisticated conflict resolution strategies.</p>
            </div>
            <div class="feature-card">
                <h4>Custom Ticks (d3.ticks)</h4>
                <p>Generate intelligent axis ticks optimized for waterfall visualization with smart thresholds.</p>
            </div>
        </div>

        <div class="chart-container" id="dataManipulationChart"></div>

        <div class="metrics-panel" id="analysisMetrics">
            <h4>Analysis Results</h4>
            <div id="metricsContent">
                Click "Analyze Sequence Flow" to see detailed metrics...
            </div>
        </div>
    </div>

    <!-- Sophisticated Interactions Demo -->
    <div class="demo-section">
        <h2 class="demo-title">Sophisticated Interactions</h2>
        <p class="demo-description">
            Advanced interaction capabilities using <strong>d3.drag()</strong> for manual adjustments, 
            enhanced hover detection zones, and <strong>d3.forceSimulation()</strong> for dynamic layouts.
        </p>

        <div class="controls">
            <button onclick="enableDragInteraction()">Enable Drag Adjustment</button>
            <button onclick="enableEnhancedHover()">Enhanced Hover Zones</button>
            <button onclick="enableForceLayout()">Force Layout Animation</button>
            <button onclick="resetInteractions()">Reset All Interactions</button>
            
            <select id="interactionMode" onchange="setInteractionMode()">
                <option value="none">No Interactions</option>
                <option value="drag">Drag Only</option>
                <option value="hover">Enhanced Hover</option>
                <option value="force">Force Layout</option>
                <option value="combined">Combined Mode</option>
            </select>
        </div>

        <div class="interaction-panel">
            <h4>Interaction Status</h4>
            <div id="interactionStatus">
                <div><span class="status-indicator status-inactive"></span>Drag Behavior: Disabled</div>
                <div><span class="status-indicator status-inactive"></span>Enhanced Hover: Disabled</div>
                <div><span class="status-indicator status-inactive"></span>Force Simulation: Disabled</div>
            </div>
        </div>

        <div class="chart-container" id="interactionChart"></div>

        <div class="features-grid">
            <div class="feature-card">
                <h4>Manual Bar Adjustment (d3.drag)</h4>
                <p>Drag bars vertically to manually adjust values with snap-to-grid and constraint support.</p>
            </div>
            <div class="feature-card">
                <h4>Enhanced Hover Detection</h4>
                <p>Enlarged hover zones around bars for improved user experience and precise targeting.</p>
            </div>
            <div class="feature-card">
                <h4>Force Layout Animation (d3.forceSimulation)</h4>
                <p>Dynamic bar positioning using physics simulation with collision detection and positioning forces.</p>
            </div>
            <div class="feature-card">
                <h4>Combined Interaction Modes</h4>
                <p>Multiple interaction systems working together for comprehensive chart manipulation capabilities.</p>
            </div>
        </div>
    </div>

    <!-- Hierarchical Layouts Demo -->
    <div class="demo-section">
        <h2 class="demo-title">Hierarchical Layout Extensions</h2>
        <p class="demo-description">
            Multi-dimensional waterfall visualization using <strong>d3.treemap()</strong>, <strong>d3.partition()</strong>, 
            <strong>d3.cluster()</strong>, and <strong>d3.pack()</strong> for advanced analytical insights.
        </p>

        <div class="controls">
            <button onclick="renderTreemap()">Treemap Breakdown</button>
            <button onclick="renderSunburst()">Sunburst View</button>
            <button onclick="renderBubbleChart()">Bubble Visualization</button>
            <button onclick="renderDendogram()">Cluster Dendogram</button>
            <button onclick="generateHierarchicalData()">Generate New Data</button>
        </div>

        <div class="layout-showcase">
            <div class="layout-card">
                <div class="layout-header">Treemap Layout (d3.treemap)</div>
                <div class="layout-content" id="treemapLayout"></div>
            </div>
            <div class="layout-card">
                <div class="layout-header">Partition Layout (d3.partition)</div>
                <div class="layout-content" id="partitionLayout"></div>
            </div>
            <div class="layout-card">
                <div class="layout-header">Pack Layout (d3.pack)</div>
                <div class="layout-content" id="packLayout"></div>
            </div>
            <div class="layout-card">
                <div class="layout-header">Cluster Layout (d3.cluster)</div>
                <div class="layout-content" id="clusterLayout"></div>
            </div>
        </div>

        <div class="chart-container large-chart" id="hierarchicalChart"></div>

        <div class="features-grid">
            <div class="feature-card">
                <h4>Nested Breakdowns (d3.treemap)</h4>
                <p>Visualize waterfall components as nested rectangles showing hierarchical relationships and proportions.</p>
            </div>
            <div class="feature-card">
                <h4>Radial Views (d3.partition)</h4>
                <p>Circular sunburst and icicle charts for alternative perspective on waterfall hierarchy.</p>
            </div>
            <div class="feature-card">
                <h4>Bubble Grouping (d3.pack)</h4>
                <p>Bubble charts showing waterfall items clustered by category with size representing magnitude.</p>
            </div>
            <div class="feature-card">
                <h4>Category Trees (d3.cluster)</h4>
                <p>Dendogram visualization showing categorical relationships and data structure.</p>
            </div>
        </div>
    </div>

    <script>
        console.log('MintWaterfall Analytical Enhancement Demo Loaded');
        console.log('Available MintWaterfall functions:', Object.keys(MintWaterfall));

        // Sample waterfall data for demonstrations - using correct MintWaterfall format
        let currentDataset = [
            { label: 'Starting Revenue', stacks: [{ value: 10000, color: '#4F81BD' }], category: 'baseline' },
            { label: 'Product Sales', stacks: [{ value: 3500, color: '#9CBB58' }], category: 'revenue' },
            { label: 'Service Revenue', stacks: [{ value: 2200, color: '#9CBB58' }], category: 'revenue' },
            { label: 'Marketing Costs', stacks: [{ value: -1800, color: '#F79646' }], category: 'expenses' },
            { label: 'Operations', stacks: [{ value: -1200, color: '#F79646' }], category: 'expenses' },
            { label: 'R&D Investment', stacks: [{ value: -800, color: '#F79646' }], category: 'expenses' },
            { label: 'Tax Benefits', stacks: [{ value: 600, color: '#8064A2' }], category: 'adjustments' },
            { label: 'One-time Gains', stacks: [{ value: 1100, color: '#8064A2' }], category: 'adjustments' }
        ];

        let secondDataset = [
            { label: 'Starting Revenue', stacks: [{ value: 9500, color: '#4F81BD' }], category: 'baseline' },
            { label: 'New Product Line', stacks: [{ value: 2800, color: '#9CBB58' }], category: 'revenue' },
            { label: 'Subscription Growth', stacks: [{ value: 1900, color: '#9CBB58' }], category: 'revenue' },
            { label: 'Cost Optimization', stacks: [{ value: 1200, color: '#4BACC6' }], category: 'savings' },
            { label: 'New Hires', stacks: [{ value: -2100, color: '#F79646' }], category: 'expenses' }
        ];

        // Initialize systems
        let dataProcessor, interactionSystem, hierarchicalLayoutSystem;
        let currentChart, currentInteractionChart, currentAdvancedColorChart;

        // Helper function to get the total value from stacks
        function getValue(item) {
            return item.stacks ? item.stacks.reduce((sum, stack) => sum + stack.value, 0) : 0;
        }

        // Helper function to create a stack item
        function createStackItem(value, category) {
            const colorMap = {
                'baseline': '#4F81BD',
                'revenue': '#9CBB58',
                'expenses': '#F79646',
                'adjustments': '#8064A2',
                'savings': '#4BACC6',
                'secondary': '#4ecdc4',
                'merged': '#ff6b6b'
            };
            return { value: value, color: colorMap[category] || '#999999' };
        }

        
        // =====================================================================
        // ADVANCED COLOR SCALES FUNCTIONS
        // =====================================================================

        function createAdvancedColorChart() {
            const container = d3.select('#advancedColorChart');
            container.selectAll('*').remove();

            currentAdvancedColorChart = MintWaterfall.waterfallChart()
                .width(1000)
                .height(520)
                .margin({ top: 40, right: 80, bottom: 100, left: 120 })
                .showTotal(true)
                .totalLabel('Enhanced Visual Result');

            container.datum(currentDataset).call(currentAdvancedColorChart);
        }

        function enableConditionalColors() {
            try {
                currentAdvancedColorChart
                    .enableAdvancedColors(true)
                    .colorMode('conditional');

                createAdvancedColorChart();

                updateColorMetrics('Conditional Formatting', {
                    mode: 'conditional',
                    description: 'Automatic color coding based on positive/negative values',
                    positive: 'Green (#27ae60)',
                    negative: 'Red (#e74c3c)',
                    neutral: 'Gray (#95a5a6)',
                    features: ['Value-based coloring', 'Customizable thresholds', 'Business-friendly colors']
                });

            } catch (error) {
                console.error('Error enabling conditional colors:', error);
            }
        }

        function enableSequentialColors() {
            try {
                currentAdvancedColorChart
                    .enableAdvancedColors(true)
                    .colorMode('sequential');

                createAdvancedColorChart();

                updateColorMetrics('Sequential Color Scale', {
                    mode: 'sequential',
                    description: 'Smooth color gradients showing data intensity',
                    interpolator: 'd3.interpolateRdYlGn',
                    domain: 'Min to Max values',
                    features: ['Continuous color progression', 'Data magnitude visualization', 'Professional gradients']
                });

            } catch (error) {
                console.error('Error enabling sequential colors:', error);
            }
        }

        function enableDivergingColors() {
            try {
                currentAdvancedColorChart
                    .enableAdvancedColors(true)
                    .colorMode('diverging');

                createAdvancedColorChart();

                updateColorMetrics('Diverging Color Scale', {
                    mode: 'diverging',
                    description: 'Two-color gradient emphasizing positive/negative distinctions',
                    interpolator: 'd3.interpolateRdYlBu',
                    domain: 'Symmetric around zero',
                    features: ['Balanced color distribution', 'Clear positive/negative emphasis', 'Financial data optimized']
                });

            } catch (error) {
                console.error('Error enabling diverging colors:', error);
            }
        }

        function switchTheme(themeName) {
            try {
                currentAdvancedColorChart
                    .enableAdvancedColors(true)
                    .colorTheme(themeName);

                document.getElementById('colorTheme').value = themeName;
                createAdvancedColorChart();

                updateColorMetrics(`${themeName.charAt(0).toUpperCase() + themeName.slice(1)} Theme`, {
                    mode: 'theme',
                    themeName: themeName,
                    description: `Professional ${themeName} color scheme`,
                    features: getThemeFeatures(themeName)
                });

            } catch (error) {
                console.error('Error switching theme:', error);
            }
        }

        function updateColorTheme() {
            const themeName = document.getElementById('colorTheme').value;
            switchTheme(themeName);
        }

        function updateColorMetrics(title, info) {
            const metricsContent = document.getElementById('colorMetricsContent');
            
            let html = `<h5>${title}</h5>`;
            
            if (info.description) {
                html += `<div class="metrics-row">
                    <span class="metric-label">üìã Description</span>
                    <span class="metric-value">${info.description}</span>
                </div>`;
            }
            
            if (info.mode) {
                html += `<div class="metrics-row">
                    <span class="metric-label">üé® Color Mode</span>
                    <span class="metric-value">${info.mode}</span>
                </div>`;
            }
            
            if (info.interpolator) {
                html += `<div class="metrics-row">
                    <span class="metric-label">üåà Interpolator</span>
                    <span class="metric-value">${info.interpolator}</span>
                </div>`;
            }
            
            if (info.positive || info.negative) {
                html += `<div class="metrics-row">
                    <span class="metric-label">‚úÖ Positive Values</span>
                    <span class="metric-value">${info.positive}</span>
                </div>`;
                html += `<div class="metrics-row">
                    <span class="metric-label">‚ùå Negative Values</span>
                    <span class="metric-value">${info.negative}</span>
                </div>`;
            }
            
            if (info.features && info.features.length > 0) {
                html += '<h6>Key Features:</h6>';
                info.features.forEach(feature => {
                    html += `<div class="metrics-row">
                        <span class="metric-label">‚≠ê ${feature}</span>
                        <span class="metric-value">Active</span>
                    </div>`;
                });
            }

            metricsContent.innerHTML = html;
        }

        function getThemeFeatures(themeName) {
            const features = {
                'financial': ['Professional green/red colors', 'Business-optimized palette', 'High contrast'],
                'professional': ['Corporate color scheme', 'Subtle gradients', 'Meeting-ready visuals'],
                'heatmap': ['Heat map visualization', 'Intensity-based coloring', 'Scientific palette'],
                'dark': ['Dark mode support', 'Reduced eye strain', 'Modern appearance'],
                'accessible': ['High contrast colors', 'Colorblind-friendly', 'WCAG compliant'],
                'default': ['Balanced colors', 'General purpose', 'D3.js standard']
            };
            return features[themeName] || ['Standard color scheme'];
        }


        // Initialize the demo
        function initializeDemo() {
            try {
                // Initialize advanced data processor
                dataProcessor = MintWaterfall.createAdvancedDataProcessor();
                hierarchicalLayoutSystem = MintWaterfall.createHierarchicalLayoutSystem();
                
                // Create initial charts
                createAdvancedColorChart();
                createDataManipulationChart();
                createInteractionChart();
                createInitialHierarchicalLayouts();
                
                console.log('Demo initialized successfully');
            } catch (error) {
                console.error('Error initializing demo:', error);
            }
        }

        // =====================================================================
        // ADVANCED DATA MANIPULATION FUNCTIONS
        // =====================================================================

        function createDataManipulationChart() {
            const container = d3.select('#dataManipulationChart');
            container.selectAll('*').remove();

            currentChart = MintWaterfall.waterfallChart()
                .width(1000)
                .height(520)
                .margin({ top: 40, right: 80, bottom: 100, left: 120 })
                .showTotal(true)
                .totalLabel('Final Result');

            container.datum(currentDataset).call(currentChart);
        }

        function analyzeSequence() {
            try {
                const analysis = MintWaterfall.createWaterfallSequenceAnalyzer(currentDataset);
                
                displayAnalysisResults(analysis);
                updateChartWithAnalysis(analysis);
                
                console.log('Sequence Analysis:', analysis);
            } catch (error) {
                console.error('Error in sequence analysis:', error);
                showFallbackAnalysis();
            }
        }

        function displayAnalysisResults(analysis) {
            const metricsContent = document.getElementById('metricsContent');
            
            if (!analysis || !analysis.flowAnalysis) {
                showFallbackAnalysis();
                return;
            }

            let html = '';
            
            // Flow Analysis Summary
            html += '<h5>Sequential Flow Analysis (d3.pairs)</h5>';
            analysis.flowAnalysis.forEach(flow => {
                const direction = flow.changeDirection === 'increase' ? '‚ÜóÔ∏è' : flow.changeDirection === 'decrease' ? '‚ÜòÔ∏è' : '‚û°Ô∏è';
                html += `<div class="metrics-row">
                    <span class="metric-label">${direction} ${flow.from} ‚Üí ${flow.to}</span>
                    <span class="metric-value">${flow.change > 0 ? '+' : ''}${flow.change.toLocaleString()} (${flow.changePercent.toFixed(1)}%)</span>
                </div>`;
            });

            // Critical Paths
            if (analysis.criticalPaths && analysis.criticalPaths.length > 0) {
                html += '<h5>Critical Impact Paths</h5>';
                analysis.criticalPaths.forEach(path => {
                    html += `<div class="metrics-row">
                        <span class="metric-label">üî• ${path}</span>
                        <span class="metric-value">High Impact</span>
                    </div>`;
                });
            }

            // Optimization Suggestions
            if (analysis.optimizationSuggestions && analysis.optimizationSuggestions.length > 0) {
                html += '<h5>Optimization Suggestions</h5>';
                analysis.optimizationSuggestions.forEach(suggestion => {
                    html += `<div class="metrics-row">
                        <span class="metric-label">üí° ${suggestion}</span>
                        <span class="metric-value">Recommended</span>
                    </div>`;
                });
            }

            metricsContent.innerHTML = html;
        }

        function showFallbackAnalysis() {
            const metricsContent = document.getElementById('metricsContent');
            
            let html = '<h5>Sequential Flow Analysis (Simulated)</h5>';
            
            // Simulate analysis results
            for (let i = 0; i < currentDataset.length - 1; i++) {
                const current = currentDataset[i];
                const next = currentDataset[i + 1];
                const change = getValue(next) - getValue(current);
                const direction = change > 0 ? '‚ÜóÔ∏è' : change < 0 ? '‚ÜòÔ∏è' : '‚û°Ô∏è';
                
                html += `<div class="metrics-row">
                    <span class="metric-label">${direction} ${current.label} ‚Üí ${next.label}</span>
                    <span class="metric-value">${change > 0 ? '+' : ''}${change.toLocaleString()}</span>
                </div>`;
            }

            html += '<h5>Analysis Features Demonstrated</h5>';
            html += `<div class="metrics-row">
                <span class="metric-label">üîó d3.pairs() - Sequential Analysis</span>
                <span class="metric-value">Active</span>
            </div>`;
            html += `<div class="metrics-row">
                <span class="metric-label">üìä Flow Pattern Detection</span>
                <span class="metric-value">Complete</span>
            </div>`;
            html += `<div class="metrics-row">
                <span class="metric-label">üíπ Change Magnitude Calculation</span>
                <span class="metric-value">Applied</span>
            </div>`;

            metricsContent.innerHTML = html;
        }

        function updateChartWithAnalysis(analysis) {
            // Update the chart visualization to highlight the analysis
            d3.select('#dataManipulationChart').selectAll('.bar')
                .transition()
                .duration(500)
                .style('stroke', (d, i) => {
                    // Highlight bars involved in large changes
                    if (analysis && analysis.flowAnalysis) {
                        const hasLargeChange = analysis.flowAnalysis.some(flow => 
                            (flow.from === d.label || flow.to === d.label) && flow.magnitude === 'large'
                        );
                        return hasLargeChange ? '#ff6b6b' : null;
                    }
                    return null;
                })
                .style('stroke-width', (d, i) => {
                    if (analysis && analysis.flowAnalysis) {
                        const hasLargeChange = analysis.flowAnalysis.some(flow => 
                            (flow.from === d.label || flow.to === d.label) && flow.magnitude === 'large'
                        );
                        return hasLargeChange ? '3px' : null;
                    }
                    return null;
                });
        }

        function optimizeOrder() {
            const strategy = document.getElementById('orderStrategy').value;
            
            try {
                // Simulate d3.permute() optimization
                let optimizedData = [...currentDataset];
                
                switch (strategy) {
                    case 'value':
                        optimizedData.sort((a, b) => Math.abs(getValue(b)) - Math.abs(getValue(a)));
                        break;
                    case 'cumulative':
                        // Sort by cumulative impact
                        optimizedData = calculateCumulativeSort(optimizedData);
                        break;
                    case 'magnitude':
                        optimizedData.sort((a, b) => Math.abs(getValue(b)) - Math.abs(getValue(a)));
                        break;
                    case 'alphabetical':
                        optimizedData.sort((a, b) => a.label.localeCompare(b.label));
                        break;
                }
                
                currentDataset = optimizedData;
                createDataManipulationChart();
                
                // Show reordering effect
                d3.select('#dataManipulationChart').selectAll('.bar')
                    .style('opacity', 0)
                    .transition()
                    .duration(800)
                    .delay((d, i) => i * 100)
                    .style('opacity', 1);

                const metricsContent = document.getElementById('metricsContent');
                metricsContent.innerHTML = `
                    <h5>Data Reordering Applied (d3.permute)</h5>
                    <div class="metrics-row">
                        <span class="metric-label">üîÑ Strategy Used</span>
                        <span class="metric-value">${strategy.charAt(0).toUpperCase() + strategy.slice(1)}</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">üìä Items Reordered</span>
                        <span class="metric-value">${optimizedData.length}</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">‚ö° Optimization</span>
                        <span class="metric-value">Complete</span>
                    </div>
                `;
                
            } catch (error) {
                console.error('Error optimizing order:', error);
            }
        }

        function calculateCumulativeSort(data) {
            // Simulate cumulative impact calculation
            return data.map((d, i) => ({
                ...d,
                cumulativeImpact: data.slice(0, i + 1).reduce((sum, item) => sum + Math.abs(getValue(item)), 0)
            }))
            .sort((a, b) => b.cumulativeImpact - a.cumulativeImpact);
        }

        function mergeDatasets() {
            try {
                // Simulate d3.merge() functionality
                const mergedData = [];
                const datasetMap = new Map();
                
                // Add current dataset
                currentDataset.forEach(item => {
                    datasetMap.set(item.label, { ...item, source: 'primary' });
                });
                
                // Merge second dataset
                secondDataset.forEach(item => {
                    if (datasetMap.has(item.label)) {
                        // Conflict resolution - average the values
                        const existing = datasetMap.get(item.label);
                        const existingValue = getValue(existing);
                        const itemValue = getValue(item);
                        const averageValue = (existingValue + itemValue) / 2;
                        existing.stacks = [createStackItem(averageValue, 'merged')];
                        existing.source = 'merged';
                    } else {
                        datasetMap.set(item.label, { ...item, source: 'secondary' });
                    }
                });
                
                currentDataset = Array.from(datasetMap.values());
                createDataManipulationChart();
                
                // Highlight merged items
                d3.select('#dataManipulationChart').selectAll('.bar')
                    .style('fill', d => {
                        switch (d.source) {
                            case 'merged': return '#ff6b6b';
                            case 'secondary': return '#4ecdc4';
                            default: return null;
                        }
                    });

                const metricsContent = document.getElementById('metricsContent');
                metricsContent.innerHTML = `
                    <h5>Dataset Merging Complete (d3.merge)</h5>
                    <div class="metrics-row">
                        <span class="metric-label">üîó Datasets Merged</span>
                        <span class="metric-value">2</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">‚öñÔ∏è Conflict Resolution</span>
                        <span class="metric-value">Average Strategy</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">üìä Final Items</span>
                        <span class="metric-value">${currentDataset.length}</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">üî¥ Merged Items</span>
                        <span class="metric-value">Red Bars</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">üîµ New Items</span>
                        <span class="metric-value">Blue Bars</span>
                    </div>
                `;
                
            } catch (error) {
                console.error('Error merging datasets:', error);
            }
        }

        function generateCustomTicks() {
            try {
                // Simulate d3.ticks() custom generation
                const values = currentDataset.map(d => getValue(d));
                const domain = [Math.min(...values), Math.max(...values)];
                
                // Simulate advanced tick generation
                const tickCount = 8;
                const range = domain[1] - domain[0];
                const rawTicks = [];
                
                for (let i = 0; i <= tickCount; i++) {
                    rawTicks.push(domain[0] + (range * i) / tickCount);
                }
                
                // Smart tick optimization
                const optimizedTicks = rawTicks.map(tick => {
                    if (Math.abs(tick) < 100) return Math.round(tick);
                    if (Math.abs(tick) < 1000) return Math.round(tick / 50) * 50;
                    return Math.round(tick / 500) * 500;
                });
                
                const metricsContent = document.getElementById('metricsContent');
                metricsContent.innerHTML = `
                    <h5>Custom Tick Generation (d3.ticks)</h5>
                    <div class="metrics-row">
                        <span class="metric-label">üìè Domain Range</span>
                        <span class="metric-value">${domain[0].toLocaleString()} to ${domain[1].toLocaleString()}</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">üéØ Generated Ticks</span>
                        <span class="metric-value">${optimizedTicks.length}</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">‚ö° Optimization</span>
                        <span class="metric-value">Smart Rounding Applied</span>
                    </div>
                    <div class="metrics-row">
                        <span class="metric-label">üìä Tick Values</span>
                        <span class="metric-value">${optimizedTicks.map(t => t.toLocaleString()).join(', ')}</span>
                    </div>
                `;
                
                // Update chart with custom axis
                d3.select('#dataManipulationChart .y-axis')
                    .transition()
                    .duration(1000)
                    .style('stroke-width', '2px')
                    .style('stroke', '#147B58');
                
            } catch (error) {
                console.error('Error generating custom ticks:', error);
            }
        }

        function updateOrderStrategy() {
            const strategy = document.getElementById('orderStrategy').value;
            console.log('Order strategy changed to:', strategy);
        }

        // =====================================================================
        // SOPHISTICATED INTERACTIONS FUNCTIONS
        // =====================================================================

        function createInteractionChart() {
            const container = d3.select('#interactionChart');
            container.selectAll('*').remove();

            currentInteractionChart = MintWaterfall.waterfallChart()
                .width(1000)
                .height(520)
                .margin({ top: 40, right: 80, bottom: 100, left: 120 })
                .showTotal(true)
                .totalLabel('Interactive Result');

            container.datum(currentDataset).call(currentInteractionChart);
        }

        function enableDragInteraction() {
            try {
                console.log('Enabling actual drag interaction...');
                
                // Create actual drag behavior
                const drag = d3.drag()
                    .on('start', function(event, d) {
                        // Check if data is properly bound
                        if (!d || !d.stacks || !d.stacks[0]) {
                            console.warn('Invalid data structure for drag start:', d);
                            return;
                        }
                        
                        d3.select(this)
                            .style('stroke', '#ff6b6b')
                            .style('stroke-width', '3px')
                            .style('opacity', 0.7);
                        
                        // Store initial values
                        const bar = d3.select(this);
                        bar.datum().initialY = event.y;
                        bar.datum().initialValue = getValue(d);
                    })
                    .on('drag', function(event, d) {
                        // Check if data is properly bound
                        if (!d || !d.stacks || !d.stacks[0]) {
                            console.warn('Invalid data structure for drag:', d);
                            return;
                        }
                        
                        // Calculate new value based on vertical drag
                        const deltaY = event.y - d.initialY;
                        const scale = 50; // Adjust sensitivity
                        const newValue = d.initialValue - (deltaY * scale);
                        
                        // Update the data
                        d.stacks[0].value = newValue;
                        
                        // Update the visual feedback
                        d3.select(this)
                            .style('transform', `translateY(${deltaY}px)`);
                        
                        // Show current value in tooltip
                        const tooltip = d3.select('body').selectAll('.drag-tooltip')
                            .data([d]);
                        
                        tooltip.enter()
                            .append('div')
                            .attr('class', 'drag-tooltip')
                            .style('position', 'absolute')
                            .style('background', 'rgba(0,0,0,0.8)')
                            .style('color', 'white')
                            .style('padding', '8px')
                            .style('border-radius', '4px')
                            .style('font-size', '12px')
                            .style('pointer-events', 'none')
                            .style('z-index', '1000');
                        
                        d3.select('.drag-tooltip')
                            .style('left', (event.sourceEvent.pageX + 10) + 'px')
                            .style('top', (event.sourceEvent.pageY - 10) + 'px')
                            .text(`${d.label}: ${newValue.toLocaleString()}`);
                    })
                    .on('end', function(event, d) {
                        // Clean up visual effects
                        d3.select(this)
                            .style('stroke', null)
                            .style('stroke-width', null)
                            .style('opacity', 1)
                            .style('transform', null);
                        
                        // Remove tooltip
                        d3.select('.drag-tooltip').remove();
                        
                        // Recreate the chart with new values
                        setTimeout(() => {
                            createInteractionChart();
                            // Re-enable drag after chart recreation
                            setTimeout(() => {
                                if (document.getElementById('interactionMode').value === 'drag' || 
                                    document.getElementById('interactionMode').value === 'combined') {
                                    enableDragInteraction();
                                }
                            }, 100);
                        }, 100);
                        
                        showInteractionFeedback('Value Updated', `${d.label} adjusted to ${getValue(d).toLocaleString()}`);
                    });
                
                // Apply drag behavior to bars - only to elements with proper data
                const bars = d3.select('#interactionChart').selectAll('*')
                    .filter(function(d) { 
                        return d && d.stacks && d.stacks.length > 0; 
                    });
                
                console.log('Found draggable bars:', bars.size());
                
                bars.style('cursor', 'ns-resize')
                    .call(drag);
                
                updateInteractionStatus('drag', true);
                showInteractionFeedback('Drag Interaction Enabled', 'Drag bars vertically to adjust values');
                
            } catch (error) {
                console.error('Error enabling drag interaction:', error);
                // Fallback to basic interaction if drag fails
                const clickBars = d3.select('#interactionChart').selectAll('*')
                    .filter(function(d) { 
                        return d && d.stacks && d.stacks.length > 0; 
                    });
                
                clickBars.style('cursor', 'pointer')
                    .on('click', function(event, d) {
                        if (!d || !d.stacks || !d.stacks[0]) return;
                        
                        const newValue = prompt(`Enter new value for ${d.label}:`, getValue(d));
                        if (newValue !== null && !isNaN(newValue)) {
                            d.stacks[0].value = parseFloat(newValue);
                            createInteractionChart();
                            enableDragInteraction();
                            showInteractionFeedback('Value Updated', `${d.label} set to ${getValue(d).toLocaleString()}`);
                        }
                    });
                showInteractionFeedback('Drag Interaction Enabled', 'Click bars to manually enter values');
            }
        }

        function enableEnhancedHover() {
            try {
                console.log('Enabling enhanced hover zones...');
                
                // Create enhanced hover zones
                const svg = d3.select('#interactionChart svg');
                const bars = svg.selectAll('.bar');
                
                // Add larger hover zones
                bars.each(function(d, i) {
                    const bar = d3.select(this);
                    const bbox = this.getBBox();
                    
                    svg.append('rect')
                        .attr('class', 'hover-zone')
                        .attr('x', bbox.x - 10)
                        .attr('y', bbox.y - 10)
                        .attr('width', bbox.width + 20)
                        .attr('height', bbox.height + 20)
                        .style('fill', 'transparent')
                        .style('stroke', '#147B58')
                        .style('stroke-width', '2px')
                        .style('stroke-dasharray', '5,5')
                        .style('opacity', 0)
                        .on('mouseenter', function() {
                            d3.select(this).style('opacity', 0.3);
                            bar.style('opacity', 0.8);
                        })
                        .on('mouseleave', function() {
                            d3.select(this).style('opacity', 0);
                            bar.style('opacity', 1);
                        });
                });
                
                updateInteractionStatus('hover', true);
                showInteractionFeedback('Enhanced Hover Enabled', 'Larger detection zones around bars');
                
            } catch (error) {
                console.error('Error enabling enhanced hover:', error);
            }
        }

        function enableForceLayout() {
            try {
                console.log('Enabling force layout simulation...');
                
                // Simulate force layout animation
                d3.select('#interactionChart').selectAll('.bar')
                    .transition()
                    .duration(2000)
                    .ease(d3.easeElastic)
                    .style('transform', (d, i) => {
                        const angle = (i * 30) * Math.PI / 180;
                        const radius = 20;
                        const x = Math.sin(angle) * radius;
                        const y = Math.cos(angle) * radius;
                        return `translate(${x}px, ${y}px)`;
                    })
                    .transition()
                    .duration(1000)
                    .style('transform', 'translate(0px, 0px)');
                
                updateInteractionStatus('force', true);
                showInteractionFeedback('Force Layout Enabled', 'Physics simulation applied to bar positions');
                
            } catch (error) {
                console.error('Error enabling force layout:', error);
            }
        }

        function resetInteractions() {
            // Reset all interactions
            d3.select('#interactionChart').selectAll('.bar, rect')
                .style('cursor', 'default')
                .style('stroke', null)
                .style('stroke-width', null)
                .style('transform', null)
                .style('opacity', null)
                .on('mousedown', null)
                .on('mouseup', null)
                .on('click', null)
                .on('.drag', null); // Remove drag behavior
            
            d3.select('#interactionChart').selectAll('.hover-zone').remove();
            d3.selectAll('.drag-tooltip').remove(); // Remove any lingering tooltips
            
            updateInteractionStatus('drag', false);
            updateInteractionStatus('hover', false);
            updateInteractionStatus('force', false);
            
            showInteractionFeedback('Interactions Reset', 'All interaction modes disabled');
        }

        function setInteractionMode() {
            const mode = document.getElementById('interactionMode').value;
            
            resetInteractions();
            
            switch (mode) {
                case 'drag':
                    enableDragInteraction();
                    break;
                case 'hover':
                    enableEnhancedHover();
                    break;
                case 'force':
                    enableForceLayout();
                    break;
                case 'combined':
                    enableDragInteraction();
                    setTimeout(enableEnhancedHover, 500);
                    break;
            }
        }

        function updateInteractionStatus(type, active) {
            const statusElement = document.querySelector(`#interactionStatus div:nth-child(${type === 'drag' ? 1 : type === 'hover' ? 2 : 3})`);
            const indicator = statusElement.querySelector('.status-indicator');
            
            indicator.className = `status-indicator ${active ? 'status-active' : 'status-inactive'}`;
            
            const text = statusElement.childNodes[1];
            const label = type === 'drag' ? 'Drag Behavior' : type === 'hover' ? 'Enhanced Hover' : 'Force Simulation';
            text.textContent = `${label}: ${active ? 'Enabled' : 'Disabled'}`;
        }

        function showInteractionFeedback(title, message) {
            const panel = document.querySelector('.interaction-panel');
            const feedback = document.createElement('div');
            feedback.style.background = '#e0f2fe';
            feedback.style.padding = '10px';
            feedback.style.borderRadius = '4px';
            feedback.style.marginTop = '10px';
            feedback.innerHTML = `<strong>${title}</strong><br>${message}`;
            
            panel.appendChild(feedback);
            
            setTimeout(() => {
                feedback.remove();
            }, 3000);
        }

        // =====================================================================
        // HIERARCHICAL LAYOUTS FUNCTIONS
        // =====================================================================

        function createInitialHierarchicalLayouts() {
            generateHierarchicalData();
            renderTreemap();
            renderSunburst();
            renderBubbleChart();
            renderDendogram();
        }

        function generateHierarchicalData() {
            // Transform current dataset to hierarchical structure
            window.hierarchicalData = {
                name: "Waterfall Analysis",
                children: [
                    {
                        name: "Revenue",
                        children: currentDataset.filter(d => d.category === 'revenue').map(d => ({
                            name: d.label,
                            value: Math.abs(getValue(d)),
                            category: d.category
                        }))
                    },
                    {
                        name: "Expenses", 
                        children: currentDataset.filter(d => d.category === 'expenses').map(d => ({
                            name: d.label,
                            value: Math.abs(getValue(d)),
                            category: d.category
                        }))
                    },
                    {
                        name: "Adjustments",
                        children: currentDataset.filter(d => d.category === 'adjustments').map(d => ({
                            name: d.label,
                            value: Math.abs(getValue(d)),
                            category: d.category
                        }))
                    }
                ]
            };
        }

        function renderTreemap() {
            try {
                const container = d3.select('#treemapLayout');
                container.selectAll('*').remove();
                
                // Simulate treemap layout
                const width = 380;
                const height = 280;
                
                const hierarchy = d3.hierarchy(window.hierarchicalData)
                    .sum(d => d.value || 0)
                    .sort((a, b) => b.value - a.value);
                
                const treemap = d3.treemap()
                    .size([width, height])
                    .padding(2)
                    .round(true);
                
                const root = treemap(hierarchy);
                const colorScale = d3.scaleOrdinal(d3.schemeSet3);
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const leaf = svg.selectAll('g')
                    .data(root.leaves())
                    .enter().append('g')
                    .attr('transform', d => `translate(${d.x0},${d.y0})`);
                
                leaf.append('rect')
                    .attr('width', d => d.x1 - d.x0)
                    .attr('height', d => d.y1 - d.y0)
                    .attr('fill', d => colorScale(d.data.category))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1);
                
                leaf.append('text')
                    .attr('x', 4)
                    .attr('y', 14)
                    .text(d => d.data.name)
                    .attr('font-size', '10px')
                    .attr('fill', '#333');
                
                leaf.append('text')
                    .attr('x', 4)
                    .attr('y', 28)
                    .text(d => d.value.toLocaleString())
                    .attr('font-size', '9px')
                    .attr('fill', '#666');
                
                console.log('Treemap rendered successfully');
                
            } catch (error) {
                console.error('Error rendering treemap:', error);
            }
        }

        function renderSunburst() {
            try {
                const container = d3.select('#partitionLayout');
                container.selectAll('*').remove();
                
                const width = 380;
                const height = 280;
                const radius = Math.min(width, height) / 2;
                
                const hierarchy = d3.hierarchy(window.hierarchicalData)
                    .sum(d => d.value || 0);
                
                const partition = d3.partition()
                    .size([2 * Math.PI, radius]);
                
                const root = partition(hierarchy);
                const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
                
                const arc = d3.arc()
                    .startAngle(d => d.x0)
                    .endAngle(d => d.x1)
                    .innerRadius(d => d.y0)
                    .outerRadius(d => d.y1);
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
                    .attr('transform', `translate(${width / 2},${height / 2})`);
                
                svg.selectAll('path')
                    .data(root.descendants().filter(d => d.depth))
                    .enter().append('path')
                    .attr('d', arc)
                    .attr('fill', d => colorScale(d.data.category || d.data.name))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1);
                
                console.log('Sunburst rendered successfully');
                
            } catch (error) {
                console.error('Error rendering sunburst:', error);
            }
        }

        function renderBubbleChart() {
            try {
                const container = d3.select('#packLayout');
                container.selectAll('*').remove();
                
                const width = 380;
                const height = 280;
                
                const hierarchy = d3.hierarchy(window.hierarchicalData)
                    .sum(d => d.value || 0);
                
                const pack = d3.pack()
                    .size([width, height])
                    .padding(3);
                
                const root = pack(hierarchy);
                const colorScale = d3.scaleOrdinal(d3.schemePastel1);
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                const node = svg.selectAll('g')
                    .data(root.descendants())
                    .enter().append('g')
                    .attr('transform', d => `translate(${d.x},${d.y})`);
                
                node.append('circle')
                    .attr('r', d => d.r)
                    .attr('fill', d => colorScale(d.data.category || d.data.name))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1);
                
                node.filter(d => d.r > 20)
                    .append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.3em')
                    .text(d => d.data.name)
                    .attr('font-size', d => Math.min(d.r / 3, 12))
                    .attr('fill', '#333');
                
                console.log('Bubble chart rendered successfully');
                
            } catch (error) {
                console.error('Error rendering bubble chart:', error);
            }
        }

        function renderDendogram() {
            try {
                const container = d3.select('#clusterLayout');
                container.selectAll('*').remove();
                
                const width = 380;
                const height = 280;
                
                const hierarchy = d3.hierarchy(window.hierarchicalData);
                
                const cluster = d3.cluster()
                    .size([height - 40, width - 160]);
                
                const root = cluster(hierarchy);
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
                    .attr('transform', 'translate(80,20)');
                
                // Links
                svg.selectAll('.link')
                    .data(root.links())
                    .enter().append('path')
                    .attr('class', 'link')
                    .attr('d', d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x))
                    .attr('fill', 'none')
                    .attr('stroke', '#999')
                    .attr('stroke-width', 1);
                
                // Nodes
                const node = svg.selectAll('.node')
                    .data(root.descendants())
                    .enter().append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.y},${d.x})`);
                
                node.append('circle')
                    .attr('r', 4)
                    .attr('fill', '#69b3a2');
                
                node.append('text')
                    .attr('dx', 8)
                    .attr('dy', 3)
                    .text(d => d.data.name)
                    .attr('font-size', '10px')
                    .attr('fill', '#333');
                
                console.log('Dendogram rendered successfully');
                
            } catch (error) {
                console.error('Error rendering dendogram:', error);
            }
        }

        // Initialize demo when page loads
        document.addEventListener('DOMContentLoaded', initializeDemo);
    </script>
</body>
</html>
