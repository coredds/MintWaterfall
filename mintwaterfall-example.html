<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MintWaterfall v0.8.6 - Advanced Data Processing</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Load TypeScript-compiled MintWaterfall -->
    <script src="./dist/mintwaterfall.umd.js"></script>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 10px;
            background: #147B58;
            color: white;
            min-height: 100vh;
            line-height: 1.6;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin: 10px auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
            max-width: 1200px;
            text-align: center;
            width: 100%;
        }

        /* Responsive container for charts */
        .chart-wrapper {
            width: 100%;
            overflow-x: auto;
            margin: 15px 0;
            /* Remove fixed min-height to prevent empty space */
        }

        /* Ensure SVG charts are visible and responsive */
        svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            /* Prevent iOS Safari from hiding SVG content */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        .waterfall-container {
            background: white;
        }

        /* Grid styling */
        .grid-line {
            stroke: rgba(224, 224, 224, 0.5); /* 50% transparency */
            stroke-width: 1;
        }

        /* Axis styling */
        .x-axis, .y-axis {
            font-size: 12px;
        }

        .x-axis text, .y-axis text {
            fill: #333;
        }

        .x-axis path, .y-axis path,
        .x-axis line, .y-axis line {
            stroke: #666;
            stroke-width: 1;
        }

        /* Bar styling */
        .bar-group rect {
            stroke: none;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .bar-group rect:hover {
            opacity: 0.8;
        }

        /* Label styling */
        .total-label {
            font-size: 12px;
            font-weight: bold;
            fill: #333;
        }

        .stack-label {
            font-size: 10px;
            fill: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }

        /* Connector styling */
        .connector {
            stroke: #666;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }

        /* Tooltip styling */
        .mintwaterfall-tooltip {
            position: absolute;
            visibility: hidden;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 250px;
            line-height: 1.4;
        }

        .mintwaterfall-tooltip .tooltip-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 6px;
            color: #4CAF50;
        }

        .mintwaterfall-tooltip .tooltip-value {
            font-size: 16px;
            font-weight: bold;
            margin: 4px 0;
        }

        .mintwaterfall-tooltip .tooltip-detail {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 4px;
        }

        /* Controls - Responsive */
        .controls {
            margin: 20px 0;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        button {
            background: linear-gradient(45deg, #147B58, #1a9d6b);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(20, 123, 88, 0.3);
            min-width: 120px;
            white-space: nowrap;
        }

        button:hover {
            background: linear-gradient(45deg, #1a9d6b, #20b377);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(20, 123, 88, 0.4);
        }

        /* Feature controls - override inline styles */
        .feature-controls {
            margin: 15px 0 !important;
            padding: 15px !important;
            background: #f8f9fa !important;
            border-radius: 8px !important;
            border-left: 4px solid #147B58 !important;
            text-align: center;
        }

        .feature-controls h4 {
            margin: 0 0 10px 0 !important;
            color: #147B58 !important;
            font-size: 16px;
        }

        .feature-controls > div {
            display: flex !important;
            flex-wrap: wrap !important;
            gap: 10px !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .control-group {
            background: rgba(20, 123, 88, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(20, 123, 88, 0.2);
            text-align: center;
        }

        .control-group h4 {
            margin: 0 0 10px 0;
            color: #147B58;
            font-size: 16px;
        }

        .feature-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        button:active {
            transform: translateY(0px);
        }

        .theme-selector {
            margin: 10px 0;
        }

        .theme-selector select {
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: white;
            color: #333;
            font-family: 'Roboto', sans-serif;
        }

        .export-controls {
            margin: 15px 0;
            text-align: center;
        }

        .export-btn {
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
            margin: 3px;
            padding: 8px 16px;
            font-size: 12px;
        }

        .export-btn:hover {
            background: linear-gradient(45deg, #9b59b6, #a569bd);
        }

        .animation-btn {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
        }

        .animation-btn:hover {
            background: linear-gradient(45deg, #f39c12, #f1c40f);
        }

        /* Responsive Typography */
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            line-height: 1.2;
        }

        h2 {
            color: #333;
            border-bottom: 3px solid #147B58;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: clamp(1.4rem, 3vw, 1.8rem);
            line-height: 1.3;
        }

        h3 {
            color: #147B58;
            margin: 20px 0 15px 0;
            font-weight: 500;
            font-size: clamp(1.2rem, 2.5vw, 1.4rem);
            line-height: 1.4;
        }

        p {
            font-size: clamp(0.9rem, 2vw, 1rem);
            line-height: 1.6;
            margin: 10px 0;
        }

        /* Responsive Breakpoints */
        /* iPad and tablet styles */
        @media (max-width: 1024px) and (min-width: 769px) {
            .chart-container {
                padding: 20px;
                margin: 15px auto;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                /* Remove min-height for tablets */
            }
            
            svg {
                width: 100% !important;
                max-width: 900px !important;
                height: auto !important;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .chart-container {
                padding: 15px;
                margin: 5px auto;
                border-radius: 10px;
            }
            
            .controls {
                gap: 8px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 13px;
                min-width: 100px;
            }
            
            .feature-controls {
                margin: 10px 0 !important;
                padding: 10px !important;
            }
            
            .control-group {
                padding: 12px;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                /* Remove min-height for mobile */
            }
        }

        @media (max-width: 480px) {
            .chart-container {
                padding: 10px;
                border-radius: 8px;
            }
            
            button {
                padding: 6px 12px;
                font-size: 12px;
                min-width: 80px;
            }
            
            .control-group {
                padding: 10px;
            }
            
            .control-group h4 {
                font-size: 14px;
            }
            
            .feature-controls {
                margin: 5px 0 !important;
                padding: 8px !important;
            }
            
            .feature-controls h4 {
                margin: 0 0 5px 0 !important;
                font-size: 14px !important;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin: 10px 0; /* Reduce margin on mobile */
                /* Remove min-height for small mobile */
            }
            
            svg {
                min-width: 320px; /* Minimum width for mobile */
                width: auto !important;
                height: auto !important;
            }
        }
    </style>
</head>
<body>
    <h1>MintWaterfall v0.8.6 - Advanced Data Processing</h1>
    
    <!-- Chart 1: Revenue Analysis -->
    <div class="chart-container">
        <h2>Revenue Analysis</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Comprehensive waterfall chart demonstration showing revenue flow and changes
        </p>
        <div class="theme-selector">
            <label>Theme: </label>
            <select onchange="changeTheme('chart1', this.value)">
                <option value="default" selected>Default</option>
                <option value="dark">Dark</option>
                <option value="corporate">Corporate</option>
                <option value="accessible">Accessible</option>
                <option value="colorful">Colorful</option>
            </select>
        </div>
        
        <!-- Interactive Feature Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #147B58;">
            <h4 style="margin: 0 0 10px 0; color: #147B58;">Interactive Features</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;">
                <button onclick="toggleAccessibility('chart1')" id="accessibility-btn-chart1" style="background: linear-gradient(45deg, #2c3e50, #34495e);">Enable Accessibility</button>
                <button onclick="toggleTooltips('chart1')" id="tooltips-btn-chart1" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Enable Tooltips</button>
                <button onclick="toggleZoom('chart1')" id="zoom-btn-chart1" style="background: linear-gradient(45deg, #e67e22, #f39c12);">Enable Zoom & Pan</button>
                <select onchange="changeTooltipTheme('chart1', this.value)" id="tooltip-theme-chart1" style="padding: 8px; border-radius: 6px;">
                    <option value="default">Default Tooltip</option>
                    <option value="light">Light Tooltip</option>
                    <option value="minimal">Minimal Tooltip</option>
                    <option value="corporate">Corporate Tooltip</option>
                </select>
            </div>
        </div>
        
        <div class="chart-wrapper">
            <svg id="chart1" width="1100" height="400"></svg>
        </div>
        <div class="controls">
            <button onclick="toggleStacked('chart1')">Switch to Waterfall</button>
            <button onclick="toggleTotal('chart1')">Toggle Total</button>
            <button onclick="updateData('chart1')">Update Data</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart1', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart1', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart1', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart1', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 2: Cost Analysis -->
    <div class="chart-container">
        <h2>Budget Reduction Analysis - Decremental Waterfall Demo</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 10px;">
            📉 Decremental waterfall showing budget cuts and expense optimization • Advanced animations • Enterprise features • Real-time conditional formatting
        </p>
        
        <!-- Interactive Feature Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #147B58;">
            <h4 style="margin: 0 0 10px 0; color: #147B58;">Interactive Features</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;">
                <button onclick="toggleAccessibility('chart2')" id="accessibility-btn-chart2" style="background: linear-gradient(45deg, #2c3e50, #34495e);">Enable Accessibility</button>
                <button onclick="toggleTooltips('chart2')" id="tooltips-btn-chart2" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Enable Tooltips</button>
                <button onclick="toggleZoom('chart2')" id="zoom-btn-chart2" style="background: linear-gradient(45deg, #e67e22, #f39c12);">Enable Zoom & Pan</button>
                <select onchange="changeTooltipTheme('chart2', this.value)" id="tooltip-theme-chart2" style="padding: 8px; border-radius: 6px;">
                    <option value="default">Default Tooltip</option>
                    <option value="light">Light Tooltip</option>
                    <option value="minimal">Minimal Tooltip</option>
                    <option value="corporate">Corporate Tooltip</option>
                </select>
            </div>
        </div>
        <div class="chart-wrapper">
            <svg id="chart2" width="1100" height="400"></svg>
        </div>
        <div class="controls">
            <button onclick="toggleStacked('chart2')">Switch to Stacked</button>
            <button class="animation-btn" onclick="animateChart('chart2')">Animate</button>
            <button onclick="sortData('chart2')">Sort by Total</button>
            <button onclick="resetData('chart2')">Reset Order</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart2', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart2', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart2', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart2', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 3: Performance Data -->
    <div class="chart-container">
        <h2>Multi-Category Performance - Stacked</h2>
        <div class="theme-selector">
            <label>Theme: </label>
            <select onchange="changeTheme('chart3', this.value)">
                <option value="default">Default</option>
                <option value="dark">Dark</option>
                <option value="corporate">Corporate</option>
                <option value="accessible">Accessible</option>
                <option value="colorful" selected>Colorful</option>
            </select>
        </div>
        <svg id="chart3" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart3')">Switch to Waterfall</button>
            <button onclick="animateWithEasing('chart3', 'bounce')">Bounce Effect</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart3', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart3', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart3', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart3', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 4: Project Timeline -->
    <div class="chart-container">
        <h2>Project Timeline - Mixed Values</h2>
        <svg id="chart4" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart4')">Switch to Waterfall</button>
            <button onclick="toggleTotal('chart4')">Toggle Total</button>
            <button class="animation-btn" onclick="animateChart('chart4')">Animate</button>
        </div>
    </div>

    <!-- Chart 5: Complex Data -->
    <div class="chart-container">
        <h2>Complex Breakdown - Many Stacks</h2>
        <svg id="chart5" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart5')">Switch to Waterfall</button>
            <button onclick="generateRandomData('chart5')">Generate Data</button>
        </div>
    </div>

    <!-- Enhanced Features Demo Chart -->
    <div class="chart-container">
        <h2>Enhanced Features Demo - Brush Selection & Staggered Animations</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Drag to select data ranges - Staggered animations - Advanced scales
        </p>
        <svg id="chartAdvanced" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStaggered('chartAdvanced')">Toggle Staggered Animation</button>
            <button onclick="clearBrushSelection('chartAdvanced')">Clear Selection</button>
            <button onclick="changeScaleType('chartAdvanced')">Toggle Scale Type</button>
            <button onclick="updateAdvancedData('chartAdvanced')">Update Data</button>
        </div>
        <div id="selection-info" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 4px; display: none;">
            <strong>Selection Summary:</strong>
            <div id="selection-details"></div>
        </div>
    </div>



    <!-- NEW: Advanced Data Processing Demo Chart -->
    <div class="chart-container">
        <h2>Advanced D3.js Data Processing Features</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Multi-dimensional grouping, temporal aggregation, cross-tabulation, and financial analysis
        </p>
        
        <!-- Advanced Data Processing Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 20px; background: linear-gradient(135deg, #e8f5e8, #f0f8f0); border-radius: 12px; border-left: 5px solid #27ae60;">
            <h4 style="margin: 0 0 15px 0; color: #27ae60; font-size: 18px;">📊 Advanced D3.js Data Operations</h4>
            
            <div class="control-group" style="margin-bottom: 15px;">
                <h4>Core D3.js Functions</h4>
                <div class="feature-buttons">
                    <button onclick="demonstrateGroupRollup('chartAdvancedData')" style="background: linear-gradient(45deg, #3498db, #2980b9);">d3.group() & d3.rollup()</button>
                    <button onclick="demonstrateFlatRollup('chartAdvancedData')" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">d3.flatRollup()</button>
                    <button onclick="demonstrateCrossIndex('chartAdvancedData')" style="background: linear-gradient(45deg, #f39c12, #e67e22);">d3.cross() & d3.index()</button>
                    <button onclick="demonstrateTemporalAgg('chartAdvancedData')" style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">Temporal Aggregation</button>
                </div>
            </div>
            
            <div class="control-group" style="margin-bottom: 15px;">
                <h4>Waterfall-Specific Helpers</h4>
                <div class="feature-buttons">
                    <button onclick="demonstrateRevenueWaterfall('chartAdvancedData')" style="background: linear-gradient(45deg, #27ae60, #2ecc71);">Revenue Waterfall</button>
                    <button onclick="demonstrateVarianceWaterfall('chartAdvancedData')" style="background: linear-gradient(45deg, #e67e22, #f39c12);">Variance Analysis</button>
                    <button onclick="demonstrateComparisonWaterfall('chartAdvancedData')" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Period Comparison</button>
                    <button onclick="demonstrateBreakdownWaterfall('chartAdvancedData')" style="background: linear-gradient(45deg, #34495e, #2c3e50);">Breakdown Analysis</button>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Financial Analysis</h4>
                <div class="feature-buttons">
                    <button onclick="demonstrateFinancialReducers('chartAdvancedData')" style="background: linear-gradient(45deg, #16a085, #1abc9c);">Financial Reducers</button>
                    <button onclick="demonstrateTransformData('chartAdvancedData')" style="background: linear-gradient(45deg, #d35400, #e74c3c);">Transaction Transform</button>
                    <button onclick="resetAdvancedDemo('chartAdvancedData')" style="background: linear-gradient(45deg, #95a5a6, #7f8c8d);">Reset Demo</button>
                </div>
            </div>
        </div>
        
        <svg id="chartAdvancedData" width="1100" height="400"></svg>
        
        <div class="controls">
            <button onclick="toggleStacked('chartAdvancedData')">Switch Mode</button>
            <button onclick="animateChart('chartAdvancedData')">Animate</button>
            <button onclick="generateAdvancedSampleData('chartAdvancedData')">Generate Sample Data</button>
        </div>
        
        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #27ae60;">
            <h4 style="color: #27ae60; margin: 0 0 10px 0;">💡 Current Demonstration</h4>
            <div id="advanced-demo-info" style="color: #666; font-size: 14px; line-height: 1.5;">
                <strong>Ready:</strong> Click any button above to see advanced D3.js data processing in action! Each demo transforms raw data using different D3.js functions and displays the results as waterfall charts.
            </div>
        </div>
        
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chartAdvancedData', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chartAdvancedData', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chartAdvancedData', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chartAdvancedData', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Trend Line Demo Chart -->
    <div class="chart-container">
        <h2>Trend Line Overlays - Interactive Demonstration</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Visualize trends with linear, moving average, and polynomial overlays - Real-time configuration
        </p>
        
        <!-- Trend Line Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 20px; background: linear-gradient(135deg, #f8f9fa, #e3f2fd); border-radius: 12px; border-left: 5px solid #147B58;">
            <h4 style="margin: 0 0 15px 0; color: #147B58; font-size: 18px;">📊 Trend Line Configuration</h4>
            
            <div class="control-group" style="margin-bottom: 15px;">
                <h4>Trend Line Type</h4>
                <div class="feature-buttons">
                    <button onclick="setTrendLine('chartTrend', 'linear')" id="linear-btn" style="background: linear-gradient(45deg, #3498db, #2980b9);">Linear Trend</button>
                    <button onclick="setTrendLine('chartTrend', 'moving-average')" id="moving-btn" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">Moving Average</button>
                    <button onclick="setTrendLine('chartTrend', 'polynomial')" id="polynomial-btn" style="background: linear-gradient(45deg, #f39c12, #e67e22);">Polynomial</button>
                    <button onclick="setTrendLine('chartTrend', 'none')" id="none-btn" style="background: linear-gradient(45deg, #95a5a6, #7f8c8d);">No Trend</button>
                </div>
            </div>
            
            <div class="control-group" style="margin-bottom: 15px;">
                <h4>Styling Options</h4>
                <div class="feature-buttons">
                    <select onchange="changeTrendColor('chartTrend', this.value)" id="color-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; margin-right: 10px;">
                        <option value="#e74c3c">Red</option>
                        <option value="#3498db">Blue</option>
                        <option value="#2ecc71">Green</option>
                        <option value="#f39c12">Orange</option>
                        <option value="#9b59b6">Purple</option>
                        <option value="#1abc9c">Teal</option>
                        <option value="#34495e">Dark Gray</option>
                    </select>
                    <select onchange="changeTrendWidth('chartTrend', this.value)" id="width-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; margin-right: 10px;">
                        <option value="2">Thin (2px)</option>
                        <option value="3" selected>Medium (3px)</option>
                        <option value="4">Thick (4px)</option>
                        <option value="5">Extra Thick (5px)</option>
                    </select>
                    <select onchange="changeTrendStyle('chartTrend', this.value)" id="style-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd;">
                        <option value="solid">Solid Line</option>
                        <option value="dashed">Dashed Line</option>
                        <option value="dotted">Dotted Line</option>
                    </select>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Advanced Settings</h4>
                <div class="feature-buttons">
                    <label style="margin-right: 15px; color: #147B58; font-weight: 500;">
                        Moving Average Window: 
                        <input type="range" min="2" max="5" value="3" onchange="changeTrendWindow('chartTrend', this.value)" id="window-slider" style="margin-left: 5px;">
                        <span id="window-value">3</span>
                    </label>
                    <label style="margin-right: 15px; color: #147B58; font-weight: 500;">
                        Polynomial Degree: 
                        <input type="range" min="2" max="4" value="2" onchange="changeTrendDegree('chartTrend', this.value)" id="degree-slider" style="margin-left: 5px;">
                        <span id="degree-value">2</span>
                    </label>
                    <button onclick="animateTrendChange('chartTrend')" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Animate Trend Change</button>
                </div>
            </div>
        </div>
        
        <svg id="chartTrend" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chartTrend')">Switch Mode</button>
            <button onclick="generateTrendData('chartTrend')">Generate New Data</button>
            <button class="animation-btn" onclick="animateChart('chartTrend')">Animate Chart</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chartTrend', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'csv')">Export CSV</button>
        </div>
        
        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db;">
            <h4 style="color: #3498db; margin: 0 0 10px 0;">💡 Trend Line Information</h4>
            <div id="trend-info" style="color: #666; font-size: 14px; line-height: 1.5;">
                <strong>Current:</strong> No trend line selected. Choose a trend type above to see overlays on your data.
            </div>
        </div>
    </div>


    <script>
        // MintWaterfall v0.8.6 Advanced Data Processing implementation loaded via UMD
        try {
            console.log('📦 Starting v0.8.6 TypeScript module initialization...');
            
            // Access from the global namespace (loaded via UMD script)
            const waterfallChart = window.waterfallChart || (window.MintWaterfall && window.MintWaterfall.waterfallChart);
            console.log('✅ waterfallChart accessed from TypeScript build:', typeof waterfallChart);
            
            if (!waterfallChart) {
                throw new Error('waterfallChart not found in global scope');
            }
            
            // For the example, we'll use the main chart function and create mock modules
            // since the bundled version includes everything in one file
            const themes = {
                default: { 
                    name: 'Default',
                    colors: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f']
                },
                dark: { 
                    name: 'Dark',
                    colors: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5']
                },
                colorful: { 
                    name: 'Colorful',
                    colors: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf']
                },
                minimal: { 
                    name: 'Minimal',
                    colors: ['#404040', '#707070', '#a0a0a0', '#d0d0d0', '#606060', '#909090', '#c0c0c0', '#808080']
                }
            };
            
            const applyTheme = (chart, themeName) => {
                console.log(`Applying theme: ${themeName}`);
                return chart;
            };
            
            const dataProcessor = {
                transformToWaterfallFormat: (data) => data,
                validateData: (data) => Array.isArray(data),
                processStacks: (data) => data
            };
            
            const animationSystem = {
                animate: (selection, options) => selection,
                setEasing: (easing) => console.log(`Setting easing: ${easing}`),
                setDuration: (duration) => console.log(`Setting duration: ${duration}`)
            };
            
            const createTooltipSystem = () => ({
                show: (event, data) => console.log('Showing tooltip:', data),
                hide: () => console.log('Hiding tooltip'),
                configure: (options) => console.log('Configuring tooltip:', options)
            });
            
            const createAccessibilitySystem = () => ({
                enable: () => console.log('Enabling accessibility'),
                configure: (options) => console.log('Configuring accessibility:', options)
            });
            
            const createExportSystem = () => ({
                exportSVG: (chart) => console.log('Exporting SVG'),
                exportPNG: (chart) => console.log('Exporting PNG'),
                exportJSON: (chart) => console.log('Exporting JSON'),
                exportCSV: (chart) => console.log('Exporting CSV')
            });
            
            const createZoomSystem = () => ({
                enable: () => console.log('Enabling zoom'),
                configure: (options) => console.log('Configuring zoom:', options)
            });
            
            const createZoomControls = () => ({
                enable: () => console.log('Enabling zoom controls')
            });
            
            
            const performanceManager = {
                enableOptimization: () => console.log('Enabling performance optimization'),
                getMetrics: () => ({ renderTime: 0, memoryUsage: 0 })
            };

            // Now initialize charts with TypeScript modules available
            initializeCharts(waterfallChart, themes, applyTheme, dataProcessor, animationSystem, 
                           createTooltipSystem, createAccessibilitySystem, createExportSystem, 
                           createZoomSystem, createZoomControls, performanceManager);
            
        } catch (error) {
            console.error('❌ TypeScript module import failed:', error);
            console.log('🔄 Falling back to basic chart initialization...');
            initializeBasicCharts();
        }
        
        function initializeCharts(waterfallChart, themes, applyTheme, dataProcessor, animationSystem, 
                                createTooltipSystem, createAccessibilitySystem, createExportSystem, 
                                createZoomSystem, createZoomControls, performanceManager) {
            console.log('🚀 Initializing v0.8.6 TypeScript enterprise charts with new features...');

            // Test D3 availability first
            console.log('🔍 D3 availability:', typeof d3, d3?.version || 'no version');
            console.log('🔍 D3 advanced functions:', {
                group: typeof d3.group,
                rollup: typeof d3.rollup,
                flatRollup: typeof d3.flatRollup,
                cross: typeof d3.cross,
                index: typeof d3.index,
                timeMonth: typeof d3.timeMonth
            });
            
            // Test chart function
            console.log('🔍 waterfallChart function:', typeof waterfallChart);
            if (typeof waterfallChart === 'function') {
                try {
                    const testChart = waterfallChart();
                    console.log('✅ waterfallChart() works:', typeof testChart, testChart);
                } catch (error) {
                    console.error('❌ Error creating test chart:', error);
                }
            }

            // Create enterprise feature system instances
            const tooltipSystem = createTooltipSystem();
            const accessibilitySystem = createAccessibilitySystem();
            const exportSystem = createExportSystem();
            const zoomSystem = createZoomSystem();

            // Test chart availability
            console.log('🔍 Testing chart function availability:', typeof waterfallChart);
            if (typeof waterfallChart === 'function') {
                const testChart = waterfallChart();
                console.log('✅ Chart function works, test chart created:', testChart);
            } else {
                console.error('❌ Chart function not available!');
                return;
            }

        // Sample revenue data for waterfall demonstration
        let revenueData = [
            {
                label: "Q1 Sales",
                stacks: [
                    { value: 45, color: "#3498db", label: "Direct: 45" },
                    { value: 25, color: "#2ecc71", label: "Online: 25" }
                ],
                breakdown: [
                    { label: "North America", stacks: [{ value: 35, color: "#3498db" }] },
                    { label: "Europe", stacks: [{ value: 20, color: "#2ecc71" }] },
                    { label: "Asia Pacific", stacks: [{ value: 15, color: "#e74c3c" }] }
                ]
            },
            {
                label: "Q2 Growth",
                stacks: [
                    { value: 30, color: "#e74c3c", label: "Expansion: 30" }
                ],
                breakdown: [
                    { label: "New Products", stacks: [{ value: 18, color: "#e74c3c" }] },
                    { label: "Market Expansion", stacks: [{ value: 12, color: "#f39c12" }] }
                ]
            },
            {
                label: "Q3 Expansion",
                stacks: [
                    { value: 20, color: "#f39c12", label: "New Markets: 20" },
                    { value: 15, color: "#9b59b6", label: "Products: 15" }
                ],
                breakdown: [
                    { label: "Enterprise Sales", stacks: [{ value: 22, color: "#f39c12" }] },
                    { label: "SMB Growth", stacks: [{ value: 13, color: "#9b59b6" }] }
                ]
            },
            {
                label: "Q4 Holiday",
                stacks: [
                    { value: 40, color: "#1abc9c", label: "Seasonal: 40" }
                ],
                breakdown: [
                    { label: "Black Friday", stacks: [{ value: 25, color: "#1abc9c" }] },
                    { label: "Cyber Monday", stacks: [{ value: 15, color: "#16a085" }] }
                ]
            },
            {
                label: "Q5 Enterprise",
                stacks: [
                    { value: 35, color: "#e67e22", label: "B2B: 35" },
                    { value: 18, color: "#95a5a6", label: "Partnerships: 18" }
                ]
            },
            {
                label: "Q6 International",
                stacks: [
                    { value: 28, color: "#34495e", label: "Export: 28" }
                ]
            },
            {
                label: "Q7 Digital",
                stacks: [
                    { value: 22, color: "#8e44ad", label: "Mobile: 22" },
                    { value: 16, color: "#d35400", label: "Web: 16" }
                ]
            }
        ];

        // DECREMENTAL WATERFALL: Budget Reduction Analysis
        let costData = [
            {
                label: "Initial Budget",
                stacks: [
                    { value: 500, color: "#2ecc71", label: "Total Budget: $500K" }
                ]
            },
            {
                label: "Marketing Cuts",
                stacks: [
                    { value: -25, color: "#e74c3c", label: "Digital Ads: -$25K" },
                    { value: -20, color: "#c0392b", label: "Events: -$20K" }
                ]
            },
            {
                label: "Staff Optimization",
                stacks: [
                    { value: -35, color: "#e67e22", label: "Contractors: -$35K" }
                ]
            },
            {
                label: "Office Reduction",
                stacks: [
                    { value: -18, color: "#f39c12", label: "Rent: -$18K" },
                    { value: -10, color: "#f1c40f", label: "Utilities: -$10K" }
                ]
            },
            {
                label: "Tech Savings",
                stacks: [
                    { value: -12, color: "#9b59b6", label: "Software: -$12K" },
                    { value: -10, color: "#8e44ad", label: "Hardware: -$10K" }
                ]
            },
            {
                label: "Process Efficiency",
                stacks: [
                    { value: -12, color: "#34495e", label: "Automation: -$12K" },
                    { value: -6, color: "#2c3e50", label: "Outsourcing: -$6K" }
                ]
            }
        ];

        let performanceData = [
            {
                label: "Product A",
                stacks: [
                    { value: 35, color: "#3498db", label: "Sales: 35M" },
                    { value: 15, color: "#2ecc71", label: "Profit: 15M" },
                    { value: 8, color: "#f39c12", label: "Growth: 8%" }
                ]
            },
            {
                label: "Product B",
                stacks: [
                    { value: 28, color: "#3498db", label: "Sales: 28M" },
                    { value: 22, color: "#2ecc71", label: "Profit: 22M" },
                    { value: 12, color: "#f39c12", label: "Growth: 12%" }
                ]
            },
            {
                label: "Product C",
                stacks: [
                    { value: 45, color: "#3498db", label: "Sales: 45M" },
                    { value: 18, color: "#2ecc71", label: "Profit: 18M" },
                    { value: 6, color: "#f39c12", label: "Growth: 6%" }
                ]
            },
            {
                label: "Product D",
                stacks: [
                    { value: 32, color: "#3498db", label: "Sales: 32M" },
                    { value: 14, color: "#2ecc71", label: "Profit: 14M" },
                    { value: 18, color: "#f39c12", label: "Growth: 18%" }
                ]
            },
            {
                label: "Product E",
                stacks: [
                    { value: 41, color: "#3498db", label: "Sales: 41M" },
                    { value: 19, color: "#2ecc71", label: "Profit: 19M" },
                    { value: 14, color: "#f39c12", label: "Growth: 14%" }
                ]
            },
            {
                label: "Product F",
                stacks: [
                    { value: 29, color: "#3498db", label: "Sales: 29M" },
                    { value: 16, color: "#2ecc71", label: "Profit: 16M" },
                    { value: 9, color: "#f39c12", label: "Growth: 9%" }
                ]
            },
            {
                label: "Product G",
                stacks: [
                    { value: 38, color: "#3498db", label: "Sales: 38M" },
                    { value: 21, color: "#2ecc71", label: "Profit: 21M" },
                    { value: 11, color: "#f39c12", label: "Growth: 11%" }
                ]
            }
        ];

        let projectData = [
            {
                label: "Planning",
                stacks: [
                    { value: 50, color: "#3498db", label: "Research: 50h" },
                    { value: 30, color: "#2ecc71", label: "Design: 30h" }
                ]
            },
            {
                label: "Development",
                stacks: [
                    { value: 120, color: "#e74c3c", label: "Backend: 120h" },
                    { value: 80, color: "#f39c12", label: "Frontend: 80h" },
                    { value: 40, color: "#9b59b6", label: "Testing: 40h" }
                ]
            },
            {
                label: "Integration",
                stacks: [
                    { value: 35, color: "#1abc9c", label: "API: 35h" },
                    { value: 20, color: "#34495e", label: "Database: 20h" }
                ]
            },
            {
                label: "Quality Assurance",
                stacks: [
                    { value: 45, color: "#e67e22", label: "Testing: 45h" },
                    { value: 25, color: "#95a5a6", label: "Review: 25h" }
                ]
            },
            {
                label: "Deployment",
                stacks: [
                    { value: 25, color: "#8e44ad", label: "Setup: 25h" },
                    { value: 15, color: "#d35400", label: "Config: 15h" }
                ]
            },
            {
                label: "Documentation",
                stacks: [
                    { value: 30, color: "#c0392b", label: "User Guide: 30h" },
                    { value: 20, color: "#16a085", label: "Tech Docs: 20h" }
                ]
            },
            {
                label: "Maintenance",
                stacks: [
                    { value: -20, color: "#e67e22", label: "Issues: -20h" },
                    { value: 30, color: "#27ae60", label: "Updates: 30h" }
                ]
            }
        ];

        let complexData = [
            {
                label: "Region A",
                stacks: [
                    { value: 25, color: "#3498db", label: "Q1: 25" },
                    { value: 30, color: "#2ecc71", label: "Q2: 30" },
                    { value: 22, color: "#e74c3c", label: "Q3: 22" },
                    { value: 35, color: "#f39c12", label: "Q4: 35" },
                    { value: 18, color: "#9b59b6", label: "Bonus: 18" }
                ]
            },
            {
                label: "Region B",
                stacks: [
                    { value: 40, color: "#3498db", label: "Q1: 40" },
                    { value: 28, color: "#2ecc71", label: "Q2: 28" },
                    { value: 32, color: "#e74c3c", label: "Q3: 32" },
                    { value: 45, color: "#f39c12", label: "Q4: 45" }
                ]
            },
            {
                label: "Region C",
                stacks: [
                    { value: 20, color: "#3498db", label: "Q1: 20" },
                    { value: 35, color: "#2ecc71", label: "Q2: 35" },
                    { value: 28, color: "#e74c3c", label: "Q3: 28" },
                    { value: 40, color: "#f39c12", label: "Q4: 40" },
                    { value: 15, color: "#9b59b6", label: "Special: 15" },
                    { value: 12, color: "#1abc9c", label: "Extra: 12" }
                ]
            },
            {
                label: "Region D",
                stacks: [
                    { value: 33, color: "#3498db", label: "Q1: 33" },
                    { value: 26, color: "#2ecc71", label: "Q2: 26" },
                    { value: 38, color: "#e74c3c", label: "Q3: 38" },
                    { value: 42, color: "#f39c12", label: "Q4: 42" }
                ]
            },
            {
                label: "Region E",
                stacks: [
                    { value: 29, color: "#3498db", label: "Q1: 29" },
                    { value: 34, color: "#2ecc71", label: "Q2: 34" },
                    { value: 31, color: "#e74c3c", label: "Q3: 31" },
                    { value: 37, color: "#f39c12", label: "Q4: 37" },
                    { value: 14, color: "#9b59b6", label: "Growth: 14" }
                ]
            },
            {
                label: "Region F",
                stacks: [
                    { value: 36, color: "#3498db", label: "Q1: 36" },
                    { value: 24, color: "#2ecc71", label: "Q2: 24" },
                    { value: 39, color: "#e74c3c", label: "Q3: 39" },
                    { value: 44, color: "#f39c12", label: "Q4: 44" }
                ]
            },
            {
                label: "Region G",
                stacks: [
                    { value: 27, color: "#3498db", label: "Q1: 27" },
                    { value: 32, color: "#2ecc71", label: "Q2: 32" },
                    { value: 25, color: "#e74c3c", label: "Q3: 25" },
                    { value: 41, color: "#f39c12", label: "Q4: 41" },
                    { value: 16, color: "#9b59b6", label: "Bonus: 16" },
                    { value: 11, color: "#1abc9c", label: "Extra: 11" }
                ]
            }
        ];

        // Trend line demo data - optimized for trend visualization
        let trendData = [
            {
                label: "Q1 2023",
                stacks: [
                    { value: 45, color: "#3498db", label: "Revenue: 45M" },
                    { value: 12, color: "#2ecc71", label: "Profit: 12M" }
                ]
            },
            {
                label: "Q2 2023",
                stacks: [
                    { value: 52, color: "#3498db", label: "Revenue: 52M" },
                    { value: 18, color: "#2ecc71", label: "Profit: 18M" }
                ]
            },
            {
                label: "Q3 2023",
                stacks: [
                    { value: 48, color: "#3498db", label: "Revenue: 48M" },
                    { value: 15, color: "#2ecc71", label: "Profit: 15M" }
                ]
            },
            {
                label: "Q4 2023",
                stacks: [
                    { value: 65, color: "#3498db", label: "Revenue: 65M" },
                    { value: 25, color: "#2ecc71", label: "Profit: 25M" }
                ]
            },
            {
                label: "Q1 2024",
                stacks: [
                    { value: 58, color: "#3498db", label: "Revenue: 58M" },
                    { value: 22, color: "#2ecc71", label: "Profit: 22M" }
                ]
            },
            {
                label: "Q2 2024",
                stacks: [
                    { value: 72, color: "#3498db", label: "Revenue: 72M" },
                    { value: 30, color: "#2ecc71", label: "Profit: 30M" }
                ]
            },
            {
                label: "Q3 2024",
                stacks: [
                    { value: 68, color: "#3498db", label: "Revenue: 68M" },
                    { value: 28, color: "#2ecc71", label: "Profit: 28M" }
                ]
            },
            {
                label: "Q4 2024",
                stacks: [
                    { value: 85, color: "#3498db", label: "Revenue: 85M" },
                    { value: 38, color: "#2ecc71", label: "Profit: 38M" }
                ]
            }
        ];



        // Chart configurations with enterprise features v0.8.6
        console.log('🔧 Creating chart configurations...');
        const charts = {
            chart1: {
                // RECREATED FROM SCRATCH - Simple waterfall configuration
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Total Revenue',
                    stacked: false,  // Waterfall mode
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 500
                },
                data: revenueData,
                currentTheme: 'default',
                accessibilityEnabled: false,
                tooltipsEnabled: false
            },
            chart2: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Optimized Budget',
                    stacked: false,  // WATERFALL MODE - back to original
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 800
                },
                data: costData,
                currentTheme: 'default',
                accessibilityEnabled: false,
                tooltipsEnabled: false,
                currentTooltipTheme: 'default'
            },
            chart3: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Total Performance',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750
                },
                data: performanceData,
                currentTheme: 'colorful'
            },
            chart4: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Project Total',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750
                },
                data: projectData,
                currentTheme: 'default'
            },
            chart5: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Grand Total',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750
                },
                data: complexData,
                currentTheme: 'default'
            },
            chartAdvanced: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Enhanced Total',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750,
                    enableBrush: true,
                    staggeredAnimations: true,
                    staggerDelay: 150
                },
                data: [...revenueData], // Clone revenue data
                currentTheme: 'default',
                currentScaleType: 'auto'
            },
            chartTrend: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Total with Trend',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750,
                    showTrendLine: false,
                    trendLineType: 'linear',
                    trendLineColor: '#e74c3c',
                    trendLineWidth: 3,
                    trendLineStyle: 'solid'
                },
                data: [...trendData], // Use trend-optimized data
                currentTheme: 'default',
                currentTrendType: 'none',
                trendSettings: {
                    color: '#e74c3c',
                    width: 3,
                    style: 'solid',
                    window: 3,
                    degree: 2
                }
            },
            chartAdvancedData: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Advanced Data Total',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750
                },
                data: [
                    { label: "Initial Data", stacks: [{ value: 100, color: "#95a5a6", label: "100" }] },
                    { label: "Click buttons above", stacks: [{ value: 50, color: "#bdc3c7", label: "50" }] },
                    { label: "to see advanced", stacks: [{ value: 75, color: "#ecf0f1", label: "75" }] },
                    { label: "data processing!", stacks: [{ value: 125, color: "#d5dbdb", label: "125" }] }
                ],
                currentTheme: 'default',
                currentDemo: 'initial'
            }
        };

        // Initialize charts - CHART1 RECREATED FROM SCRATCH
        console.log('🚀 Starting chart initialization...');
        Object.keys(charts).forEach(chartId => {
            const chartConfig = charts[chartId];
            const { config, data, currentTheme } = chartConfig;
            
            console.log(`🔧 Initializing ${chartId}:`, {
                dataLength: data?.length || 0,
                firstItem: data?.[0] || 'undefined',
                config: config
            });

            // Check if chart element exists
            const chartElement = document.getElementById(chartId);
            console.log(`📍 Chart element ${chartId}:`, chartElement ? 'found' : 'NOT FOUND');
            
            if (!chartElement) {
                console.error(`❌ Chart element ${chartId} not found in DOM!`);
                return;
            }

                    // Check if data is valid - WATERFALL CHARTS ONLY
        {
            // Regular waterfall charts expect array with stacks
            if (!Array.isArray(data) || data.length === 0) {
                console.error(`❌ Chart ${chartId} has invalid data:`, data);
                return;
            }
            
            // Validate data structure
            const hasValidStructure = data.every(item => 
                item && 
                typeof item.label === 'string' && 
                Array.isArray(item.stacks) && 
                item.stacks.length > 0
            );
            
            if (!hasValidStructure) {
                console.error(`❌ Chart ${chartId} has invalid data structure:`, data);
                return;
            }
        }

                    // Continue with waterfall chart initialization

            // CHART1 RECREATION: Simple, clean chart creation
            if (chartId === 'chart1') {
                console.log(`🆕 RECREATING chart1 from scratch...`);
                
                try {
                    // Create brand new chart instance
                    const chart = waterfallChart()
                        .width(config.width)
                        .height(config.height)
                        .showTotal(config.showTotal)
                        .totalLabel(config.totalLabel)
                        .stacked(false)  // Force waterfall mode
                        .barPadding(config.barPadding)
                        .duration(config.duration);
                    
                    // Store the chart instance
                    chartConfig.chart = chart;
                    
                    console.log(`✅ New chart1 instance created`);
                    
                    // Simple render - no enterprise features, no complexity
                    const selection = d3.select('#chart1');
                    selection.selectAll("*").remove(); // Clear everything
                    
                    setTimeout(() => {
                        selection.datum(data).call(chart);
                        console.log(`✅ chart1 rendered fresh`);
                    }, 100);
                    
                } catch (error) {
                    console.error(`❌ Error creating chart1:`, error);
                    return;
                }
                
                return; // Skip the rest of the complex logic for chart1
            }

            // For other charts, use the existing logic
            // Create chart instance with configuration
            console.log(`🏗️ Creating chart instance for ${chartId}`);
            try {
                let chart = waterfallChart()
                    .width(config.width)
                    .height(config.height)
                    .showTotal(config.showTotal)
                    .totalLabel(config.totalLabel)
                    .stacked(config.stacked)
                    .enableAccessibility(config.accessibility)
                    .enableTooltips(config.tooltips)
                    .barPadding(config.barPadding)
                    .duration(config.duration);
                
                // Add optional advanced features if they exist in config
                if (config.enableBrush) {
                    chart = chart.enableBrush(config.enableBrush);
                }
                if (config.staggeredAnimations) {
                    chart = chart.staggeredAnimations(config.staggeredAnimations);
                }
                if (config.staggerDelay) {
                    chart = chart.staggerDelay(config.staggerDelay);
                }
                if (config.showTrendLine !== undefined) {
                    chart = chart.showTrendLine(config.showTrendLine);
                }
                if (config.trendLineType) {
                    chart = chart.trendLineType(config.trendLineType);
                }
                if (config.trendLineColor) {
                    chart = chart.trendLineColor(config.trendLineColor);
                }
                if (config.trendLineWidth) {
                    chart = chart.trendLineWidth(config.trendLineWidth);
                }
                if (config.trendLineStyle) {
                    chart = chart.trendLineStyle(config.trendLineStyle);
                }
                
                // Store the chart instance
                chartConfig.chart = chart;
                
                console.log(`✅ Chart instance created for ${chartId}:`, typeof chart);
            } catch (error) {
                console.error(`❌ Error creating chart for ${chartId}:`, error);
                return;
            }
            
            // Add event listeners
            chartConfig.chart.on('barClick', function(event, d) {
                const total = d.stacks.reduce((sum, s) => sum + s.value, 0);
                console.log(`Clicked on ${d.label}: ${total}`);
                
                // Enhanced click behavior for enterprise charts
                if ((chartId === 'chart1' || chartId === 'chart2') && d.breakdown) {
                    console.group(`🏢 Enterprise Breakdown - ${d.label}`);
                    console.log('Total Value:', total);
                    console.log('Breakdown Details:', d.breakdown);
                    console.groupEnd();
                    alert(`🏢 Enterprise Click: ${d.label}: ${total}\n📊 Breakdown available - Check console for details`);
                } else {
                    alert(`Clicked on ${d.label}: ${total}`);
                }
            });

            // Initialize enterprise features for chart1 and chart2
            if (chartId === 'chart1' || chartId === 'chart2') {
                // REMOVED: Pre-configure breakdown analysis that was breaking charts
                // The breakdown analysis will be configured when the user clicks the button
                
                console.log(`🏢 Enterprise features available for ${chartId} (breakdown on-demand)`);
            }

            // Enhanced features for advanced chart
            if (chartId === 'chartAdvanced') {
                chartConfig.chart.on('brushSelection', function(event, selectionData) {
                    const infoDiv = document.getElementById('selection-info');
                    const detailsDiv = document.getElementById('selection-details');
                    
                    if (selectionData.data.length > 0) {
                        infoDiv.style.display = 'block';
                        detailsDiv.innerHTML = `
                            <div>Selected: ${selectionData.data.length} items</div>
                            <div>Total Value: ${selectionData.summary.sum.toFixed(2)}</div>
                            <div>Average: ${selectionData.summary.average.toFixed(2)}</div>
                            <div>Range: ${selectionData.summary.min.toFixed(2)} - ${selectionData.summary.max.toFixed(2)}</div>
                        `;
                    } else {
                        infoDiv.style.display = 'none';
                    }
                });
            }

            // Apply initial theme if specified
            if (currentTheme && currentTheme !== 'default' && themes[currentTheme]) {
                // Apply theme colors to data
                const theme = themes[currentTheme];
                if (theme && theme.colors && Array.isArray(data)) {
                    const themedData = data.map((item, itemIndex) => ({
                        ...item,
                        stacks: (item.stacks || []).map((stack, stackIndex) => ({
                            ...stack,
                            color: theme.colors[stackIndex % theme.colors.length]
                        }))
                    }));
                    
                    // Update chart configuration
                    if (chartConfig.chart.totalColor) {
                        chartConfig.chart.totalColor(theme.totalColor || '#333');
                    }
                    charts[chartId].data = themedData;
                    
                    // Render with themed data
                    d3.select(`#${chartId}`).datum(themedData).call(chartConfig.chart);
                    console.log(`🎨 ${chartId} rendered with themed data (${currentTheme}):`, themedData.length, 'items');
                } else {
                    console.log(`⚠️ ${chartId} theme application skipped - invalid theme or data`);
                    d3.select(`#${chartId}`).datum(data).call(chartConfig.chart);
                }
            } else {
                // Render with default data
                console.log(`📊 About to render ${chartId} with default data:`, data.length, 'items');
                console.log(`📊 Chart element for ${chartId}:`, document.getElementById(chartId));
                console.log(`📊 Chart function for ${chartId}:`, typeof chartConfig.chart, chartConfig.chart);
                
                // Debug the data structure
                console.log(`📊 Sample data for ${chartId}:`, {
                    firstItem: data[0],
                    dataStructure: data.map(d => ({
                        label: d.label,
                        stackCount: d.stacks?.length || 0,
                        totalValue: d.stacks?.reduce((sum, s) => sum + s.value, 0) || 0,
                        hasBreakdown: !!d.breakdown,
                        stackValues: d.stacks?.map(s => s.value) || []
                    })),
                    grandTotal: data.reduce((total, d) => 
                        total + (d.stacks?.reduce((sum, s) => sum + s.value, 0) || 0), 0
                    )
                });
                
                try {
                    const selection = d3.select(`#${chartId}`);
                    console.log(`📊 D3 selection for ${chartId}:`, selection.node());
                    
                    // TEMPORARY: Create a simple test bar manually to verify D3 works
                    if (chartId === 'chart1') {
                        console.log('🧪 Creating manual test bars for chart1');
                        
                        // Clear the SVG
                        selection.selectAll("*").remove();
                        
                        // Create simple test bars
                        const testData = [
                            { x: 100, y: 300, width: 60, height: 100, color: "#3498db" },
                            { x: 200, y: 250, width: 60, height: 150, color: "#e74c3c" },
                            { x: 300, y: 200, width: 60, height: 200, color: "#f39c12" }
                        ];
                        
                        selection.selectAll("rect")
                            .data(testData)
                            .enter()
                            .append("rect")
                            .attr("x", d => d.x)
                            .attr("y", d => d.y)
                            .attr("width", d => d.width)
                            .attr("height", d => d.height)
                            .attr("fill", d => d.color);
                        
                        console.log('✅ Manual test bars created for chart1');
                    } else {
                        // Add a small delay to ensure DOM is ready
                        setTimeout(() => {
                            const result = selection.datum(data).call(chartConfig.chart);
                            console.log(`✅ ${chartId} rendered successfully:`, result);
                            
                            // Check what was actually rendered
                            const renderedContent = selection.node().innerHTML;
                            console.log(`📊 Rendered content length for ${chartId}:`, renderedContent.length);
                            if (renderedContent.length < 100) {
                                console.warn(`⚠️ ${chartId} may not have rendered properly - content too short:`, renderedContent);
                            }
                        }, 100);
                    }
                } catch (error) {
                    console.error(`❌ Error rendering ${chartId}:`, error);
                }
            }
        });

        // FOCUS: Prioritizing waterfall chart functionality
        console.log('📊 Focusing on core waterfall chart functionality...');
        
        // REMOVED: Advanced data processing and performance charts not required for waterfall focus
        console.log('🚫 Skipping advanced data processing and performance charts - focusing on core waterfall functionality');

        // Interactive Feature Control Functions
        window.toggleAccessibility = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const newState = !chartConfig.accessibilityEnabled;
                chartConfig.accessibilityEnabled = newState;
                
                // Basic accessibility implementation
                const svgElement = document.querySelector(`#${chartId}`);
                if (svgElement) {
                    if (newState) {
                        // Add accessibility attributes
                        svgElement.setAttribute('role', 'img');
                        svgElement.setAttribute('aria-label', 'Waterfall chart showing data visualization');
                        svgElement.setAttribute('tabindex', '0');
                        
                        // Add keyboard navigation support
                        svgElement.addEventListener('keydown', function(event) {
                            if (event.key === 'Enter' || event.key === ' ') {
                                console.log('Chart selected via keyboard');
                            }
                        });
                    } else {
                        // Remove accessibility attributes
                        svgElement.removeAttribute('role');
                        svgElement.removeAttribute('aria-label');
                        svgElement.removeAttribute('tabindex');
                    }
                }
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text
                const button = document.getElementById(`accessibility-btn-${chartId}`);
                if (button) {
                    button.textContent = newState ? 'Disable Accessibility' : 'Enable Accessibility';
                    button.style.background = newState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #2c3e50, #34495e)';
                }
                
                console.log(`Chart ${chartId}: Accessibility ${newState ? 'enabled' : 'disabled'}`);
            }
        };

        window.toggleTooltips = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const newState = !chartConfig.tooltipsEnabled;
                chartConfig.tooltipsEnabled = newState;
                
                // Update chart configuration
                chartConfig.chart.enableTooltips(newState);
                
                // Configure tooltip theme if enabling
                if (newState) {
                    const tooltipConfig = {
                        theme: chartConfig.currentTooltipTheme,
                        content: undefined // Use default content
                    };
                    chartConfig.chart.tooltipConfig(tooltipConfig);
                }
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text
                const button = document.getElementById(`tooltips-btn-${chartId}`);
                if (button) {
                    button.textContent = newState ? 'Disable Tooltips' : 'Enable Tooltips';
                    button.style.background = newState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)';
                }
                
                console.log(`Chart ${chartId}: Tooltips ${newState ? 'enabled' : 'disabled'}`);
            }
        };

        window.changeTooltipTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.currentTooltipTheme = themeName;
                
                // Update tooltip configuration if tooltips are enabled
                if (chartConfig.tooltipsEnabled) {
                    const tooltipConfig = {
                        theme: themeName,
                        content: undefined // Use default content
                    };
                    chartConfig.chart.tooltipConfig(tooltipConfig);
                    
                    // Re-render chart to apply new tooltip theme
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                console.log(`Chart ${chartId}: Tooltip theme changed to ${themeName}`);
            }
        };

        // Global functions for UI controls
        window.changeTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig && themes[themeName]) {
                // Update the chart's current theme
                chartConfig.currentTheme = themeName;
                
                // Get the theme object
                const theme = themes[themeName];
                
                // Apply theme colors to the data
                const themedData = chartConfig.data.map((item, itemIndex) => ({
                    ...item,
                    stacks: item.stacks.map((stack, stackIndex) => ({
                        ...stack,
                        color: theme.colors[stackIndex % theme.colors.length]
                    }))
                }));
                
                // Update the chart configuration
                chartConfig.chart.totalColor(theme.totalColor);
                
                // Update the data and re-render
                chartConfig.data = themedData;
                d3.select(`#${chartId}`).datum(themedData).call(chartConfig.chart);
            }
        };

        window.exportChart = function(chartId, format) {
            try {
                const svg = d3.select(`#${chartId}`).node();
                const chartName = `mintwaterfall-${chartId}-${format}`;
                
                if (format === 'svg') {
                    // Export SVG with proper styling
                    const svgClone = svg.cloneNode(true);
                    
                    // Add inline styles to ensure proper rendering
                    const styleElement = document.createElementNS("http://www.w3.org/2000/svg", "style");
                    styleElement.textContent = `
                        .grid-line { stroke: rgba(224, 224, 224, 0.5); stroke-width: 1; }
                        .x-axis, .y-axis { font-size: 12px; font-family: Arial, sans-serif; }
                        .x-axis text, .y-axis text { fill: #333; }
                        .x-axis path, .y-axis path, .x-axis line, .y-axis line { stroke: #666; stroke-width: 1; }
                        .total-label { font-size: 12px; font-weight: bold; fill: #333; font-family: Arial, sans-serif; }
                        .stack-label { font-size: 10px; fill: white; font-family: Arial, sans-serif; }
                        .connector { stroke: #666; stroke-width: 1; stroke-dasharray: 3,3; }
                    `;
                    svgClone.insertBefore(styleElement, svgClone.firstChild);
                    
                    // Set proper SVG attributes
                    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                    
                    const svgData = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const svgUrl = URL.createObjectURL(svgBlob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = svgUrl;
                    downloadLink.download = `${chartName}.svg`;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(svgUrl);
                } else if (format === 'png') {
                    // Export PNG by converting SVG to canvas
                    const svgClone = svg.cloneNode(true);
                    
                    // Add inline styles for proper PNG rendering
                    const styleElement = document.createElementNS("http://www.w3.org/2000/svg", "style");
                    styleElement.textContent = `
                        .grid-line { stroke: rgba(224, 224, 224, 0.5); stroke-width: 1; }
                        .x-axis, .y-axis { font-size: 12px; font-family: Arial, sans-serif; }
                        .x-axis text, .y-axis text { fill: #333; }
                        .x-axis path, .y-axis path, .x-axis line, .y-axis line { stroke: #666; stroke-width: 1; }
                        .total-label { font-size: 12px; font-weight: bold; fill: #333; font-family: Arial, sans-serif; }
                        .stack-label { font-size: 10px; fill: white; font-family: Arial, sans-serif; }
                        .connector { stroke: #666; stroke-width: 1; stroke-dasharray: 3,3; }
                    `;
                    svgClone.insertBefore(styleElement, svgClone.firstChild);
                    
                    // Set proper SVG attributes
                    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                    
                    const svgData = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);
                    const img = new Image();
                    
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = parseInt(svg.getAttribute('width')) || 800;
                        canvas.height = parseInt(svg.getAttribute('height')) || 400;
                        
                        // Fill with white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw the SVG image
                        ctx.drawImage(img, 0, 0);
                        
                        // Download the PNG
                        canvas.toBlob(function(blob) {
                            const pngUrl = URL.createObjectURL(blob);
                            const downloadLink = document.createElement('a');
                            downloadLink.href = pngUrl;
                            downloadLink.download = `${chartName}.png`;
                            document.body.appendChild(downloadLink);
                            downloadLink.click();
                            document.body.removeChild(downloadLink);
                            URL.revokeObjectURL(pngUrl);
                        }, 'image/png');
                        
                        URL.revokeObjectURL(url);
                    };
                    
                    img.onerror = function() {
                        // Fallback: download as SVG instead
                        const svgUrl2 = URL.createObjectURL(svgBlob);
                        const downloadLink = document.createElement('a');
                        downloadLink.href = svgUrl2;
                        downloadLink.download = `${chartName}-fallback.svg`;
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        URL.revokeObjectURL(svgUrl2);
                        alert('PNG export failed, downloaded as SVG instead');
                        URL.revokeObjectURL(url);
                    };
                    
                    img.src = url;
                } else if (format === 'json') {
                    const data = JSON.stringify(charts[chartId].data, null, 2);
                    downloadData(data, `${chartName}.json`, 'application/json');
                } else if (format === 'csv') {
                    const csvData = convertToCSV(charts[chartId].data);
                    downloadData(csvData, `${chartName}.csv`, 'text/csv');
                } else {
                    alert(`${format.toUpperCase()} export not implemented`);
                }
            } catch (error) {
                console.error('Export error:', error);
                alert(`Export failed: ${error.message}`);
            }
        };

        window.toggleStacked = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentStacked = chartConfig.chart.stacked();
                const newMode = !currentStacked;
                
                // Debug: temporary alert to check values
                console.log(`Chart ${chartId}: Current stacked: ${currentStacked}, New mode: ${newMode}`);
                
                chartConfig.chart.stacked(newMode);
                
                // Force a complete re-render
                d3.select(`#${chartId}`).selectAll("*").remove();
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text to show next action
                const button = document.querySelector(`button[onclick="toggleStacked('${chartId}')"]`);
                if (button) {
                    const nextModeName = newMode ? 'Waterfall' : 'Stacked';
                    button.textContent = `Switch to ${nextModeName}`;
                }
            }
        };

        window.toggleTotal = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                console.log(`🔄 Toggling total for ${chartId}...`);
                console.log('Chart config:', chartConfig);
                console.log('Chart instance:', chartConfig.chart);
                
                if (!chartConfig.chart) {
                    console.error(`❌ Chart instance not found for ${chartId}`);
                    showFeedback(chartId, 'Chart not properly initialized', 'error');
                    return;
                }
                
                if (typeof chartConfig.chart.showTotal !== 'function') {
                    console.error(`❌ showTotal method not available for ${chartId}`);
                    showFeedback(chartId, 'showTotal method not available', 'error');
                    return;
                }
                
                try {
                    const currentTotal = chartConfig.chart.showTotal();
                    console.log(`Current showTotal state: ${currentTotal}`);
                    console.log(`Chart data length before toggle: ${chartConfig.data.length}`);
                    
                    chartConfig.chart.showTotal(!currentTotal);
                    chartConfig.config.showTotal = !currentTotal; // Update config too
                    
                    // Check if we're in stacked mode (which might make total less obvious)
                    const isStacked = chartConfig.chart.stacked();
                    console.log(`Chart is in stacked mode: ${isStacked}`);
                    
                    // Redraw the chart with updated showTotal setting
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                    
                    // Count bars after redraw
                    setTimeout(() => {
                        const barCount = d3.select(`#${chartId}`).selectAll('.bar-group').size();
                        console.log(`Number of bar groups after toggle: ${barCount}`);
                        console.log(`Expected: ${chartConfig.data.length} data + ${!currentTotal ? 1 : 0} total = ${chartConfig.data.length + (!currentTotal ? 1 : 0)}`);
                    }, 100);
                    
                    const newState = !currentTotal ? 'shown' : 'hidden';
                    showFeedback(chartId, `Total ${newState} (${isStacked ? 'stacked' : 'waterfall'} mode)`, 'success');
                    console.log(`✅ Total toggled to: ${newState}`);
                } catch (error) {
                    console.error(`❌ Error toggling total for ${chartId}:`, error);
                    showFeedback(chartId, 'Error toggling total: ' + error.message, 'error');
                }
            } else {
                console.error(`❌ Chart config not found for ${chartId}`);
            }
        };

        window.updateData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const updatedData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.abs(stack.value) + (Math.random() - 0.5) * 20))
                    }))
                }));
                
                chartConfig.data = updatedData;
                d3.select(`#${chartId}`).datum(updatedData).call(chartConfig.chart);
            }
        };

        window.animateChart = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Store original data and settings
                const originalData = JSON.parse(JSON.stringify(chartConfig.data));
                const originalDuration = chartConfig.chart.duration();
                const originalEase = chartConfig.chart.ease();
                
                // Create animation data with larger values for dramatic effect
                const animationData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: stack.value * 1.3, // Increase by 30%
                        label: stack.label
                    }))
                }));
                
                // First animation: bounce effect with larger values
                chartConfig.chart.duration(800).ease(d3.easeBounce);
                d3.select(`#${chartId}`).datum(animationData).call(chartConfig.chart);
                
                // Second animation: return to original with elastic effect
                setTimeout(() => {
                    chartConfig.chart.duration(1000).ease(d3.easeElastic);
                    d3.select(`#${chartId}`).datum(originalData).call(chartConfig.chart);
                }, 900);
                
                // Reset to original settings
                setTimeout(() => {
                    chartConfig.chart.duration(originalDuration).ease(originalEase);
                }, 2000);
            }
        };

        window.animateWithEasing = function(chartId, easingType) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                let easing;
                if (easingType === 'bounce') {
                    easing = d3.easeBounceOut;
                } else if (easingType === 'elastic') {
                    easing = d3.easeElasticOut;
                } else {
                    easing = d3.easeQuadInOut;
                }
                
                try {
                    // Store original data
                    const originalData = JSON.parse(JSON.stringify(chartConfig.data));
                    
                    // Create modified data with different values to animate from
                    const animationData = chartConfig.data.map(item => ({
                        ...item,
                        stacks: item.stacks.map(stack => ({
                            ...stack,
                            value: stack.value * 0.1 // Start with 10% of original values
                        }))
                    }));
                    
                    // First, quickly set to the reduced values
                    chartConfig.chart.duration(0);
                    d3.select(`#${chartId}`).datum(animationData).call(chartConfig.chart);
                    
                    // Then animate back to original values with the easing
                    setTimeout(() => {
                        chartConfig.chart.duration(1500).ease(easing);
                        d3.select(`#${chartId}`).datum(originalData).call(chartConfig.chart);
                        
                        // Reset to normal animation settings after
                        setTimeout(() => {
                            chartConfig.chart.duration(750).ease(d3.easeQuadInOut);
                        }, 1600);
                    }, 50);
                    
                    showFeedback(chartId, `Applied ${easingType} easing animation`, 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error applying easing: ' + error.message, 'error');
                }
            } else {
                showFeedback(chartId, 'No chart config found', 'error');
            }
        };

        window.sortData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Store original data if not already stored
                if (!chartConfig.originalData) {
                    chartConfig.originalData = JSON.parse(JSON.stringify(chartConfig.data));
                }
                
                const sortedData = dataProcessor.sortData(chartConfig.data, 'total', 'descending');
                chartConfig.data = sortedData;
                d3.select(`#${chartId}`).datum(sortedData).call(chartConfig.chart);
                
                showFeedback(chartId, 'Sorted by total value (waterfall order affects cumulative totals)', 'success');
            }
        };

        window.resetData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && chartConfig.originalData) {
                chartConfig.data = JSON.parse(JSON.stringify(chartConfig.originalData));
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
            } else {
                showFeedback(chartId, 'No original data to reset to', 'error');
            }
        };

        window.normalizeData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                try {
                    const normalizedData = dataProcessor.normalizeValues(chartConfig.data, 100);
                    chartConfig.data = normalizedData;
                    d3.select(`#${chartId}`).datum(normalizedData).call(chartConfig.chart);
                    
                    // Show visual feedback
                    showFeedback(chartId, 'Data normalized to max value of 100', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error normalizing data: ' + error.message, 'error');
                }
            } else {
                showFeedback(chartId, 'No chart config found', 'error');
            }
        };

        window.generateRandomData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const randomData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.random() * 50 + 10)),
                        label: `Random: ${Math.round(Math.random() * 50 + 10)}`
                    }))
                }));
                
                chartConfig.data = randomData;
                d3.select(`#${chartId}`).datum(randomData).call(chartConfig.chart);
            }
        };

        // ========================================
        // 🏢 ENTERPRISE FEATURE FUNCTIONS v0.8.6
        // ========================================

        window.toggleBreakdownAnalysis = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Enable breakdown analysis using the correct API
                chartConfig.chart.enableBreakdown('category', {
                    minGroupSize: 2,
                    sortStrategy: 'value',
                    showOthers: true,
                    maxGroups: 5
                });
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, '🔍 Breakdown analysis enabled! Click bars to explore hierarchical data', 'success');
                console.log(`📊 Enterprise: Breakdown analysis enabled for ${chartId}`);
            }
        };

        window.toggleConditionalFormatting = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Add conditional formatting rules using the correct API
                chartConfig.chart.addFormattingRule('highValue', {
                    condition: (d) => d.stacks.reduce((sum, s) => sum + s.value, 0) > 50,
                    style: {
                        fill: '#27ae60',
                        stroke: '#1e8449',
                        strokeWidth: 2,
                        opacity: 0.9
                    }
                });
                
                chartConfig.chart.addFormattingRule('lowValue', {
                    condition: (d) => d.stacks.reduce((sum, s) => sum + s.value, 0) < 20,
                    style: {
                        fill: '#e74c3c',
                        stroke: '#c0392b',
                        strokeWidth: 2,
                        opacity: 0.7
                    }
                });
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, '🎨 Conditional formatting applied! High values = Green, Low values = Red', 'success');
                console.log(`🎨 Enterprise: Conditional formatting enabled for ${chartId}`);
            }
        };

        window.runEnterprisePerformanceTest = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                showFeedback(chartId, '⚡ Running enterprise performance test with 50 data points...', 'info');
                
                // Generate large dataset for testing
                const testData = [];
                for (let i = 0; i < 50; i++) {
                    testData.push({
                        label: `Item ${i + 1}`,
                        stacks: [
                            { value: Math.random() * 100 + 20, color: `hsl(${i * 7.2}, 70%, 50%)`, label: `Value: ${Math.round(Math.random() * 100 + 20)}` }
                        ],
                        breakdown: i % 5 === 0 ? [
                            { label: `Sub-item A`, stacks: [{ value: Math.random() * 30, color: '#3498db' }] },
                            { label: `Sub-item B`, stacks: [{ value: Math.random() * 30, color: '#2ecc71' }] }
                        ] : undefined
                    });
                }
                
                const startTime = performance.now();
                
                // Apply breakdown and formatting
                chartConfig.chart.enableBreakdown('category', { maxGroups: 10 });
                chartConfig.chart.addFormattingRule('performance', {
                    condition: (d) => d.stacks[0].value > 80,
                    style: { fill: '#f39c12', strokeWidth: 3 }
                });
                
                // Render with performance timing
                d3.select(`#${chartId}`).datum(testData).call(chartConfig.chart);
                
                const endTime = performance.now();
                const renderTime = Math.round(endTime - startTime);
                
                setTimeout(() => {
                    // Restore original data
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                    showFeedback(chartId, `⚡ Performance test completed! Rendered 50 items in ${renderTime}ms`, 'success');
                }, 2000);
            }
        };

        window.exploreBreakdowns = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                console.group(`📊 Enterprise Data Explorer - ${chartId}`);
                console.log('Chart Configuration:', chartConfig);
                console.log('Data Structure:');
                
                chartConfig.data.forEach((item, index) => {
                    const total = item.stacks.reduce((sum, s) => sum + s.value, 0);
                    console.log(`  ${index + 1}. ${item.label}: ${total} total`);
                    
                    if (item.breakdown && item.breakdown.length > 0) {
                        console.log(`    📋 Breakdown (${item.breakdown.length} items):`);
                        item.breakdown.forEach((breakdownItem, bIndex) => {
                            const breakdownTotal = breakdownItem.stacks.reduce((sum, s) => sum + s.value, 0);
                            console.log(`      ${bIndex + 1}. ${breakdownItem.label}: ${breakdownTotal}`);
                        });
                    } else {
                        console.log(`    📋 No breakdown data available`);
                    }
                });
                
                console.groupEnd();
                showFeedback(chartId, '📊 Data structure logged to console! Check developer tools', 'info');
            }
        };

        // ========================================
        // 🏢 ENTERPRISE v0.8.6 FUNCTIONS
        // ========================================

        // Enterprise Breakdown Analysis
        window.toggleBreakdownAnalysis = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.enableBreakdown();
                chartConfig.chart.enableBreakdown(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, 
                    `🏢 Breakdown Analysis ${!currentState ? 'ENABLED' : 'DISABLED'} - Click bars to explore hierarchical data`, 
                    'success'
                );
            }
        };

        // Enterprise Performance Test
        window.runEnterprisePerformanceTest = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const startTime = performance.now();
                showFeedback(chartId, '🚀 Running enterprise performance benchmark...', 'info');
                
                // Generate large dataset for performance testing
                const performanceData = [];
                for (let i = 0; i < 50; i++) {
                    performanceData.push({
                        label: `Enterprise Item ${i + 1}`,
                        stacks: [
                            { value: Math.random() * 100000 - 50000, color: '#3498db' }
                        ],
                        breakdown: [
                            { label: `Breakdown A`, stacks: [{ value: Math.random() * 25000, color: '#2ecc71' }] },
                            { label: `Breakdown B`, stacks: [{ value: Math.random() * 25000, color: '#e74c3c' }] }
                        ]
                    });
                }
                
                // Render with performance data
                d3.select(`#${chartId}`).datum(performanceData).call(chartConfig.chart);
                
                const endTime = performance.now();
                const renderTime = Math.round(endTime - startTime);
                
                setTimeout(() => {
                    // Restore original data
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                    showFeedback(chartId, 
                        `⚡ Performance Test Complete: ${renderTime}ms for 50 enterprise items with breakdowns`, 
                        'success'
                    );
                }, 2000);
            }
        };

        // Enterprise Data Breakdown Explorer
        window.exploreBreakdowns = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                let hasBreakdowns = false;
                chartConfig.data.forEach(item => {
                    if (item.breakdown && item.breakdown.length > 0) {
                        hasBreakdowns = true;
                        console.log(`📊 ${item.label} breakdown:`, item.breakdown);
                    }
                });
                
                if (hasBreakdowns) {
                    showFeedback(chartId, 
                        '🔍 Enterprise breakdown data explored - Check console for detailed breakdown information', 
                        'success'
                    );
                } else {
                    showFeedback(chartId, 
                        '📊 No breakdown data available - Enable breakdown analysis to see hierarchical details', 
                        'info'
                    );
                }
            }
        };

        // Visual feedback function
        window.showFeedback = function(chartId, message, type) {
            let feedbackDiv = document.getElementById(`feedback-${chartId}`);
            if (!feedbackDiv) {
                feedbackDiv = document.createElement('div');
                feedbackDiv.id = `feedback-${chartId}`;
                feedbackDiv.style.cssText = 'margin: 10px 0; padding: 8px; border-radius: 4px; font-size: 14px; font-weight: bold;';
                
                // Find the chart container and add feedback after the controls
                const chartContainer = document.querySelector(`#${chartId}`).closest('.chart-container');
                const controls = chartContainer.querySelector('.controls') || chartContainer.querySelector('.export-controls');
                if (controls) {
                    controls.parentNode.insertBefore(feedbackDiv, controls.nextSibling);
                }
            }
            
            // Style based on type
            if (type === 'success') {
                feedbackDiv.style.background = '#27ae60';
                feedbackDiv.style.color = 'white';
            } else if (type === 'error') {
                feedbackDiv.style.background = '#e74c3c';
                feedbackDiv.style.color = 'white';
            } else {
                feedbackDiv.style.background = '#f39c12';
                feedbackDiv.style.color = 'white';
            }
            
            feedbackDiv.textContent = message;
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                feedbackDiv.style.opacity = '0';
                setTimeout(() => {
                    if (feedbackDiv.parentNode) {
                        feedbackDiv.parentNode.removeChild(feedbackDiv);
                    }
                }, 300);
            }, 3000);
        };

        // Utility functions
        function convertToCSV(data) {
            const headers = ['Label', 'Stack_Index', 'Value', 'Color', 'Stack_Label'];
            const rows = [headers.join(',')];
            
            data.forEach(item => {
                item.stacks.forEach((stack, index) => {
                    rows.push([
                        `"${item.label}"`,
                        index,
                        stack.value,
                        `"${stack.color}"`,
                        `"${stack.label}"`
                    ].join(','));
                });
            });
            
            return rows.join('\n');
        }

        function downloadData(data, filename, mimeType) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Enhanced feature control functions
        window.toggleStaggered = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentStagger = chartConfig.chart.staggeredAnimations();
                chartConfig.chart.staggeredAnimations(!currentStagger);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, 
                    `Staggered animations ${!currentStagger ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.clearBrushSelection = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Clear brush selection programmatically
                d3.select(`#${chartId}`).selectAll('.waterfall-brush').call(d3.brush().move, null);
                
                // Hide selection info
                const infoDiv = document.getElementById('selection-info');
                if (infoDiv) infoDiv.style.display = 'none';
                
                showFeedback(chartId, 'Selection cleared', 'success');
            }
        };

        window.changeScaleType = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const scaleTypes = ['auto', 'linear', 'ordinal'];
                const currentIndex = scaleTypes.indexOf(chartConfig.currentScaleType || 'auto');
                const nextIndex = (currentIndex + 1) % scaleTypes.length;
                const newScaleType = scaleTypes[nextIndex];
                
                chartConfig.currentScaleType = newScaleType;
                chartConfig.chart.scaleType(newScaleType);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, `Scale type: ${newScaleType}`, 'success');
            }
        };

        window.updateAdvancedData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Generate new random data with enhanced values
                const newData = chartConfig.data.map((item, i) => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.random() * 100 + 20)),
                        label: `${stack.label.split(':')[0]}: ${Math.round(Math.random() * 100 + 20)}`
                    }))
                }));
                
                chartConfig.data = newData;
                d3.select(`#${chartId}`).datum(newData).call(chartConfig.chart);
                
                showFeedback(chartId, 'Data updated with enhanced animations', 'success');
            }
        };

        // Interactive feature toggle functions
        window.toggleAccessibility = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.enableAccessibility();
                chartConfig.chart.enableAccessibility(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`accessibility-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Accessibility' : 'Enable Accessibility';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #2c3e50, #34495e)';
                }
                
                showFeedback(chartId, 
                    `Accessibility ${!currentState ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.toggleTooltips = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.enableTooltips();
                chartConfig.chart.enableTooltips(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`tooltips-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Tooltips' : 'Enable Tooltips';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)' : 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)';
                }
                
                showFeedback(chartId, 
                    `Tooltips ${!currentState ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.toggleZoom = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.enableZoom();
                chartConfig.chart.enableZoom(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`zoom-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Zoom & Pan' : 'Enable Zoom & Pan';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #e67e22, #f39c12)';
                }
                
                showFeedback(chartId, 
                    `Zoom & Pan ${!currentState ? 'enabled - Use mouse wheel to zoom, drag to pan' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.changeTooltipTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig && chartConfig.chart) {
                // Update tooltip theme configuration
                if (chartConfig.chart.tooltipConfig) {
                    chartConfig.chart.tooltipConfig({ theme: themeName });
                }
                
                // Store the current tooltip theme
                chartConfig.currentTooltipTheme = themeName;
                
                // Re-render chart to apply tooltip theme changes
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, `Tooltip theme changed to: ${themeName}`, 'success');
            }
        };

        // Toggle tooltips on/off
        window.toggleTooltips = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const newState = !chartConfig.tooltipsEnabled;
                chartConfig.tooltipsEnabled = newState;
                
                // Update chart tooltip state and re-render
                if (chartConfig.chart && chartConfig.chart.enableTooltips) {
                    chartConfig.chart.enableTooltips(newState);
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                // Update cursor style
                const svgElement = document.querySelector(`#${chartId}`);
                if (svgElement) {
                    svgElement.style.cursor = newState ? 'pointer' : 'default';
                    if (!newState) {
                        // Remove any existing tooltips
                        d3.selectAll('.mintwaterfall-tooltip').remove();
                    }
                }
                
                // Update button text
                const button = document.getElementById(`tooltips-btn-${chartId}`);
                if (button) {
                    button.textContent = newState ? 'Disable Tooltips' : 'Enable Tooltips';
                    button.style.background = newState ? 
                        'linear-gradient(45deg, #c0392b, #e74c3c)' : 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)';
                }
                
                showFeedback(chartId, `Tooltips ${newState ? 'enabled' : 'disabled'}`, 'success');
            }
        };

        // Change chart theme
        window.changeTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Theme color mappings
                const themes = {
                    default: {
                        colors: ['#3498db', '#e74c3c', '#f39c12', '#27ae60', '#9b59b6', '#e67e22', '#95a5a6'],
                        background: '#ffffff',
                        text: '#2c3e50'
                    },
                    dark: {
                        colors: ['#5dade2', '#ec7063', '#f8c471', '#58d68d', '#bb8fce', '#f0b27a', '#aab7b8'],
                        background: '#2c3e50',
                        text: '#ecf0f1'
                    },
                    corporate: {
                        colors: ['#2874a6', '#a93226', '#b7950b', '#148f77', '#7d3c98', '#d68910', '#5d6d7e'],
                        background: '#f8f9fa',
                        text: '#212529'
                    },
                    accessible: {
                        colors: ['#0073e6', '#d63031', '#fdcb6e', '#00b894', '#6c5ce7', '#fd79a8', '#636e72'],
                        background: '#ffffff',
                        text: '#2d3436'
                    },
                    colorful: {
                        colors: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'],
                        background: '#ffffff',
                        text: '#2f3542'
                    }
                };
                
                const theme = themes[themeName] || themes.default;
                chartConfig.currentTheme = themeName;
                
                // Apply theme colors to data and update chart
                if (chartConfig.chart && chartConfig.data) {
                    // Update data colors based on theme
                    chartConfig.data.forEach((item, index) => {
                        if (item.stacks) {
                            item.stacks.forEach((stack, stackIndex) => {
                                const colorIndex = (index * item.stacks.length + stackIndex) % theme.colors.length;
                                stack.color = theme.colors[colorIndex];
                            });
                        }
                    });
                    
                    // Set theme on chart and re-render with new colors
                    chartConfig.chart.theme(themeName);
                }
                
                // Re-render chart with new theme
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, `Theme changed to: ${themeName}`, 'success');
            }
        };

        // Trend Line Functions
        window.setTrendLine = function(chartId, trendType) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.currentTrendType = trendType;
                
                // Update button states
                ['linear', 'moving-average', 'polynomial', 'none'].forEach(type => {
                    const btnId = type === 'moving-average' ? 'moving-btn' : 
                                  type === 'polynomial' ? 'polynomial-btn' : 
                                  type === 'linear' ? 'linear-btn' : 'none-btn';
                    const btn = document.getElementById(btnId);
                    if (btn) {
                        if (type === trendType) {
                            btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)';
                            btn.style.color = 'white';
                        } else {
                            // Reset to original colors
                            if (type === 'linear') btn.style.background = 'linear-gradient(45deg, #3498db, #2980b9)';
                            else if (type === 'moving-average') btn.style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                            else if (type === 'polynomial') btn.style.background = 'linear-gradient(45deg, #f39c12, #e67e22)';
                            else btn.style.background = 'linear-gradient(45deg, #95a5a6, #7f8c8d)';
                        }
                    }
                });

                // Configure chart
                if (trendType === 'none') {
                    chartConfig.chart.showTrendLine(false);
                } else {
                    chartConfig.chart
                        .showTrendLine(true)
                        .trendLineType(trendType)
                        .trendLineColor(chartConfig.trendSettings.color)
                        .trendLineWidth(chartConfig.trendSettings.width)
                        .trendLineStyle(chartConfig.trendSettings.style);
                }

                // Update chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update info display
                updateTrendInfo(chartId, trendType);
                
                showFeedback(chartId, `Trend line: ${trendType === 'none' ? 'disabled' : trendType}`, 'success');
            }
        };

        window.changeTrendColor = function(chartId, color) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.color = color;
                chartConfig.chart.trendLineColor(color);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line color: ${color}`, 'success');
            }
        };

        window.changeTrendWidth = function(chartId, width) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.width = parseInt(width);
                chartConfig.chart.trendLineWidth(parseInt(width));
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line width: ${width}px`, 'success');
            }
        };

        window.changeTrendStyle = function(chartId, style) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.style = style;
                chartConfig.chart.trendLineStyle(style);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line style: ${style}`, 'success');
            }
        };

        window.changeTrendWindow = function(chartId, window) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.window = parseInt(window);
                
                // Update chart trend line window
                if (chartConfig.chart && chartConfig.chart.trendLineWindow) {
                    chartConfig.chart.trendLineWindow(parseInt(window));
                }
                
                if (chartConfig.currentTrendType === 'moving-average') {
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                document.getElementById('window-value').textContent = window;
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, `Moving average window: ${window}`, 'success');
            }
        };

        window.changeTrendDegree = function(chartId, degree) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.degree = parseInt(degree);
                
                // Update chart trend line degree
                if (chartConfig.chart && chartConfig.chart.trendLineDegree) {
                    chartConfig.chart.trendLineDegree(parseInt(degree));
                }
                
                if (chartConfig.currentTrendType === 'polynomial') {
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                document.getElementById('degree-value').textContent = degree;
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, `Polynomial degree: ${degree}`, 'success');
            }
        };

        window.animateTrendChange = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Create a smooth transition effect
                const svg = d3.select(`#${chartId}`);
                const trendLine = svg.select('.trend-line');
                
                if (!trendLine.empty()) {
                    const totalLength = trendLine.node().getTotalLength();
                    
                    trendLine
                        .attr('stroke-dasharray', totalLength + ' ' + totalLength)
                        .attr('stroke-dashoffset', totalLength)
                        .transition()
                        .duration(2000)
                        .ease(d3.easeElastic)
                        .attr('stroke-dashoffset', 0)
                        .on('end', function() {
                            d3.select(this).attr('stroke-dasharray', 'none');
                        });
                        
                    showFeedback(chartId, 'Trend line animated!', 'success');
                } else {
                    showFeedback(chartId, 'Enable a trend line first to see animation', 'info');
                }
            }
        };

        window.generateTrendData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Generate new trend-oriented data with growth pattern
                const baseValue = 40;
                const growth = 1.15; // 15% growth trend
                const volatility = 0.3; // 30% volatility
                
                const newData = [];
                for (let i = 0; i < 8; i++) {
                    const trend = baseValue * Math.pow(growth, i / 2);
                    const noise = (Math.random() - 0.5) * volatility * trend;
                    const revenue = Math.round(trend + noise);
                    const profit = Math.round(revenue * (0.25 + Math.random() * 0.15));
                    
                    newData.push({
                        label: `Q${(i % 4) + 1} ${2023 + Math.floor(i / 4)}`,
                        stacks: [
                            { value: revenue, color: "#3498db", label: `Revenue: ${revenue}M` },
                            { value: profit, color: "#2ecc71", label: `Profit: ${profit}M` }
                        ]
                    });
                }
                
                chartConfig.data = newData;
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, 'New trend data generated!', 'success');
            }
        };

        function updateTrendInfo(chartId, trendType) {
            const infoDiv = document.getElementById('trend-info');
            if (infoDiv && chartId === 'chartTrend') {
                const chartConfig = charts[chartId];
                let infoText = '';
                
                switch (trendType) {
                    case 'linear':
                        infoText = '<strong>Linear Trend:</strong> Shows a straight-line trend through the data points using least squares regression. Best for identifying consistent growth or decline patterns.';
                        break;
                    case 'moving-average':
                        const window = chartConfig.trendSettings.window;
                        infoText = `<strong>Moving Average (${window}-period):</strong> Smooths out short-term fluctuations to reveal underlying trends. Each point represents the average of ${window} consecutive data points.`;
                        break;
                    case 'polynomial':
                        const degree = chartConfig.trendSettings.degree;
                        infoText = `<strong>Polynomial Trend (degree ${degree}):</strong> Fits a curved line that can capture more complex patterns in the data. Higher degrees can show turning points and cycles.`;
                        break;
                    case 'none':
                    default:
                        infoText = '<strong>Current:</strong> No trend line selected. Choose a trend type above to see overlays on your data.';
                        break;
                }
                
                infoDiv.innerHTML = infoText;
            }
        }

        // Responsive chart functionality - improved for touch devices
        function makeChartsResponsive() {
            // Wait for charts to be fully rendered first
            const checkChartsReady = () => {
                const chartElements = document.querySelectorAll('svg[id^="chart"]');
                let allChartsReady = true;
                
                chartElements.forEach(svg => {
                    // Check if chart has actual content (bars, not just empty SVG)
                    const hasContent = svg.querySelector('.bar-group') || svg.querySelector('rect') || svg.querySelector('g');
                    if (!hasContent) {
                        allChartsReady = false;
                    }
                });
                
                if (!allChartsReady) {
                    // Charts not ready yet, check again in 200ms
                    setTimeout(checkChartsReady, 200);
                    return;
                }
                
                // Charts are ready, apply responsive behavior
                chartElements.forEach(svg => {
                    const chartId = svg.id;
                    const container = svg.parentElement;
                    
                    // Get original dimensions from the rendered chart
                    const bbox = svg.getBBox ? svg.getBBox() : { width: 1100, height: 400 };
                    const originalWidth = parseInt(svg.getAttribute('width')) || bbox.width || 1100;
                    const originalHeight = parseInt(svg.getAttribute('height')) || bbox.height || 400;
                    
                    function resizeChart() {
                        const containerWidth = container.clientWidth;
                        const availableWidth = containerWidth - 40; // 20px padding on each side
                        
                        // For tablets and mobile, ensure chart is visible
                        if (availableWidth < originalWidth && availableWidth > 320) {
                            // Set responsive styles without changing chart dimensions
                            svg.style.width = '100%';
                            svg.style.maxWidth = `${availableWidth}px`;
                            svg.style.height = 'auto';
                            svg.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
                            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                        } else if (availableWidth >= originalWidth) {
                            // Reset to original size for desktop
                            svg.style.width = `${originalWidth}px`;
                            svg.style.maxWidth = '100%';
                            svg.style.height = `${originalHeight}px`;
                            svg.removeAttribute('viewBox');
                            svg.removeAttribute('preserveAspectRatio');
                        }
                    }
                    
                    // Set initial responsive styles
                    svg.style.maxWidth = '100%';
                    svg.style.display = 'block';
                    svg.style.margin = '0 auto';
                    
                    // Initial resize
                    resizeChart();
                    
                    // Add resize listener (debounced)
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(resizeChart, 150);
                    });
                    
                    // Add orientation change listener for mobile devices
                    window.addEventListener('orientationchange', () => {
                        setTimeout(resizeChart, 300); // Delay for orientation change
                    });
                });
            };
            
            // Start checking for charts
            checkChartsReady();
        }
        
        // Initialize responsive charts after a longer delay to ensure full initialization
        setTimeout(makeChartsResponsive, 1000);

        // ========================================
        // 🚀 ADVANCED DATA PROCESSING DEMONSTRATIONS
        // ========================================

        // Sample data for demonstrations
        const advancedSampleData = [
            { region: 'North', product: 'Widget A', channel: 'Direct', revenue: 85000, date: '2024-01-15', actual: 85000, budget: 80000 },
            { region: 'North', product: 'Widget A', channel: 'Partner', revenue: 45000, date: '2024-01-22', actual: 45000, budget: 50000 },
            { region: 'North', product: 'Widget B', channel: 'Direct', revenue: 62000, date: '2024-02-10', actual: 62000, budget: 60000 },
            { region: 'South', product: 'Widget A', channel: 'Direct', revenue: 95000, date: '2024-01-08', actual: 95000, budget: 90000 },
            { region: 'South', product: 'Widget B', channel: 'Partner', revenue: 58000, date: '2024-02-18', actual: 58000, budget: 55000 },
            { region: 'East', product: 'Widget A', channel: 'Online', revenue: 72000, date: '2024-01-25', actual: 72000, budget: 75000 },
            { region: 'West', product: 'Widget B', channel: 'Direct', revenue: 88000, date: '2024-02-05', actual: 88000, budget: 85000 },
            { region: 'East', product: 'Widget B', channel: 'Partner', revenue: 41000, date: '2024-02-15', actual: 41000, budget: 45000 }
        ];

        const expenseTransactionData = [
            { category: 'Marketing', subcategory: 'Digital Ads', amount: -25000, date: '2024-01-10' },
            { category: 'Marketing', subcategory: 'Events', amount: -15000, date: '2024-01-20' },
            { category: 'Operations', subcategory: 'Salaries', amount: -80000, date: '2024-01-31' },
            { category: 'Operations', subcategory: 'Rent', amount: -12000, date: '2024-02-01' },
            { category: 'Technology', subcategory: 'Software', amount: -8000, date: '2024-01-15' },
            { category: 'Technology', subcategory: 'Hardware', amount: -5000, date: '2024-02-10' },
            { category: 'Marketing', subcategory: 'Content', amount: -18000, date: '2024-02-20' },
            { category: 'Operations', subcategory: 'Utilities', amount: -6000, date: '2024-02-05' }
        ];

        // Demo: d3.group() and d3.rollup()
        window.demonstrateGroupRollup = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            // Simulate d3.group() and d3.rollup() functionality
            const grouped = d3.group(advancedSampleData, d => d.region, d => d.product);
            const rollup = d3.rollup(
                advancedSampleData,
                values => ({
                    totalRevenue: d3.sum(values, d => d.revenue),
                    avgRevenue: d3.mean(values, d => d.revenue),
                    count: values.length
                }),
                d => d.region
            );

            // Convert rollup to waterfall format
            const waterfallData = Array.from(rollup.entries()).map(([region, summary]) => ({
                label: region,
                stacks: [{
                    value: Math.round(summary.totalRevenue / 1000),
                    color: ['#3498db', '#e74c3c', '#f39c12', '#27ae60'][Array.from(rollup.keys()).indexOf(region)],
                    label: `$${Math.round(summary.totalRevenue / 1000)}K (${summary.count} items)`
                }]
            }));

            chartConfig.data = waterfallData;
            chartConfig.currentDemo = 'group-rollup';
            d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>d3.group() & d3.rollup():</strong> Grouped ${advancedSampleData.length} records by region, then aggregated revenue.
                <br><strong>Result:</strong> ${waterfallData.length} regional totals showing $${d3.sum(waterfallData, d => d.stacks[0].value)}K total revenue.
                <br><strong>Technique:</strong> Multi-dimensional grouping with custom reducer functions.
            `;

            showFeedback(chartId, 'd3.group() & d3.rollup() demonstration complete', 'success');
        };

        // Demo: d3.flatRollup()
        window.demonstrateFlatRollup = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            // Use d3.flatRollup() to get flattened hierarchical results
            const flatRollup = d3.flatRollup(
                advancedSampleData,
                values => d3.sum(values, d => d.revenue),
                d => d.region,
                d => d.product,
                d => d.channel
            );

            // Convert to waterfall format
            const waterfallData = flatRollup.slice(0, 8).map(([region, product, channel, revenue], index) => ({
                label: `${region}/${product}/${channel}`,
                stacks: [{
                    value: Math.round(revenue / 1000),
                    color: d3.schemeCategory10[index % 10],
                    label: `$${Math.round(revenue / 1000)}K`
                }]
            }));

            chartConfig.data = waterfallData;
            chartConfig.currentDemo = 'flat-rollup';
            d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>d3.flatRollup():</strong> Created flattened 3-dimensional aggregation (Region → Product → Channel).
                <br><strong>Result:</strong> ${flatRollup.length} combinations flattened to array of [key1, key2, key3, value] tuples.
                <br><strong>Showing:</strong> Top ${waterfallData.length} revenue combinations from multi-dimensional breakdown.
            `;

            showFeedback(chartId, 'd3.flatRollup() demonstration complete', 'success');
        };

        // Demo: d3.cross() and d3.index()
        window.demonstrateCrossIndex = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            try {
                // Check if D3.js functions are available
                if (!d3.cross || !d3.index) {
                    throw new Error('d3.cross() or d3.index() not available in this D3.js version');
                }

                // Ensure we have sample data
                if (!advancedSampleData || advancedSampleData.length === 0) {
                    generateAdvancedSampleData(chartId);
                }

                // Create unique lists for cross-tabulation
                const regions = [...new Set(advancedSampleData.map(d => d.region))];
                const products = [...new Set(advancedSampleData.map(d => d.product))];

                console.log('Regions:', regions);
                console.log('Products:', products);
                console.log('Sample data length:', advancedSampleData.length);

                // Use d3.cross() for cartesian product
                const crossTab = d3.cross(regions, products, (region, product) => {
                    const matches = advancedSampleData.filter(d => d.region === region && d.product === product);
                    return {
                        region,
                        product,
                        revenue: d3.sum(matches, d => d.revenue),
                        count: matches.length
                    };
                });

                console.log('Cross tab result:', crossTab);

                // Use d3.index() for fast lookups
                const indexed = d3.index(advancedSampleData, d => d.region, d => d.product);
                console.log('Indexed result:', indexed);

                // Convert cross-tabulation to waterfall
                const waterfallData = crossTab
                    .filter(d => d.revenue > 0)
                    .map((item, index) => ({
                        label: `${item.region} × ${item.product}`,
                        stacks: [{
                            value: Math.round(item.revenue / 1000),
                            color: ['#3498db', '#e74c3c', '#f39c12', '#27ae60', '#9b59b6', '#1abc9c'][index % 6],
                            label: `$${Math.round(item.revenue / 1000)}K (${item.count} records)`
                        }]
                    }));

                if (waterfallData.length === 0) {
                    // Fallback data
                    waterfallData.push(
                        { label: "North × Widget", stacks: [{ value: 120, color: "#3498db", label: "$120K (5 records)" }] },
                        { label: "South × Gadget", stacks: [{ value: 85, color: "#e74c3c", label: "$85K (3 records)" }] },
                        { label: "East × Widget", stacks: [{ value: 95, color: "#f39c12", label: "$95K (4 records)" }] },
                        { label: "West × Gadget", stacks: [{ value: 110, color: "#27ae60", label: "$110K (6 records)" }] }
                    );
                }

                chartConfig.data = waterfallData;
                chartConfig.currentDemo = 'cross-index';
                d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

                document.getElementById('advanced-demo-info').innerHTML = `
                    <strong>d3.cross() & d3.index():</strong> Cross-tabulated ${regions.length} regions × ${products.length} products.
                    <br><strong>Cross Result:</strong> ${crossTab.length} total combinations, ${waterfallData.length} with revenue.
                    <br><strong>Index Result:</strong> Created nested Map for O(1) lookups by region and product.
                    <br><strong>Performance:</strong> Cross-tabulation in O(n×m) time, indexing provides O(1) lookup.
                `;

                showFeedback(chartId, 'd3.cross() & d3.index() demonstration complete', 'success');

            } catch (error) {
                console.error('Cross-index demonstration error:', error);
                showFeedback(chartId, 'Error in d3.cross() & d3.index(): ' + error.message, 'error');
                
                // Fallback demonstration
                const fallbackData = [
                    { label: "Cross: North × Widget", stacks: [{ value: 120, color: "#3498db", label: "$120K cross-tab" }] },
                    { label: "Cross: South × Gadget", stacks: [{ value: 85, color: "#e74c3c", label: "$85K cross-tab" }] },
                    { label: "Cross: East × Tool", stacks: [{ value: 95, color: "#f39c12", label: "$95K cross-tab" }] },
                    { label: "Index: Fast Lookup", stacks: [{ value: 110, color: "#27ae60", label: "$110K indexed" }] }
                ];
                
                chartConfig.data = fallbackData;
                d3.select(`#${chartId}`).datum(fallbackData).call(chartConfig.chart);
                
                document.getElementById('advanced-demo-info').innerHTML = `
                    <strong>d3.cross() & d3.index() (Fallback):</strong> Demonstrating cross-tabulation and indexing concepts.
                    <br><strong>Cross Product:</strong> Region × Product combinations for comprehensive analysis.
                    <br><strong>Indexing:</strong> Fast O(1) lookup performance for large datasets.
                    <br><strong>Status:</strong> Fallback data displayed due to D3.js version compatibility.
                `;
            }
        };

        // Demo: Temporal Aggregation
        window.demonstrateTemporalAgg = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            // Aggregate by month using D3.js time intervals
            const monthlyAgg = d3.rollup(
                advancedSampleData,
                values => ({
                    totalRevenue: d3.sum(values, d => d.revenue),
                    avgRevenue: d3.mean(values, d => d.revenue),
                    count: values.length
                }),
                d => d3.timeMonth(new Date(d.date))
            );

            // Convert to waterfall format
            const waterfallData = Array.from(monthlyAgg.entries()).map(([month, summary]) => ({
                label: d3.timeFormat("%b %Y")(month),
                stacks: [{
                    value: Math.round(summary.totalRevenue / 1000),
                    color: month.getMonth() === 0 ? '#3498db' : '#27ae60',
                    label: `$${Math.round(summary.totalRevenue / 1000)}K (${summary.count} records)`
                }]
            }));

            chartConfig.data = waterfallData;
            chartConfig.currentDemo = 'temporal';
            d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>Temporal Aggregation:</strong> Used d3.timeMonth() to group by month, then aggregated revenue.
                <br><strong>Result:</strong> ${waterfallData.length} monthly periods with total revenue of $${d3.sum(waterfallData, d => d.stacks[0].value)}K.
                <br><strong>D3.js Time:</strong> Leveraged D3's time interval system for precise temporal grouping.
            `;

            showFeedback(chartId, 'Temporal aggregation demonstration complete', 'success');
        };

        // Demo: Revenue Waterfall Helper
        window.demonstrateRevenueWaterfall = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            // Simulate the createRevenueWaterfall helper
            const revenueWaterfall = d3.flatRollup(
                advancedSampleData,
                values => d3.sum(values, d => d.revenue),
                d => d.region,
                d => d.product
            ).map(([region, product, revenue]) => ({
                label: `${region} → ${product}`,
                stacks: [{
                    value: Math.round(revenue / 1000),
                    color: region === 'North' ? '#3498db' : region === 'South' ? '#e74c3c' : 
                           region === 'East' ? '#f39c12' : '#27ae60',
                    label: `$${Math.round(revenue / 1000)}K`
                }]
            }));

            chartConfig.data = revenueWaterfall;
            chartConfig.currentDemo = 'revenue-waterfall';
            d3.select(`#${chartId}`).datum(revenueWaterfall).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>Revenue Waterfall Helper:</strong> Multi-dimensional revenue analysis by Region → Product.
                <br><strong>Result:</strong> ${revenueWaterfall.length} revenue streams totaling $${d3.sum(revenueWaterfall, d => d.stacks[0].value)}K.
                <br><strong>Feature:</strong> Automated hierarchical breakdown with intelligent color coding.
            `;

            showFeedback(chartId, 'Revenue waterfall demonstration complete', 'success');
        };

        // Demo: Variance Analysis
        window.demonstrateVarianceWaterfall = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            // Create variance analysis: actual vs budget
            const varianceData = d3.rollup(
                advancedSampleData,
                values => ({
                    actual: d3.sum(values, d => d.actual),
                    budget: d3.sum(values, d => d.budget)
                }),
                d => d.region
            );

            const waterfallData = Array.from(varianceData.entries()).map(([region, data]) => {
                const variance = data.actual - data.budget;
                return {
                    label: `${region} Variance`,
                    stacks: [{
                        value: Math.round(variance / 1000),
                        color: variance >= 0 ? '#27ae60' : '#e74c3c',
                        label: `${variance >= 0 ? '+' : ''}$${Math.round(variance / 1000)}K variance`
                    }]
                };
            });

            chartConfig.data = waterfallData;
            chartConfig.currentDemo = 'variance';
            d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>Variance Analysis:</strong> Actual vs Budget comparison by region.
                <br><strong>Result:</strong> ${waterfallData.length} regional variances, total variance: $${d3.sum(waterfallData, d => d.stacks[0].value)}K.
                <br><strong>Colors:</strong> Green = over budget, Red = under budget performance.
            `;

            showFeedback(chartId, 'Variance analysis demonstration complete', 'success');
        };

        // Demo: Period Comparison
        window.demonstrateComparisonWaterfall = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            try {
                // Simulate two periods of data
                const currentPeriod = advancedSampleData;
                const previousPeriod = advancedSampleData.map(d => ({
                    ...d,
                    revenue: d.revenue * (0.8 + Math.random() * 0.4) // Simulate different previous values
                }));

                // First, rollup both periods by region
                const currentRollup = d3.rollup(
                    currentPeriod,
                    values => d3.sum(values, d => d.revenue),
                    d => d.region
                );

                const prevRollup = d3.rollup(
                    previousPeriod,
                    values => d3.sum(values, d => d.revenue),
                    d => d.region
                );

                // Create comparison data
                const waterfallData = [];
                for (const [region, currentTotal] of currentRollup) {
                    const prevTotal = prevRollup.get(region) || 0;
                    const change = currentTotal - prevTotal;
                    
                    waterfallData.push({
                        label: `${region} Change`,
                        stacks: [{
                            value: Math.round(change / 1000),
                            color: change >= 0 ? '#27ae60' : '#e74c3c',
                            label: `${change >= 0 ? '+' : ''}$${Math.round(change / 1000)}K change`
                        }]
                    });
                }

                chartConfig.data = waterfallData;
                chartConfig.currentDemo = 'comparison';
                d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

                document.getElementById('advanced-demo-info').innerHTML = `
                    <strong>Period Comparison:</strong> Current vs Previous period analysis using d3.rollup() for aggregation.
                    <br><strong>Result:</strong> ${waterfallData.length} regional changes, net change: $${d3.sum(waterfallData, d => d.stacks[0].value)}K.
                    <br><strong>Method:</strong> Efficient period-over-period comparison with Map-based lookups.
                `;

                showFeedback(chartId, 'Period comparison demonstration complete', 'success');
            } catch (error) {
                console.error('Period comparison error:', error);
                showFeedback(chartId, 'Error in period comparison: ' + error.message, 'error');
                
                // Fallback simple data
                const fallbackData = [
                    { label: "North Change", stacks: [{ value: 15, color: "#27ae60", label: "+$15K change" }] },
                    { label: "South Change", stacks: [{ value: -8, color: "#e74c3c", label: "-$8K change" }] },
                    { label: "East Change", stacks: [{ value: 12, color: "#27ae60", label: "+$12K change" }] },
                    { label: "West Change", stacks: [{ value: 5, color: "#27ae60", label: "+$5K change" }] }
                ];
                
                chartConfig.data = fallbackData;
                d3.select(`#${chartId}`).datum(fallbackData).call(chartConfig.chart);
                
                document.getElementById('advanced-demo-info').innerHTML = `
                    <strong>Period Comparison (Fallback):</strong> Showing sample period-over-period changes.
                    <br><strong>Result:</strong> 4 regional changes demonstrated with simplified data.
                    <br><strong>Status:</strong> Fallback data displayed due to processing error.
                `;
            }
        };

        // Demo: Breakdown Analysis
        window.demonstrateBreakdownWaterfall = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            // Create breakdown waterfall using nested rollup
            const breakdown = d3.rollup(
                expenseTransactionData,
                values => d3.sum(values, d => d.amount),
                d => d.category,
                d => d.subcategory
            );

            const waterfallData = [];
            for (const [category, subcategories] of breakdown) {
                const stacks = Array.from(subcategories.entries()).map(([subcategory, amount], index) => ({
                    value: Math.round(Math.abs(amount) / 1000),
                    color: ['#e74c3c', '#c0392b', '#a93226'][index % 3],
                    label: `${subcategory}: $${Math.round(Math.abs(amount) / 1000)}K`
                }));

                waterfallData.push({
                    label: category,
                    stacks: stacks
                });
            }

            chartConfig.data = waterfallData;
            chartConfig.currentDemo = 'breakdown';
            d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>Breakdown Analysis:</strong> Hierarchical expense breakdown by Category → Subcategory.
                <br><strong>Result:</strong> ${waterfallData.length} categories with ${d3.sum(waterfallData, d => d.stacks.length)} subcategory breakdowns.
                <br><strong>Total Expenses:</strong> $${d3.sum(waterfallData, d => d3.sum(d.stacks, s => s.value))}K across all categories.
            `;

            showFeedback(chartId, 'Breakdown analysis demonstration complete', 'success');
        };

        // Demo: Financial Reducers
        window.demonstrateFinancialReducers = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            try {
                // Ensure we have sample data
                if (!advancedSampleData || advancedSampleData.length === 0) {
                    generateAdvancedSampleData(chartId);
                }

                // Simulate financial reducer functions
                const financialMetrics = d3.rollup(
                    advancedSampleData,
                    values => {
                        const revenues = values.map(d => d.revenue).filter(r => r != null && !isNaN(r));
                        
                        // Calculate metrics with proper null handling
                        const sum = d3.sum(revenues);
                        const mean = d3.mean(revenues);
                        const median = d3.median(revenues);
                        const variance = d3.variance(revenues);
                        const sortedRevenues = revenues.slice().sort(d3.ascending);
                        const q75 = d3.quantile(sortedRevenues, 0.75);
                        
                        console.log(`${values[0]?.region} metrics:`, { 
                            count: revenues.length, 
                            sum, mean, median, variance, q75 
                        });
                        
                        return {
                            sum: sum || 0,
                            mean: mean || 0,
                            median: median || 0,
                            variance: variance,
                            q75: q75 || 0,
                            count: revenues.length
                        };
                    },
                    d => d.region
                );

                const waterfallData = Array.from(financialMetrics.entries()).map(([region, metrics]) => {
                    // Safe variance formatting
                    const varianceText = (metrics.variance != null && !isNaN(metrics.variance)) 
                        ? `σ²: $${Math.round(metrics.variance / 1000000)}M`
                        : `σ²: N/A (n=${metrics.count})`;
                    
                    return {
                        label: `${region} Analysis`,
                        stacks: [{
                            value: Math.round((metrics.mean || 0) / 1000),
                            color: '#9b59b6',
                            label: `Avg: $${Math.round((metrics.mean || 0) / 1000)}K (${varianceText})`
                        }]
                    };
                });

                chartConfig.data = waterfallData;
                chartConfig.currentDemo = 'financial';
                d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

                // Calculate summary statistics
                const totalRegions = waterfallData.length;
                const validVariances = Array.from(financialMetrics.values()).filter(m => m.variance != null && !isNaN(m.variance)).length;

                document.getElementById('advanced-demo-info').innerHTML = `
                    <strong>Financial Reducers:</strong> Advanced statistical analysis using d3.mean(), d3.median(), d3.variance(), d3.quantile().
                    <br><strong>Metrics:</strong> Analyzed ${totalRegions} regions, ${validVariances} with valid variance calculations.
                    <br><strong>Functions:</strong> Sum, mean, median, variance, and 75th percentile calculations with null-safe handling.
                `;

                showFeedback(chartId, 'Financial reducers demonstration complete', 'success');

            } catch (error) {
                console.error('Financial reducers error:', error);
                showFeedback(chartId, 'Error in financial reducers: ' + error.message, 'error');
                
                // Fallback data
                const fallbackData = [
                    { label: "North Analysis", stacks: [{ value: 95, color: "#9b59b6", label: "Avg: $95K (σ²: $15M)" }] },
                    { label: "South Analysis", stacks: [{ value: 88, color: "#9b59b6", label: "Avg: $88K (σ²: $12M)" }] },
                    { label: "East Analysis", stacks: [{ value: 102, color: "#9b59b6", label: "Avg: $102K (σ²: $18M)" }] },
                    { label: "West Analysis", stacks: [{ value: 78, color: "#9b59b6", label: "Avg: $78K (σ²: $9M)" }] }
                ];
                
                chartConfig.data = fallbackData;
                d3.select(`#${chartId}`).datum(fallbackData).call(chartConfig.chart);
                
                document.getElementById('advanced-demo-info').innerHTML = `
                    <strong>Financial Reducers (Fallback):</strong> Sample statistical analysis demonstration.
                    <br><strong>Metrics:</strong> Average revenue with variance calculations per region.
                    <br><strong>Status:</strong> Fallback data due to processing error.
                `;
            }
        };

        // Demo: Transaction Transform
        window.demonstrateTransformData = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            // Transform transaction data to waterfall format
            const transformed = d3.rollup(
                expenseTransactionData,
                values => d3.sum(values, d => Math.abs(d.amount)),
                d => d.category
            );

            const waterfallData = Array.from(transformed.entries()).map(([category, total]) => ({
                label: category,
                stacks: [{
                    value: Math.round(total / 1000),
                    color: category === 'Marketing' ? '#e74c3c' : 
                           category === 'Operations' ? '#f39c12' : '#9b59b6',
                    label: `$${Math.round(total / 1000)}K expenses`
                }]
            }));

            chartConfig.data = waterfallData;
            chartConfig.currentDemo = 'transform';
            d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>Transaction Transform:</strong> Converted ${expenseTransactionData.length} raw transactions to ${waterfallData.length} category summaries.
                <br><strong>Total Processed:</strong> $${d3.sum(waterfallData, d => d.stacks[0].value)}K in expenses across all categories.
                <br><strong>Method:</strong> Automated transformation from flat transaction data to hierarchical waterfall format.
            `;

            showFeedback(chartId, 'Transaction transform demonstration complete', 'success');
        };

        // Reset demo
        window.resetAdvancedDemo = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            chartConfig.data = [
                { label: "Advanced D3.js", stacks: [{ value: 100, color: "#3498db", label: "100%" }] },
                { label: "Data Processing", stacks: [{ value: 85, color: "#27ae60", label: "85%" }] },
                { label: "Implementation", stacks: [{ value: 95, color: "#f39c12", label: "95%" }] },
                { label: "Complete!", stacks: [{ value: 120, color: "#e74c3c", label: "120%" }] }
            ];
            chartConfig.currentDemo = 'reset';
            d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>Reset:</strong> Ready for new demonstrations! Click any button above to see advanced D3.js data processing.
                <br><strong>Available:</strong> d3.group(), d3.rollup(), d3.flatRollup(), d3.cross(), d3.index(), temporal aggregation, and waterfall helpers.
                <br><strong>Status:</strong> All Phase 1 advanced data processing features implemented and ready to demonstrate.
            `;

            showFeedback(chartId, 'Demo reset - ready for new demonstrations', 'success');
        };

        // Generate sample data for advanced demos
        window.generateAdvancedSampleData = function(chartId) {
            const chartConfig = charts[chartId];
            if (!chartConfig) return;

            // Generate realistic sample data
            const regions = ['North', 'South', 'East', 'West', 'Central'];
            const products = ['Widget A', 'Widget B', 'Widget C'];
            const channels = ['Direct', 'Partner', 'Online'];
            
            const newData = [];
            for (let i = 0; i < 12; i++) {
                const region = regions[Math.floor(Math.random() * regions.length)];
                const product = products[Math.floor(Math.random() * products.length)];
                const channel = channels[Math.floor(Math.random() * channels.length)];
                const revenue = Math.floor(Math.random() * 80000) + 20000;
                
                newData.push({
                    region,
                    product,
                    channel,
                    revenue,
                    date: `2024-${String(Math.floor(Math.random() * 12) + 1).padStart(2, '0')}-${String(Math.floor(Math.random() * 28) + 1).padStart(2, '0')}`,
                    actual: revenue,
                    budget: revenue * (0.9 + Math.random() * 0.2)
                });
            }

            // Convert to simple waterfall format for display
            const waterfallData = newData.slice(0, 8).map((item, index) => ({
                label: `${item.region}-${item.product}`,
                stacks: [{
                    value: Math.round(item.revenue / 1000),
                    color: d3.schemeCategory10[index % 10],
                    label: `$${Math.round(item.revenue / 1000)}K`
                }]
            }));

            chartConfig.data = waterfallData;
            d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);

            document.getElementById('advanced-demo-info').innerHTML = `
                <strong>Sample Data Generated:</strong> Created ${newData.length} records with regions, products, channels, and revenue.
                <br><strong>Showing:</strong> ${waterfallData.length} items (sample of generated data).
                <br><strong>Ready:</strong> Use buttons above to process this data with advanced D3.js functions.
            `;

            showFeedback(chartId, `Generated ${newData.length} sample records`, 'success');
        };
        
        // Fallback: Ensure charts are visible even if responsive JS fails
        setTimeout(() => {
            const chartElements = document.querySelectorAll('svg[id^="chart"]');
            chartElements.forEach(svg => {
                if (!svg.style.maxWidth) {
                    svg.style.maxWidth = '100%';
                    svg.style.height = 'auto';
                    svg.style.display = 'block';
                    svg.style.margin = '0 auto';
                }
                
                // Force visibility for touch devices
                if ('ontouchstart' in window) {
                    svg.style.visibility = 'visible';
                    svg.style.opacity = '1';
                    svg.setAttribute('viewBox', `0 0 ${svg.getAttribute('width') || 1100} ${svg.getAttribute('height') || 400}`);
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                }
            });
        }, 2000);
        
        
        // Advanced data processing functions
        window.demonstrateGrouping = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && advancedDataProcessor) {
                try {
                    // Group by region and category
                    const grouped = advancedDataProcessor.groupData([], 
                        d => d.region, 
                        d => d.category
                    );
                    
                    // Convert grouped data to waterfall format
                    const waterfallData = [];
                    for (const [region, categories] of grouped) {
                        for (const [category, items] of categories) {
                            const totalSales = d3.sum(items, d => d.sales);
                            waterfallData.push({
                                label: `${region} - ${category}`,
                                stacks: [{ value: totalSales / 1000, color: d3.schemeCategory10[waterfallData.length % 10], label: `${totalSales / 1000}K` }]
                            });
                        }
                    }
                    
                    chartConfig.data = waterfallData;
                    chartConfig.currentOperation = 'grouping';
                    d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);
                    
                    document.getElementById('processing-results').innerHTML = `
                        <strong>d3.group() Results:</strong><br>
                        Grouped sample records by region and category.<br>
                        Created ${waterfallData.length} grouped categories.<br>
                        <em>Data structure: Map(region → Map(category → Array(records)))</em>
                    `;
                    
                    showFeedback(chartId, 'd3.group() demonstration complete', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error in grouping: ' + error.message, 'error');
                }
            }
        };
        
        window.demonstrateRollup = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && advancedDataProcessor) {
                try {
                    // Rollup by region with sum of sales
                    const rolled = advancedDataProcessor.rollupData([],
                        values => ({
                            totalSales: d3.sum(values, d => d.sales),
                            totalProfit: d3.sum(values, d => d.profit),
                            avgSales: d3.mean(values, d => d.sales)
                        }),
                        d => d.region
                    );
                    
                    // Convert to waterfall format
                    const waterfallData = [];
                    for (const [region, summary] of rolled) {
                        waterfallData.push({
                            label: region,
                            stacks: [
                                { value: summary.totalSales / 1000, color: '#3498db', label: `Sales: ${(summary.totalSales / 1000).toFixed(1)}K` },
                                { value: summary.totalProfit / 1000, color: '#2ecc71', label: `Profit: ${(summary.totalProfit / 1000).toFixed(1)}K` }
                            ]
                        });
                    }
                    
                    chartConfig.data = waterfallData;
                    chartConfig.currentOperation = 'rollup';
                    d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);
                    
                    document.getElementById('processing-results').innerHTML = `
                        <strong>d3.rollup() Results:</strong><br>
                        Aggregated sample records by region.<br>
                        Calculated totals and averages for ${waterfallData.length} regions.<br>
                        <em>Data structure: Map(region → {totalSales, totalProfit, avgSales})</em>
                    `;
                    
                    showFeedback(chartId, 'd3.rollup() demonstration complete', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error in rollup: ' + error.message, 'error');
                }
            }
        };
        
        window.demonstrateCrossTab = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && advancedDataProcessor) {
                try {
                    // Create cross-tabulation
                    const crosstab = advancedDataProcessor.crossTabulate([], 'region', 'category', 'sales');
                    
                    // Convert to waterfall format
                    const waterfallData = [];
                    Object.keys(crosstab).forEach(region => {
                        Object.keys(crosstab[region]).forEach(category => {
                            waterfallData.push({
                                label: `${region}/${category}`,
                                stacks: [{ value: crosstab[region][category] / 1000, color: d3.schemeCategory10[waterfallData.length % 10], label: `${(crosstab[region][category] / 1000).toFixed(1)}K` }]
                            });
                        });
                    });
                    
                    chartConfig.data = waterfallData;
                    chartConfig.currentOperation = 'crosstab';
                    d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);
                    
                    document.getElementById('processing-results').innerHTML = `
                        <strong>Cross-tabulation Results:</strong><br>
                        Created pivot table with regions vs categories.<br>
                        Generated ${waterfallData.length} cross-tabulated values.<br>
                        <em>Data structure: Object(region → Object(category → aggregatedValue))</em>
                    `;
                    
                    showFeedback(chartId, 'Cross-tabulation demonstration complete', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error in cross-tabulation: ' + error.message, 'error');
                }
            }
        };
        
        window.demonstrateTimeSeries = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && advancedDataProcessor) {
                try {
                    // Aggregate by quarter
                    const timeSeries = advancedDataProcessor.timeSeriesAggregate([], 'quarter', 'sales');
                    
                    // Convert to waterfall format
                    const waterfallData = Object.keys(timeSeries).map(quarter => ({
                        label: quarter,
                        stacks: [{ value: timeSeries[quarter] / 1000, color: '#9b59b6', label: `${(timeSeries[quarter] / 1000).toFixed(1)}K` }]
                    }));
                    
                    chartConfig.data = waterfallData;
                    chartConfig.currentOperation = 'timeseries';
                    d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);
                    
                    document.getElementById('processing-results').innerHTML = `
                        <strong>Time Series Aggregation Results:</strong><br>
                        Aggregated sales data by quarter.<br>
                        Created ${waterfallData.length} time periods.<br>
                        <em>Data structure: Object(timeKey → aggregatedValue)</em>
                    `;
                    
                    showFeedback(chartId, 'Time series demonstration complete', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error in time series: ' + error.message, 'error');
                }
            }
        };
        
        // Performance optimization functions
        window.generateLargeDataset = function(chartId, size) {
            const chartConfig = charts[chartId];
            if (chartConfig && largeDatasetUtils) {
                try {
                    const startTime = performance.now();
                    
                    // Generate large dataset
                    const largeData = largeDatasetUtils.generateSampleData(size);
                    
                    // Convert to waterfall format (sample first 50 items for visualization)
                    const sampleSize = Math.min(50, size);
                    const waterfallData = largeData.slice(0, sampleSize).map((item, i) => ({
                        label: `Item ${i + 1}`,
                        stacks: [{ value: item.value, color: d3.schemeCategory10[i % 10], label: `${item.value}` }]
                    }));
                    
                    const generateTime = performance.now() - startTime;
                    
                    chartConfig.data = waterfallData;
                    d3.select(`#${chartId}`).datum(waterfallData).call(chartConfig.chart);
                    
                    const renderTime = performance.now() - startTime;
                    
                    document.getElementById('metrics-display').innerHTML = `
                        <strong>Dataset Generated:</strong> ${size.toLocaleString()} items<br>
                        <strong>Generation Time:</strong> ${generateTime.toFixed(2)}ms<br>
                        <strong>Render Time:</strong> ${renderTime.toFixed(2)}ms<br>
                        <strong>Displayed:</strong> ${sampleSize} items (sampled for visualization)<br>
                        <strong>Performance:</strong> ${(size / renderTime * 1000).toFixed(0)} items/second
                    `;
                    
                    showFeedback(chartId, `Generated ${size.toLocaleString()} items in ${renderTime.toFixed(2)}ms`, 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error generating dataset: ' + error.message, 'error');
                }
            }
        };
        
        window.togglePerformanceOptimization = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.performanceOptimizationEnabled = !chartConfig.performanceOptimizationEnabled;
                showFeedback(chartId, `Performance optimization ${chartConfig.performanceOptimizationEnabled ? 'enabled' : 'disabled'}`, 'success');
            }
        };
        
        window.showPerformanceMetrics = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && performanceManager) {
                try {
                    const metrics = performanceManager.getMetrics();
                    
                    document.getElementById('metrics-display').innerHTML = `
                        <strong>Current Performance Metrics:</strong><br>
                        <strong>Render Time:</strong> ${metrics.renderTime}ms<br>
                        <strong>Data Processing Time:</strong> ${metrics.dataProcessingTime}ms<br>
                        <strong>Memory Usage:</strong> ${(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB<br>
                        <strong>FPS:</strong> ${metrics.fps}<br>
                        <strong>Visible Elements:</strong> ${metrics.visibleElements}<br>
                        <strong>Total Elements:</strong> ${metrics.totalElements}
                    `;
                    
                    showFeedback(chartId, 'Performance metrics updated', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error getting metrics: ' + error.message, 'error');
                }
            }
        };
        
        window.benchmarkPerformance = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && largeDatasetUtils) {
                try {
                    showFeedback(chartId, 'Running performance benchmark...', 'info');
                    
                    const results = largeDatasetUtils.benchmark([1000, 5000, 10000], (size) => {
                        const data = largeDatasetUtils.generateSampleData(size);
                        return data.length;
                    });
                    
                    document.getElementById('metrics-display').innerHTML = `
                        <strong>Benchmark Results:</strong><br>
                        ${results.map(r => `<strong>${r.size} items:</strong> ${r.time.toFixed(2)}ms (${(r.size / r.time * 1000).toFixed(0)} items/sec)`).join('<br>')}
                    `;
                    
                    showFeedback(chartId, 'Benchmark complete', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Benchmark error: ' + error.message, 'error');
                }
            }
        };


        // Log successful initialization - PURE WATERFALL FOCUS WITH TYPESCRIPT
        console.log('🌊 MintWaterfall v0.8.6 - TYPESCRIPT WATERFALL CHART SHOWCASE!');
        console.log('⚡ TYPESCRIPT MIGRATION: Full type safety, enhanced development experience');
        console.log('💧 CORE WATERFALL FEATURES: Stacked/Waterfall modes, Breakdown analysis, Conditional formatting');
        console.log('🎨 WATERFALL STYLING: Themes, animations, responsive design, accessibility');
        console.log('🔧 WATERFALL INTERACTIONS: Brush selection, zoom, tooltips, export capabilities');
        console.log('📊 WATERFALL DATA: Revenue analysis, cost breakdowns, project timelines, performance metrics');
        console.log('Charts:', Object.keys(charts));
        console.log('Available themes:', Object.keys(themes));
        console.log('Data processor loaded with', Object.keys(dataProcessor).length, 'methods');
        console.log('Animation system loaded with', Object.keys(animationSystem).length, 'features');
        console.log('🏢 Enterprise Features: Advanced breakdown analysis, hierarchical data support, conditional formatting');
        console.log('🎯 Interactive Features: Accessibility (WCAG 2.1 AA), Professional Tooltips, Export System, Zoom & Pan, Responsive Design');
        console.log('♿ Accessibility: Tab navigation, Arrow keys, Screen reader support, Focus management');
        console.log('💡 Tooltips: Smart positioning, Multiple themes, Rich content, Performance optimized');
        console.log('📤 Export: SVG, PNG, JSON, CSV formats available with enterprise data');
        console.log('🔍 Zoom & Pan: Mouse wheel zoom, drag to pan, zoom controls, touch support');
        console.log('📱 Responsive: Mobile-first design, Adaptive charts, Flexible layouts, Enterprise ready');
        console.log('🔥 TypeScript Benefits: Type safety, IntelliSense, Better debugging, Enterprise development');
        
        } // End of initializeCharts()
        
        function initializeBasicCharts() {
            console.log('🔄 Basic fallback initialization...');
            
            // Test D3 first
            if (typeof d3 === 'undefined') {
                console.error('❌ D3 not available!');
                return;
            }
            
            console.log('✅ D3 available:', d3.version);
            
            // Create simple test charts for chart1 and chart2
            ['chart1', 'chart2'].forEach(chartId => {
                const element = document.getElementById(chartId);
                if (!element) {
                    console.error(`❌ Element ${chartId} not found`);
                    return;
                }
                
                console.log(`🔧 Creating basic chart for ${chartId}`);
                
                // Clear any existing content
                d3.select(`#${chartId}`).selectAll("*").remove();
                
                // Create a simple SVG with test bars
                const svg = d3.select(`#${chartId}`)
                    .append("svg")
                    .attr("width", 1100)
                    .attr("height", 400)
                    .style("background", "#f8f9fa");
                
                // Add test data bars
                const testData = [
                    { label: "Q1", value: 70 },
                    { label: "Q2", value: 30 },
                    { label: "Q3", value: 35 },
                    { label: "Q4", value: 40 }
                ];
                
                const xScale = d3.scaleBand()
                    .domain(testData.map(d => d.label))
                    .range([80, 1020])
                    .padding(0.1);
                
                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(testData, d => d.value)])
                    .range([320, 60]);
                
                svg.selectAll("rect")
                    .data(testData)
                    .enter()
                    .append("rect")
                    .attr("x", d => xScale(d.label))
                    .attr("y", d => yScale(d.value))
                    .attr("width", xScale.bandwidth())
                    .attr("height", d => 320 - yScale(d.value))
                    .attr("fill", "#3498db");
                
                svg.selectAll("text")
                    .data(testData)
                    .enter()
                    .append("text")
                    .attr("x", d => xScale(d.label) + xScale.bandwidth() / 2)
                    .attr("y", 350)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#2c3e50")
                    .text(d => d.label);
                
                console.log(`✅ Basic chart created for ${chartId}`);
            });
        }

    </script>
</body>
</html>
