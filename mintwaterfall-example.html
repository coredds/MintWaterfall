<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MintWaterfall v0.8.0 Showcase</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 10px;
            background: #147B58;
            color: white;
            min-height: 100vh;
            line-height: 1.6;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin: 10px auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
            max-width: 1200px;
            text-align: center;
            width: 100%;
        }

        /* Responsive container for charts */
        .chart-wrapper {
            width: 100%;
            overflow-x: auto;
            margin: 15px 0;
            /* Remove fixed min-height to prevent empty space */
        }

        /* Ensure SVG charts are visible and responsive */
        svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            /* Prevent iOS Safari from hiding SVG content */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        .waterfall-container {
            background: white;
        }

        /* Grid styling */
        .grid-line {
            stroke: rgba(224, 224, 224, 0.5); /* 50% transparency */
            stroke-width: 1;
        }

        /* Axis styling */
        .x-axis, .y-axis {
            font-size: 12px;
        }

        .x-axis text, .y-axis text {
            fill: #333;
        }

        .x-axis path, .y-axis path,
        .x-axis line, .y-axis line {
            stroke: #666;
            stroke-width: 1;
        }

        /* Bar styling */
        .bar-group rect {
            stroke: none;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .bar-group rect:hover {
            opacity: 0.8;
        }

        /* Label styling */
        .total-label {
            font-size: 12px;
            font-weight: bold;
            fill: #333;
        }

        .stack-label {
            font-size: 10px;
            fill: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }

        /* Connector styling */
        .connector {
            stroke: #666;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }

        /* Tooltip styling */
        .mintwaterfall-tooltip {
            position: absolute;
            visibility: hidden;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 250px;
            line-height: 1.4;
        }

        .mintwaterfall-tooltip .tooltip-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 6px;
            color: #4CAF50;
        }

        .mintwaterfall-tooltip .tooltip-value {
            font-size: 16px;
            font-weight: bold;
            margin: 4px 0;
        }

        .mintwaterfall-tooltip .tooltip-detail {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 4px;
        }

        /* Controls - Responsive */
        .controls {
            margin: 20px 0;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        button {
            background: linear-gradient(45deg, #147B58, #1a9d6b);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(20, 123, 88, 0.3);
            min-width: 120px;
            white-space: nowrap;
        }

        button:hover {
            background: linear-gradient(45deg, #1a9d6b, #20b377);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(20, 123, 88, 0.4);
        }

        /* Feature controls - override inline styles */
        .feature-controls {
            margin: 15px 0 !important;
            padding: 15px !important;
            background: #f8f9fa !important;
            border-radius: 8px !important;
            border-left: 4px solid #147B58 !important;
            text-align: center;
        }

        .feature-controls h4 {
            margin: 0 0 10px 0 !important;
            color: #147B58 !important;
            font-size: 16px;
        }

        .feature-controls > div {
            display: flex !important;
            flex-wrap: wrap !important;
            gap: 10px !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .control-group {
            background: rgba(20, 123, 88, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(20, 123, 88, 0.2);
            text-align: center;
        }

        .control-group h4 {
            margin: 0 0 10px 0;
            color: #147B58;
            font-size: 16px;
        }

        .feature-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        button:active {
            transform: translateY(0px);
        }

        .theme-selector {
            margin: 10px 0;
        }

        .theme-selector select {
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: white;
            color: #333;
            font-family: 'Roboto', sans-serif;
        }

        .export-controls {
            margin: 15px 0;
            text-align: center;
        }

        .export-btn {
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
            margin: 3px;
            padding: 8px 16px;
            font-size: 12px;
        }

        .export-btn:hover {
            background: linear-gradient(45deg, #9b59b6, #a569bd);
        }

        .animation-btn {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
        }

        .animation-btn:hover {
            background: linear-gradient(45deg, #f39c12, #f1c40f);
        }

        /* Responsive Typography */
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            line-height: 1.2;
        }

        h2 {
            color: #333;
            border-bottom: 3px solid #147B58;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: clamp(1.4rem, 3vw, 1.8rem);
            line-height: 1.3;
        }

        h3 {
            color: #147B58;
            margin: 20px 0 15px 0;
            font-weight: 500;
            font-size: clamp(1.2rem, 2.5vw, 1.4rem);
            line-height: 1.4;
        }

        p {
            font-size: clamp(0.9rem, 2vw, 1rem);
            line-height: 1.6;
            margin: 10px 0;
        }

        /* Responsive Breakpoints */
        /* iPad and tablet styles */
        @media (max-width: 1024px) and (min-width: 769px) {
            .chart-container {
                padding: 20px;
                margin: 15px auto;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                /* Remove min-height for tablets */
            }
            
            svg {
                width: 100% !important;
                max-width: 900px !important;
                height: auto !important;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .chart-container {
                padding: 15px;
                margin: 5px auto;
                border-radius: 10px;
            }
            
            .controls {
                gap: 8px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 13px;
                min-width: 100px;
            }
            
            .feature-controls {
                margin: 10px 0 !important;
                padding: 10px !important;
            }
            
            .control-group {
                padding: 12px;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                /* Remove min-height for mobile */
            }
        }

        @media (max-width: 480px) {
            .chart-container {
                padding: 10px;
                border-radius: 8px;
            }
            
            button {
                padding: 6px 12px;
                font-size: 12px;
                min-width: 80px;
            }
            
            .control-group {
                padding: 10px;
            }
            
            .control-group h4 {
                font-size: 14px;
            }
            
            .feature-controls {
                margin: 5px 0 !important;
                padding: 8px !important;
            }
            
            .feature-controls h4 {
                margin: 0 0 5px 0 !important;
                font-size: 14px !important;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin: 10px 0; /* Reduce margin on mobile */
                /* Remove min-height for small mobile */
            }
            
            svg {
                min-width: 320px; /* Minimum width for mobile */
                width: auto !important;
                height: auto !important;
            }
        }
    </style>
</head>
<body>
    <h1>MintWaterfall v0.8.0 Showcase</h1>
    
    <!-- Chart 1: Revenue Analysis -->
    <div class="chart-container">
        <h2>Revenue Analysis</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Comprehensive waterfall chart demonstration showing revenue flow and changes
        </p>
        <div class="theme-selector">
            <label>Theme: </label>
            <select onchange="changeTheme('chart1', this.value)">
                <option value="default" selected>Default</option>
                <option value="dark">Dark</option>
                <option value="corporate">Corporate</option>
                <option value="accessible">Accessible</option>
                <option value="colorful">Colorful</option>
            </select>
        </div>
        
        <!-- Interactive Feature Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #147B58;">
            <h4 style="margin: 0 0 10px 0; color: #147B58;">Interactive Features</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;">
                <button onclick="toggleAccessibility('chart1')" id="accessibility-btn-chart1" style="background: linear-gradient(45deg, #2c3e50, #34495e);">Enable Accessibility</button>
                <button onclick="toggleTooltips('chart1')" id="tooltips-btn-chart1" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Enable Tooltips</button>
                <button onclick="toggleZoom('chart1')" id="zoom-btn-chart1" style="background: linear-gradient(45deg, #e67e22, #f39c12);">Enable Zoom & Pan</button>
                <select onchange="changeTooltipTheme('chart1', this.value)" id="tooltip-theme-chart1" style="padding: 8px; border-radius: 6px;">
                    <option value="default">Default Tooltip</option>
                    <option value="light">Light Tooltip</option>
                    <option value="minimal">Minimal Tooltip</option>
                    <option value="corporate">Corporate Tooltip</option>
                </select>
            </div>
        </div>
        
        <div class="chart-wrapper">
            <svg id="chart1" width="1100" height="400"></svg>
        </div>
        <div class="controls">
            <button onclick="toggleStacked('chart1')">Switch to Waterfall</button>
            <button onclick="toggleTotal('chart1')">Toggle Total</button>
            <button onclick="updateData('chart1')">Update Data</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart1', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart1', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart1', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart1', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 2: Cost Analysis -->
    <div class="chart-container">
        <h2>Cost Analysis - Enterprise Performance + Animation Demo</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 10px;">
            🚀 Performance benchmarking • Advanced animations • Waterfall mode with enterprise features • Real-time conditional formatting
        </p>
        
        <!-- Interactive Feature Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #147B58;">
            <h4 style="margin: 0 0 10px 0; color: #147B58;">Interactive Features</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;">
                <button onclick="toggleAccessibility('chart2')" id="accessibility-btn-chart2" style="background: linear-gradient(45deg, #2c3e50, #34495e);">Enable Accessibility</button>
                <button onclick="toggleTooltips('chart2')" id="tooltips-btn-chart2" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Enable Tooltips</button>
                <button onclick="toggleZoom('chart2')" id="zoom-btn-chart2" style="background: linear-gradient(45deg, #e67e22, #f39c12);">Enable Zoom & Pan</button>
                <select onchange="changeTooltipTheme('chart2', this.value)" id="tooltip-theme-chart2" style="padding: 8px; border-radius: 6px;">
                    <option value="default">Default Tooltip</option>
                    <option value="light">Light Tooltip</option>
                    <option value="minimal">Minimal Tooltip</option>
                    <option value="corporate">Corporate Tooltip</option>
                </select>
            </div>
        </div>
        <div class="chart-wrapper">
            <svg id="chart2" width="1100" height="400"></svg>
        </div>
        <div class="controls">
            <button onclick="toggleStacked('chart2')">Switch to Stacked</button>
            <button class="animation-btn" onclick="animateChart('chart2')">Animate</button>
            <button onclick="sortData('chart2')">Sort by Total</button>
            <button onclick="resetData('chart2')">Reset Order</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart2', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart2', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart2', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart2', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 3: Performance Data -->
    <div class="chart-container">
        <h2>Multi-Category Performance - Stacked</h2>
        <div class="theme-selector">
            <label>Theme: </label>
            <select onchange="changeTheme('chart3', this.value)">
                <option value="default">Default</option>
                <option value="dark">Dark</option>
                <option value="corporate">Corporate</option>
                <option value="accessible">Accessible</option>
                <option value="colorful" selected>Colorful</option>
            </select>
        </div>
        <svg id="chart3" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart3')">Switch to Waterfall</button>
            <button onclick="animateWithEasing('chart3', 'bounce')">Bounce Effect</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart3', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart3', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart3', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart3', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 4: Project Timeline -->
    <div class="chart-container">
        <h2>Project Timeline - Mixed Values</h2>
        <svg id="chart4" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart4')">Switch to Waterfall</button>
            <button onclick="toggleTotal('chart4')">Toggle Total</button>
            <button class="animation-btn" onclick="animateChart('chart4')">Animate</button>
        </div>
    </div>

    <!-- Chart 5: Complex Data -->
    <div class="chart-container">
        <h2>Complex Breakdown - Many Stacks</h2>
        <svg id="chart5" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart5')">Switch to Waterfall</button>
            <button onclick="generateRandomData('chart5')">Generate Data</button>
        </div>
    </div>

    <!-- Enhanced Features Demo Chart -->
    <div class="chart-container">
        <h2>Enhanced Features Demo - Brush Selection & Staggered Animations</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Drag to select data ranges - Staggered animations - Advanced scales
        </p>
        <svg id="chartAdvanced" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStaggered('chartAdvanced')">Toggle Staggered Animation</button>
            <button onclick="clearBrushSelection('chartAdvanced')">Clear Selection</button>
            <button onclick="changeScaleType('chartAdvanced')">Toggle Scale Type</button>
            <button onclick="updateAdvancedData('chartAdvanced')">Update Data</button>
        </div>
        <div id="selection-info" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 4px; display: none;">
            <strong>Selection Summary:</strong>
            <div id="selection-details"></div>
        </div>
    </div>

    <!-- Trend Line Demo Chart -->
    <div class="chart-container">
        <h2>📈 Trend Line Overlays - Interactive Demonstration</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Visualize trends with linear, moving average, and polynomial overlays - Real-time configuration
        </p>
        
        <!-- Trend Line Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 20px; background: linear-gradient(135deg, #f8f9fa, #e3f2fd); border-radius: 12px; border-left: 5px solid #147B58;">
            <h4 style="margin: 0 0 15px 0; color: #147B58; font-size: 18px;">📊 Trend Line Configuration</h4>
            
            <div class="control-group" style="margin-bottom: 15px;">
                <h4>Trend Line Type</h4>
                <div class="feature-buttons">
                    <button onclick="setTrendLine('chartTrend', 'linear')" id="linear-btn" style="background: linear-gradient(45deg, #3498db, #2980b9);">Linear Trend</button>
                    <button onclick="setTrendLine('chartTrend', 'moving-average')" id="moving-btn" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">Moving Average</button>
                    <button onclick="setTrendLine('chartTrend', 'polynomial')" id="polynomial-btn" style="background: linear-gradient(45deg, #f39c12, #e67e22);">Polynomial</button>
                    <button onclick="setTrendLine('chartTrend', 'none')" id="none-btn" style="background: linear-gradient(45deg, #95a5a6, #7f8c8d);">No Trend</button>
                </div>
            </div>
            
            <div class="control-group" style="margin-bottom: 15px;">
                <h4>Styling Options</h4>
                <div class="feature-buttons">
                    <select onchange="changeTrendColor('chartTrend', this.value)" id="color-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; margin-right: 10px;">
                        <option value="#e74c3c">Red</option>
                        <option value="#3498db">Blue</option>
                        <option value="#2ecc71">Green</option>
                        <option value="#f39c12">Orange</option>
                        <option value="#9b59b6">Purple</option>
                        <option value="#1abc9c">Teal</option>
                        <option value="#34495e">Dark Gray</option>
                    </select>
                    <select onchange="changeTrendWidth('chartTrend', this.value)" id="width-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; margin-right: 10px;">
                        <option value="2">Thin (2px)</option>
                        <option value="3" selected>Medium (3px)</option>
                        <option value="4">Thick (4px)</option>
                        <option value="5">Extra Thick (5px)</option>
                    </select>
                    <select onchange="changeTrendStyle('chartTrend', this.value)" id="style-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd;">
                        <option value="solid">Solid Line</option>
                        <option value="dashed">Dashed Line</option>
                        <option value="dotted">Dotted Line</option>
                    </select>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Advanced Settings</h4>
                <div class="feature-buttons">
                    <label style="margin-right: 15px; color: #147B58; font-weight: 500;">
                        Moving Average Window: 
                        <input type="range" min="2" max="5" value="3" onchange="changeTrendWindow('chartTrend', this.value)" id="window-slider" style="margin-left: 5px;">
                        <span id="window-value">3</span>
                    </label>
                    <label style="margin-right: 15px; color: #147B58; font-weight: 500;">
                        Polynomial Degree: 
                        <input type="range" min="2" max="4" value="2" onchange="changeTrendDegree('chartTrend', this.value)" id="degree-slider" style="margin-left: 5px;">
                        <span id="degree-value">2</span>
                    </label>
                    <button onclick="animateTrendChange('chartTrend')" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Animate Trend Change</button>
                </div>
            </div>
        </div>
        
        <svg id="chartTrend" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chartTrend')">Switch Mode</button>
            <button onclick="generateTrendData('chartTrend')">Generate New Data</button>
            <button class="animation-btn" onclick="animateChart('chartTrend')">Animate Chart</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chartTrend', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'csv')">Export CSV</button>
        </div>
        
        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db;">
            <h4 style="color: #3498db; margin: 0 0 10px 0;">💡 Trend Line Information</h4>
            <div id="trend-info" style="color: #666; font-size: 14px; line-height: 1.5;">
                <strong>Current:</strong> No trend line selected. Choose a trend type above to see overlays on your data.
            </div>
        </div>
    </div>

    <script type="module">
        // Import MintWaterfall v0.8.0 Enterprise Edition modules
        try {
            console.log('📦 Starting module imports...');
            
            // Import all modules first
            const chartModule = await import('./mintwaterfall-chart.js');
            const waterfallChart = chartModule.waterfallChart;
            console.log('✅ waterfallChart imported:', typeof waterfallChart);
            
            const themesModule = await import('./mintwaterfall-themes.js');
            const themes = themesModule.themes;
            const applyTheme = themesModule.applyTheme;
            console.log('✅ themes imported:', Object.keys(themes || {}).length, 'themes');
            
            const dataModule = await import('./mintwaterfall-data.js');
            const dataProcessor = dataModule.dataProcessor;
            console.log('✅ dataProcessor imported:', typeof dataProcessor);
            
            const animationModule = await import('./mintwaterfall-animations.js');
            const animationSystem = animationModule.animationSystem;
            console.log('✅ animationSystem imported:', typeof animationSystem);
            
            const tooltipModule = await import('./mintwaterfall-tooltip.js');
            const createTooltipSystem = tooltipModule.createTooltipSystem;
            console.log('✅ createTooltipSystem imported:', typeof createTooltipSystem);
            
            const accessibilityModule = await import('./mintwaterfall-accessibility.js');
            const createAccessibilitySystem = accessibilityModule.createAccessibilitySystem;
            console.log('✅ createAccessibilitySystem imported:', typeof createAccessibilitySystem);
            
            const exportModule = await import('./mintwaterfall-export.js');
            const createExportSystem = exportModule.createExportSystem;
            console.log('✅ createExportSystem imported:', typeof createExportSystem);
            
            const zoomModule = await import('./mintwaterfall-zoom.js');
            const createZoomSystem = zoomModule.createZoomSystem;
            const createZoomControls = zoomModule.createZoomControls;
            console.log('✅ zoom systems imported:', typeof createZoomSystem, typeof createZoomControls);

            // Now initialize charts with all imports available
            initializeCharts(waterfallChart, themes, applyTheme, dataProcessor, animationSystem, 
                           createTooltipSystem, createAccessibilitySystem, createExportSystem, 
                           createZoomSystem, createZoomControls);
            
        } catch (error) {
            console.error('❌ Module import failed:', error);
            console.log('🔄 Falling back to basic chart initialization...');
            initializeBasicCharts();
        }
        
        function initializeCharts(waterfallChart, themes, applyTheme, dataProcessor, animationSystem, 
                                createTooltipSystem, createAccessibilitySystem, createExportSystem, 
                                createZoomSystem, createZoomControls) {
            console.log('🚀 Initializing enterprise charts...');

            // Test D3 availability first
            console.log('🔍 D3 availability:', typeof d3, d3?.version || 'no version');
            
            // Test chart function
            console.log('🔍 waterfallChart function:', typeof waterfallChart);
            if (typeof waterfallChart === 'function') {
                try {
                    const testChart = waterfallChart();
                    console.log('✅ waterfallChart() works:', typeof testChart, testChart);
                } catch (error) {
                    console.error('❌ Error creating test chart:', error);
                }
            }

            // Create enterprise feature system instances
            const tooltipSystem = createTooltipSystem();
            const accessibilitySystem = createAccessibilitySystem();
            const exportSystem = createExportSystem();
            const zoomSystem = createZoomSystem();

            // Test chart availability
            console.log('🔍 Testing chart function availability:', typeof waterfallChart);
            if (typeof waterfallChart === 'function') {
                const testChart = waterfallChart();
                console.log('✅ Chart function works, test chart created:', testChart);
            } else {
                console.error('❌ Chart function not available!');
                return;
            }

        // Sample revenue data for waterfall demonstration
        let revenueData = [
            {
                label: "Q1 Sales",
                stacks: [
                    { value: 45, color: "#3498db", label: "Direct: 45" },
                    { value: 25, color: "#2ecc71", label: "Online: 25" }
                ],
                breakdown: [
                    { label: "North America", stacks: [{ value: 35, color: "#3498db" }] },
                    { label: "Europe", stacks: [{ value: 20, color: "#2ecc71" }] },
                    { label: "Asia Pacific", stacks: [{ value: 15, color: "#e74c3c" }] }
                ]
            },
            {
                label: "Q2 Growth",
                stacks: [
                    { value: 30, color: "#e74c3c", label: "Expansion: 30" }
                ],
                breakdown: [
                    { label: "New Products", stacks: [{ value: 18, color: "#e74c3c" }] },
                    { label: "Market Expansion", stacks: [{ value: 12, color: "#f39c12" }] }
                ]
            },
            {
                label: "Q3 Expansion",
                stacks: [
                    { value: 20, color: "#f39c12", label: "New Markets: 20" },
                    { value: 15, color: "#9b59b6", label: "Products: 15" }
                ],
                breakdown: [
                    { label: "Enterprise Sales", stacks: [{ value: 22, color: "#f39c12" }] },
                    { label: "SMB Growth", stacks: [{ value: 13, color: "#9b59b6" }] }
                ]
            },
            {
                label: "Q4 Holiday",
                stacks: [
                    { value: 40, color: "#1abc9c", label: "Seasonal: 40" }
                ],
                breakdown: [
                    { label: "Black Friday", stacks: [{ value: 25, color: "#1abc9c" }] },
                    { label: "Cyber Monday", stacks: [{ value: 15, color: "#16a085" }] }
                ]
            },
            {
                label: "Q5 Enterprise",
                stacks: [
                    { value: 35, color: "#e67e22", label: "B2B: 35" },
                    { value: 18, color: "#95a5a6", label: "Partnerships: 18" }
                ]
            },
            {
                label: "Q6 International",
                stacks: [
                    { value: 28, color: "#34495e", label: "Export: 28" }
                ]
            },
            {
                label: "Q7 Digital",
                stacks: [
                    { value: 22, color: "#8e44ad", label: "Mobile: 22" },
                    { value: 16, color: "#d35400", label: "Web: 16" }
                ]
            }
        ];

        let costData = [
            {
                label: "Marketing",
                stacks: [
                    { value: 15, color: "#e74c3c", label: "Digital: 15K" },
                    { value: 10, color: "#c0392b", label: "Print: 10K" }
                ]
            },
            {
                label: "Development",
                stacks: [
                    { value: 20, color: "#e67e22", label: "Frontend: 20K" },
                    { value: 15, color: "#d35400", label: "Backend: 15K" }
                ]
            },
            {
                label: "Operations",
                stacks: [
                    { value: 8, color: "#f39c12", label: "Staff: 8K" },
                    { value: 7, color: "#f1c40f", label: "Tools: 7K" }
                ]
            },
            {
                label: "Infrastructure",
                stacks: [
                    { value: 12, color: "#9b59b6", label: "Servers: 12K" },
                    { value: 8, color: "#8e44ad", label: "Network: 8K" }
                ]
            },
            {
                label: "Support",
                stacks: [
                    { value: 7, color: "#34495e", label: "Help Desk: 7K" },
                    { value: 5, color: "#2c3e50", label: "Training: 5K" }
                ]
            },
            {
                label: "Quality Assurance",
                stacks: [
                    { value: 10, color: "#27ae60", label: "Testing: 10K" },
                    { value: 8, color: "#16a085", label: "Review: 8K" }
                ]
            }
        ];

        let performanceData = [
            {
                label: "Product A",
                stacks: [
                    { value: 35, color: "#3498db", label: "Sales: 35M" },
                    { value: 15, color: "#2ecc71", label: "Profit: 15M" },
                    { value: 8, color: "#f39c12", label: "Growth: 8%" }
                ]
            },
            {
                label: "Product B",
                stacks: [
                    { value: 28, color: "#3498db", label: "Sales: 28M" },
                    { value: 22, color: "#2ecc71", label: "Profit: 22M" },
                    { value: 12, color: "#f39c12", label: "Growth: 12%" }
                ]
            },
            {
                label: "Product C",
                stacks: [
                    { value: 45, color: "#3498db", label: "Sales: 45M" },
                    { value: 18, color: "#2ecc71", label: "Profit: 18M" },
                    { value: 6, color: "#f39c12", label: "Growth: 6%" }
                ]
            },
            {
                label: "Product D",
                stacks: [
                    { value: 32, color: "#3498db", label: "Sales: 32M" },
                    { value: 14, color: "#2ecc71", label: "Profit: 14M" },
                    { value: 18, color: "#f39c12", label: "Growth: 18%" }
                ]
            },
            {
                label: "Product E",
                stacks: [
                    { value: 41, color: "#3498db", label: "Sales: 41M" },
                    { value: 19, color: "#2ecc71", label: "Profit: 19M" },
                    { value: 14, color: "#f39c12", label: "Growth: 14%" }
                ]
            },
            {
                label: "Product F",
                stacks: [
                    { value: 29, color: "#3498db", label: "Sales: 29M" },
                    { value: 16, color: "#2ecc71", label: "Profit: 16M" },
                    { value: 9, color: "#f39c12", label: "Growth: 9%" }
                ]
            },
            {
                label: "Product G",
                stacks: [
                    { value: 38, color: "#3498db", label: "Sales: 38M" },
                    { value: 21, color: "#2ecc71", label: "Profit: 21M" },
                    { value: 11, color: "#f39c12", label: "Growth: 11%" }
                ]
            }
        ];

        let projectData = [
            {
                label: "Planning",
                stacks: [
                    { value: 50, color: "#3498db", label: "Research: 50h" },
                    { value: 30, color: "#2ecc71", label: "Design: 30h" }
                ]
            },
            {
                label: "Development",
                stacks: [
                    { value: 120, color: "#e74c3c", label: "Backend: 120h" },
                    { value: 80, color: "#f39c12", label: "Frontend: 80h" },
                    { value: 40, color: "#9b59b6", label: "Testing: 40h" }
                ]
            },
            {
                label: "Integration",
                stacks: [
                    { value: 35, color: "#1abc9c", label: "API: 35h" },
                    { value: 20, color: "#34495e", label: "Database: 20h" }
                ]
            },
            {
                label: "Quality Assurance",
                stacks: [
                    { value: 45, color: "#e67e22", label: "Testing: 45h" },
                    { value: 25, color: "#95a5a6", label: "Review: 25h" }
                ]
            },
            {
                label: "Deployment",
                stacks: [
                    { value: 25, color: "#8e44ad", label: "Setup: 25h" },
                    { value: 15, color: "#d35400", label: "Config: 15h" }
                ]
            },
            {
                label: "Documentation",
                stacks: [
                    { value: 30, color: "#c0392b", label: "User Guide: 30h" },
                    { value: 20, color: "#16a085", label: "Tech Docs: 20h" }
                ]
            },
            {
                label: "Maintenance",
                stacks: [
                    { value: -20, color: "#e67e22", label: "Issues: -20h" },
                    { value: 30, color: "#27ae60", label: "Updates: 30h" }
                ]
            }
        ];

        let complexData = [
            {
                label: "Region A",
                stacks: [
                    { value: 25, color: "#3498db", label: "Q1: 25" },
                    { value: 30, color: "#2ecc71", label: "Q2: 30" },
                    { value: 22, color: "#e74c3c", label: "Q3: 22" },
                    { value: 35, color: "#f39c12", label: "Q4: 35" },
                    { value: 18, color: "#9b59b6", label: "Bonus: 18" }
                ]
            },
            {
                label: "Region B",
                stacks: [
                    { value: 40, color: "#3498db", label: "Q1: 40" },
                    { value: 28, color: "#2ecc71", label: "Q2: 28" },
                    { value: 32, color: "#e74c3c", label: "Q3: 32" },
                    { value: 45, color: "#f39c12", label: "Q4: 45" }
                ]
            },
            {
                label: "Region C",
                stacks: [
                    { value: 20, color: "#3498db", label: "Q1: 20" },
                    { value: 35, color: "#2ecc71", label: "Q2: 35" },
                    { value: 28, color: "#e74c3c", label: "Q3: 28" },
                    { value: 40, color: "#f39c12", label: "Q4: 40" },
                    { value: 15, color: "#9b59b6", label: "Special: 15" },
                    { value: 12, color: "#1abc9c", label: "Extra: 12" }
                ]
            },
            {
                label: "Region D",
                stacks: [
                    { value: 33, color: "#3498db", label: "Q1: 33" },
                    { value: 26, color: "#2ecc71", label: "Q2: 26" },
                    { value: 38, color: "#e74c3c", label: "Q3: 38" },
                    { value: 42, color: "#f39c12", label: "Q4: 42" }
                ]
            },
            {
                label: "Region E",
                stacks: [
                    { value: 29, color: "#3498db", label: "Q1: 29" },
                    { value: 34, color: "#2ecc71", label: "Q2: 34" },
                    { value: 31, color: "#e74c3c", label: "Q3: 31" },
                    { value: 37, color: "#f39c12", label: "Q4: 37" },
                    { value: 14, color: "#9b59b6", label: "Growth: 14" }
                ]
            },
            {
                label: "Region F",
                stacks: [
                    { value: 36, color: "#3498db", label: "Q1: 36" },
                    { value: 24, color: "#2ecc71", label: "Q2: 24" },
                    { value: 39, color: "#e74c3c", label: "Q3: 39" },
                    { value: 44, color: "#f39c12", label: "Q4: 44" }
                ]
            },
            {
                label: "Region G",
                stacks: [
                    { value: 27, color: "#3498db", label: "Q1: 27" },
                    { value: 32, color: "#2ecc71", label: "Q2: 32" },
                    { value: 25, color: "#e74c3c", label: "Q3: 25" },
                    { value: 41, color: "#f39c12", label: "Q4: 41" },
                    { value: 16, color: "#9b59b6", label: "Bonus: 16" },
                    { value: 11, color: "#1abc9c", label: "Extra: 11" }
                ]
            }
        ];

        // Trend line demo data - optimized for trend visualization
        let trendData = [
            {
                label: "Q1 2023",
                stacks: [
                    { value: 45, color: "#3498db", label: "Revenue: 45M" },
                    { value: 12, color: "#2ecc71", label: "Profit: 12M" }
                ]
            },
            {
                label: "Q2 2023",
                stacks: [
                    { value: 52, color: "#3498db", label: "Revenue: 52M" },
                    { value: 18, color: "#2ecc71", label: "Profit: 18M" }
                ]
            },
            {
                label: "Q3 2023",
                stacks: [
                    { value: 48, color: "#3498db", label: "Revenue: 48M" },
                    { value: 15, color: "#2ecc71", label: "Profit: 15M" }
                ]
            },
            {
                label: "Q4 2023",
                stacks: [
                    { value: 65, color: "#3498db", label: "Revenue: 65M" },
                    { value: 25, color: "#2ecc71", label: "Profit: 25M" }
                ]
            },
            {
                label: "Q1 2024",
                stacks: [
                    { value: 58, color: "#3498db", label: "Revenue: 58M" },
                    { value: 22, color: "#2ecc71", label: "Profit: 22M" }
                ]
            },
            {
                label: "Q2 2024",
                stacks: [
                    { value: 72, color: "#3498db", label: "Revenue: 72M" },
                    { value: 30, color: "#2ecc71", label: "Profit: 30M" }
                ]
            },
            {
                label: "Q3 2024",
                stacks: [
                    { value: 68, color: "#3498db", label: "Revenue: 68M" },
                    { value: 28, color: "#2ecc71", label: "Profit: 28M" }
                ]
            },
            {
                label: "Q4 2024",
                stacks: [
                    { value: 85, color: "#3498db", label: "Revenue: 85M" },
                    { value: 38, color: "#2ecc71", label: "Profit: 38M" }
                ]
            }
        ];

        // Chart configurations with enterprise features v0.8.0
        console.log('🔧 Creating chart configurations...');
        const charts = {
            chart1: {
                // RECREATED FROM SCRATCH - Simple waterfall configuration
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Total Revenue',
                    stacked: false,  // Waterfall mode
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 500
                },
                data: revenueData,
                currentTheme: 'default'
            },
            chart2: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Total Budget',
                    stacked: false,  // WATERFALL MODE - back to original
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 800
                },
                data: costData,
                currentTheme: 'default',
                accessibilityEnabled: false,
                tooltipsEnabled: false,
                currentTooltipTheme: 'default'
            },
            chart3: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Total Performance',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750
                },
                data: performanceData,
                currentTheme: 'colorful'
            },
            chart4: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Project Total',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750
                },
                data: projectData,
                currentTheme: 'default'
            },
            chart5: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Grand Total',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750
                },
                data: complexData,
                currentTheme: 'default'
            },
            chartAdvanced: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Enhanced Total',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750,
                    enableBrush: true,
                    staggeredAnimations: true,
                    staggerDelay: 150
                },
                data: [...revenueData], // Clone revenue data
                currentTheme: 'default',
                currentScaleType: 'auto'
            },
            chartTrend: {
                config: {
                    width: 1100,
                    height: 400,
                    showTotal: true,
                    totalLabel: 'Total with Trend',
                    stacked: true,
                    accessibility: false,
                    tooltips: false,
                    barPadding: 0.1,
                    duration: 750,
                    showTrendLine: false,
                    trendLineType: 'linear',
                    trendLineColor: '#e74c3c',
                    trendLineWidth: 3,
                    trendLineStyle: 'solid'
                },
                data: [...trendData], // Use trend-optimized data
                currentTheme: 'default',
                currentTrendType: 'none',
                trendSettings: {
                    color: '#e74c3c',
                    width: 3,
                    style: 'solid',
                    window: 3,
                    degree: 2
                }
            }
        };

        // Initialize charts - CHART1 RECREATED FROM SCRATCH
        console.log('🚀 Starting chart initialization...');
        Object.keys(charts).forEach(chartId => {
            const chartConfig = charts[chartId];
            const { config, data, currentTheme } = chartConfig;
            
            console.log(`🔧 Initializing ${chartId}:`, {
                dataLength: data?.length || 0,
                firstItem: data?.[0] || 'undefined',
                config: config
            });

            // Check if chart element exists
            const chartElement = document.getElementById(chartId);
            console.log(`📍 Chart element ${chartId}:`, chartElement ? 'found' : 'NOT FOUND');
            
            if (!chartElement) {
                console.error(`❌ Chart element ${chartId} not found in DOM!`);
                return;
            }

            // Check if data is valid
            if (!Array.isArray(data) || data.length === 0) {
                console.error(`❌ Chart ${chartId} has invalid data:`, data);
                return;
            }

            // CHART1 RECREATION: Simple, clean chart creation
            if (chartId === 'chart1') {
                console.log(`🆕 RECREATING chart1 from scratch...`);
                
                try {
                    // Create brand new chart instance
                    const chart = waterfallChart()
                        .width(config.width)
                        .height(config.height)
                        .showTotal(config.showTotal)
                        .totalLabel(config.totalLabel)
                        .stacked(false)  // Force waterfall mode
                        .barPadding(config.barPadding)
                        .duration(config.duration);
                    
                    // Store the chart instance
                    chartConfig.chart = chart;
                    
                    console.log(`✅ New chart1 instance created`);
                    
                    // Simple render - no enterprise features, no complexity
                    const selection = d3.select('#chart1');
                    selection.selectAll("*").remove(); // Clear everything
                    
                    setTimeout(() => {
                        selection.datum(data).call(chart);
                        console.log(`✅ chart1 rendered fresh`);
                    }, 100);
                    
                } catch (error) {
                    console.error(`❌ Error creating chart1:`, error);
                    return;
                }
                
                return; // Skip the rest of the complex logic for chart1
            }

            // For other charts, use the existing logic
            // Create chart instance with configuration
            console.log(`🏗️ Creating chart instance for ${chartId}`);
            try {
                let chart = waterfallChart()
                    .width(config.width)
                    .height(config.height)
                    .showTotal(config.showTotal)
                    .totalLabel(config.totalLabel)
                    .stacked(config.stacked)
                    .accessibility(config.accessibility)
                    .tooltips(config.tooltips)
                    .barPadding(config.barPadding)
                    .duration(config.duration);
                
                // Add optional advanced features if they exist in config
                if (config.enableBrush) {
                    chart = chart.enableBrush(config.enableBrush);
                }
                if (config.staggeredAnimations) {
                    chart = chart.staggeredAnimations(config.staggeredAnimations);
                }
                if (config.staggerDelay) {
                    chart = chart.staggerDelay(config.staggerDelay);
                }
                if (config.showTrendLine !== undefined) {
                    chart = chart.showTrendLine(config.showTrendLine);
                }
                if (config.trendLineType) {
                    chart = chart.trendLineType(config.trendLineType);
                }
                if (config.trendLineColor) {
                    chart = chart.trendLineColor(config.trendLineColor);
                }
                if (config.trendLineWidth) {
                    chart = chart.trendLineWidth(config.trendLineWidth);
                }
                if (config.trendLineStyle) {
                    chart = chart.trendLineStyle(config.trendLineStyle);
                }
                
                // Store the chart instance
                chartConfig.chart = chart;
                
                console.log(`✅ Chart instance created for ${chartId}:`, typeof chart);
            } catch (error) {
                console.error(`❌ Error creating chart for ${chartId}:`, error);
                return;
            }
            
            // Add event listeners
            chartConfig.chart.on('barClick', function(event, d) {
                const total = d.stacks.reduce((sum, s) => sum + s.value, 0);
                console.log(`Clicked on ${d.label}: ${total}`);
                
                // Enhanced click behavior for enterprise charts
                if ((chartId === 'chart1' || chartId === 'chart2') && d.breakdown) {
                    console.group(`🏢 Enterprise Breakdown - ${d.label}`);
                    console.log('Total Value:', total);
                    console.log('Breakdown Details:', d.breakdown);
                    console.groupEnd();
                    alert(`🏢 Enterprise Click: ${d.label}: ${total}\n📊 Breakdown available - Check console for details`);
                } else {
                    alert(`Clicked on ${d.label}: ${total}`);
                }
            });

            // Initialize enterprise features for chart1 and chart2
            if (chartId === 'chart1' || chartId === 'chart2') {
                // REMOVED: Pre-configure breakdown analysis that was breaking charts
                // The breakdown analysis will be configured when the user clicks the button
                
                console.log(`🏢 Enterprise features available for ${chartId} (breakdown on-demand)`);
            }

            // Enhanced features for advanced chart
            if (chartId === 'chartAdvanced') {
                chartConfig.chart.on('brushSelection', function(event, selectionData) {
                    const infoDiv = document.getElementById('selection-info');
                    const detailsDiv = document.getElementById('selection-details');
                    
                    if (selectionData.data.length > 0) {
                        infoDiv.style.display = 'block';
                        detailsDiv.innerHTML = `
                            <div>Selected: ${selectionData.data.length} items</div>
                            <div>Total Value: ${selectionData.summary.sum.toFixed(2)}</div>
                            <div>Average: ${selectionData.summary.average.toFixed(2)}</div>
                            <div>Range: ${selectionData.summary.min.toFixed(2)} - ${selectionData.summary.max.toFixed(2)}</div>
                        `;
                    } else {
                        infoDiv.style.display = 'none';
                    }
                });
            }

            // Apply initial theme if specified
            if (currentTheme && currentTheme !== 'default') {
                // Apply theme colors to data
                const theme = themes[currentTheme];
                const themedData = data.map((item, itemIndex) => ({
                    ...item,
                    stacks: item.stacks.map((stack, stackIndex) => ({
                        ...stack,
                        color: theme.colors[stackIndex % theme.colors.length]
                    }))
                }));
                
                // Update chart configuration
                chartConfig.chart.totalColor(theme.totalColor);
                charts[chartId].data = themedData;
                
                // Render with themed data
                d3.select(`#${chartId}`).datum(themedData).call(chartConfig.chart);
                console.log(`🎨 ${chartId} rendered with themed data (${currentTheme}):`, themedData.length, 'items');
            } else {
                // Render with default data
                console.log(`📊 About to render ${chartId} with default data:`, data.length, 'items');
                console.log(`📊 Chart element for ${chartId}:`, document.getElementById(chartId));
                console.log(`📊 Chart function for ${chartId}:`, typeof chartConfig.chart, chartConfig.chart);
                
                // Debug the data structure
                console.log(`📊 Sample data for ${chartId}:`, {
                    firstItem: data[0],
                    dataStructure: data.map(d => ({
                        label: d.label,
                        stackCount: d.stacks?.length || 0,
                        totalValue: d.stacks?.reduce((sum, s) => sum + s.value, 0) || 0,
                        hasBreakdown: !!d.breakdown,
                        stackValues: d.stacks?.map(s => s.value) || []
                    })),
                    grandTotal: data.reduce((total, d) => 
                        total + (d.stacks?.reduce((sum, s) => sum + s.value, 0) || 0), 0
                    )
                });
                
                try {
                    const selection = d3.select(`#${chartId}`);
                    console.log(`📊 D3 selection for ${chartId}:`, selection.node());
                    
                    // TEMPORARY: Create a simple test bar manually to verify D3 works
                    if (chartId === 'chart1') {
                        console.log('🧪 Creating manual test bars for chart1');
                        
                        // Clear the SVG
                        selection.selectAll("*").remove();
                        
                        // Create simple test bars
                        const testData = [
                            { x: 100, y: 300, width: 60, height: 100, color: "#3498db" },
                            { x: 200, y: 250, width: 60, height: 150, color: "#e74c3c" },
                            { x: 300, y: 200, width: 60, height: 200, color: "#f39c12" }
                        ];
                        
                        selection.selectAll("rect")
                            .data(testData)
                            .enter()
                            .append("rect")
                            .attr("x", d => d.x)
                            .attr("y", d => d.y)
                            .attr("width", d => d.width)
                            .attr("height", d => d.height)
                            .attr("fill", d => d.color);
                        
                        console.log('✅ Manual test bars created for chart1');
                    } else {
                        // Add a small delay to ensure DOM is ready
                        setTimeout(() => {
                            const result = selection.datum(data).call(chartConfig.chart);
                            console.log(`✅ ${chartId} rendered successfully:`, result);
                            
                            // Check what was actually rendered
                            const renderedContent = selection.node().innerHTML;
                            console.log(`📊 Rendered content length for ${chartId}:`, renderedContent.length);
                            if (renderedContent.length < 100) {
                                console.warn(`⚠️ ${chartId} may not have rendered properly - content too short:`, renderedContent);
                            }
                        }, 100);
                    }
                } catch (error) {
                    console.error(`❌ Error rendering ${chartId}:`, error);
                }
            }
        });

        // Interactive Feature Control Functions
        window.toggleAccessibility = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const newState = !chartConfig.accessibilityEnabled;
                chartConfig.accessibilityEnabled = newState;
                
                // Update chart configuration
                chartConfig.chart.accessibility(newState);
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text
                const button = document.getElementById(`accessibility-btn-${chartId}`);
                if (button) {
                    button.textContent = newState ? 'Disable Accessibility' : 'Enable Accessibility';
                    button.style.background = newState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #2c3e50, #34495e)';
                }
                
                console.log(`Chart ${chartId}: Accessibility ${newState ? 'enabled' : 'disabled'}`);
            }
        };

        window.toggleTooltips = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const newState = !chartConfig.tooltipsEnabled;
                chartConfig.tooltipsEnabled = newState;
                
                // Update chart configuration
                chartConfig.chart.tooltips(newState);
                
                // Configure tooltip theme if enabling
                if (newState) {
                    const tooltipConfig = {
                        theme: chartConfig.currentTooltipTheme,
                        content: undefined // Use default content
                    };
                    chartConfig.chart.tooltipConfig(tooltipConfig);
                }
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text
                const button = document.getElementById(`tooltips-btn-${chartId}`);
                if (button) {
                    button.textContent = newState ? 'Disable Tooltips' : 'Enable Tooltips';
                    button.style.background = newState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)';
                }
                
                console.log(`Chart ${chartId}: Tooltips ${newState ? 'enabled' : 'disabled'}`);
            }
        };

        window.changeTooltipTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.currentTooltipTheme = themeName;
                
                // Update tooltip configuration if tooltips are enabled
                if (chartConfig.tooltipsEnabled) {
                    const tooltipConfig = {
                        theme: themeName,
                        content: undefined // Use default content
                    };
                    chartConfig.chart.tooltipConfig(tooltipConfig);
                    
                    // Re-render chart to apply new tooltip theme
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                console.log(`Chart ${chartId}: Tooltip theme changed to ${themeName}`);
            }
        };

        // Global functions for UI controls
        window.changeTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig && themes[themeName]) {
                // Update the chart's current theme
                chartConfig.currentTheme = themeName;
                
                // Get the theme object
                const theme = themes[themeName];
                
                // Apply theme colors to the data
                const themedData = chartConfig.data.map((item, itemIndex) => ({
                    ...item,
                    stacks: item.stacks.map((stack, stackIndex) => ({
                        ...stack,
                        color: theme.colors[stackIndex % theme.colors.length]
                    }))
                }));
                
                // Update the chart configuration
                chartConfig.chart.totalColor(theme.totalColor);
                
                // Update the data and re-render
                chartConfig.data = themedData;
                d3.select(`#${chartId}`).datum(themedData).call(chartConfig.chart);
            }
        };

        window.exportChart = function(chartId, format) {
            try {
                const svg = d3.select(`#${chartId}`).node();
                const chartName = `mintwaterfall-${chartId}-${format}`;
                
                if (format === 'svg') {
                    // Export SVG with proper styling
                    const svgClone = svg.cloneNode(true);
                    
                    // Add inline styles to ensure proper rendering
                    const styleElement = document.createElementNS("http://www.w3.org/2000/svg", "style");
                    styleElement.textContent = `
                        .grid-line { stroke: rgba(224, 224, 224, 0.5); stroke-width: 1; }
                        .x-axis, .y-axis { font-size: 12px; font-family: Arial, sans-serif; }
                        .x-axis text, .y-axis text { fill: #333; }
                        .x-axis path, .y-axis path, .x-axis line, .y-axis line { stroke: #666; stroke-width: 1; }
                        .total-label { font-size: 12px; font-weight: bold; fill: #333; font-family: Arial, sans-serif; }
                        .stack-label { font-size: 10px; fill: white; font-family: Arial, sans-serif; }
                        .connector { stroke: #666; stroke-width: 1; stroke-dasharray: 3,3; }
                    `;
                    svgClone.insertBefore(styleElement, svgClone.firstChild);
                    
                    // Set proper SVG attributes
                    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                    
                    const svgData = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const svgUrl = URL.createObjectURL(svgBlob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = svgUrl;
                    downloadLink.download = `${chartName}.svg`;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(svgUrl);
                } else if (format === 'png') {
                    // Export PNG by converting SVG to canvas
                    const svgClone = svg.cloneNode(true);
                    
                    // Add inline styles for proper PNG rendering
                    const styleElement = document.createElementNS("http://www.w3.org/2000/svg", "style");
                    styleElement.textContent = `
                        .grid-line { stroke: rgba(224, 224, 224, 0.5); stroke-width: 1; }
                        .x-axis, .y-axis { font-size: 12px; font-family: Arial, sans-serif; }
                        .x-axis text, .y-axis text { fill: #333; }
                        .x-axis path, .y-axis path, .x-axis line, .y-axis line { stroke: #666; stroke-width: 1; }
                        .total-label { font-size: 12px; font-weight: bold; fill: #333; font-family: Arial, sans-serif; }
                        .stack-label { font-size: 10px; fill: white; font-family: Arial, sans-serif; }
                        .connector { stroke: #666; stroke-width: 1; stroke-dasharray: 3,3; }
                    `;
                    svgClone.insertBefore(styleElement, svgClone.firstChild);
                    
                    // Set proper SVG attributes
                    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                    
                    const svgData = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);
                    const img = new Image();
                    
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = parseInt(svg.getAttribute('width')) || 800;
                        canvas.height = parseInt(svg.getAttribute('height')) || 400;
                        
                        // Fill with white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw the SVG image
                        ctx.drawImage(img, 0, 0);
                        
                        // Download the PNG
                        canvas.toBlob(function(blob) {
                            const pngUrl = URL.createObjectURL(blob);
                            const downloadLink = document.createElement('a');
                            downloadLink.href = pngUrl;
                            downloadLink.download = `${chartName}.png`;
                            document.body.appendChild(downloadLink);
                            downloadLink.click();
                            document.body.removeChild(downloadLink);
                            URL.revokeObjectURL(pngUrl);
                        }, 'image/png');
                        
                        URL.revokeObjectURL(url);
                    };
                    
                    img.onerror = function() {
                        // Fallback: download as SVG instead
                        const svgUrl2 = URL.createObjectURL(svgBlob);
                        const downloadLink = document.createElement('a');
                        downloadLink.href = svgUrl2;
                        downloadLink.download = `${chartName}-fallback.svg`;
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        URL.revokeObjectURL(svgUrl2);
                        alert('PNG export failed, downloaded as SVG instead');
                        URL.revokeObjectURL(url);
                    };
                    
                    img.src = url;
                } else if (format === 'json') {
                    const data = JSON.stringify(charts[chartId].data, null, 2);
                    downloadData(data, `${chartName}.json`, 'application/json');
                } else if (format === 'csv') {
                    const csvData = convertToCSV(charts[chartId].data);
                    downloadData(csvData, `${chartName}.csv`, 'text/csv');
                } else {
                    alert(`${format.toUpperCase()} export not implemented`);
                }
            } catch (error) {
                console.error('Export error:', error);
                alert(`Export failed: ${error.message}`);
            }
        };

        window.toggleStacked = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentStacked = chartConfig.chart.stacked();
                const newMode = !currentStacked;
                
                // Debug: temporary alert to check values
                console.log(`Chart ${chartId}: Current stacked: ${currentStacked}, New mode: ${newMode}`);
                
                chartConfig.chart.stacked(newMode);
                
                // Force a complete re-render
                d3.select(`#${chartId}`).selectAll("*").remove();
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text to show next action
                const button = document.querySelector(`button[onclick="toggleStacked('${chartId}')"]`);
                if (button) {
                    const nextModeName = newMode ? 'Waterfall' : 'Stacked';
                    button.textContent = `Switch to ${nextModeName}`;
                }
            }
        };

        window.toggleTotal = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentTotal = chartConfig.chart.showTotal();
                chartConfig.chart.showTotal(!currentTotal);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
            }
        };

        window.updateData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const updatedData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.abs(stack.value) + (Math.random() - 0.5) * 20))
                    }))
                }));
                
                chartConfig.data = updatedData;
                d3.select(`#${chartId}`).datum(updatedData).call(chartConfig.chart);
            }
        };

        window.animateChart = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Store original data and settings
                const originalData = JSON.parse(JSON.stringify(chartConfig.data));
                const originalDuration = chartConfig.chart.duration();
                const originalEase = chartConfig.chart.ease();
                
                // Create animation data with larger values for dramatic effect
                const animationData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: stack.value * 1.3, // Increase by 30%
                        label: stack.label
                    }))
                }));
                
                // First animation: bounce effect with larger values
                chartConfig.chart.duration(800).ease(d3.easeBounce);
                d3.select(`#${chartId}`).datum(animationData).call(chartConfig.chart);
                
                // Second animation: return to original with elastic effect
                setTimeout(() => {
                    chartConfig.chart.duration(1000).ease(d3.easeElastic);
                    d3.select(`#${chartId}`).datum(originalData).call(chartConfig.chart);
                }, 900);
                
                // Reset to original settings
                setTimeout(() => {
                    chartConfig.chart.duration(originalDuration).ease(originalEase);
                }, 2000);
            }
        };

        window.animateWithEasing = function(chartId, easingType) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                let easing;
                if (easingType === 'bounce') {
                    easing = d3.easeBounceOut;
                } else if (easingType === 'elastic') {
                    easing = d3.easeElasticOut;
                } else {
                    easing = d3.easeQuadInOut;
                }
                
                try {
                    // Store original data
                    const originalData = JSON.parse(JSON.stringify(chartConfig.data));
                    
                    // Create modified data with different values to animate from
                    const animationData = chartConfig.data.map(item => ({
                        ...item,
                        stacks: item.stacks.map(stack => ({
                            ...stack,
                            value: stack.value * 0.1 // Start with 10% of original values
                        }))
                    }));
                    
                    // First, quickly set to the reduced values
                    chartConfig.chart.duration(0);
                    d3.select(`#${chartId}`).datum(animationData).call(chartConfig.chart);
                    
                    // Then animate back to original values with the easing
                    setTimeout(() => {
                        chartConfig.chart.duration(1500).ease(easing);
                        d3.select(`#${chartId}`).datum(originalData).call(chartConfig.chart);
                        
                        // Reset to normal animation settings after
                        setTimeout(() => {
                            chartConfig.chart.duration(750).ease(d3.easeQuadInOut);
                        }, 1600);
                    }, 50);
                    
                    showFeedback(chartId, `Applied ${easingType} easing animation`, 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error applying easing: ' + error.message, 'error');
                }
            } else {
                showFeedback(chartId, 'No chart config found', 'error');
            }
        };

        window.sortData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Store original data if not already stored
                if (!chartConfig.originalData) {
                    chartConfig.originalData = JSON.parse(JSON.stringify(chartConfig.data));
                }
                
                const sortedData = dataProcessor.sortData(chartConfig.data, 'total', 'descending');
                chartConfig.data = sortedData;
                d3.select(`#${chartId}`).datum(sortedData).call(chartConfig.chart);
                
                showFeedback(chartId, 'Sorted by total value (waterfall order affects cumulative totals)', 'success');
            }
        };

        window.resetData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && chartConfig.originalData) {
                chartConfig.data = JSON.parse(JSON.stringify(chartConfig.originalData));
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
            } else {
                showFeedback(chartId, 'No original data to reset to', 'error');
            }
        };

        window.normalizeData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                try {
                    const normalizedData = dataProcessor.normalizeValues(chartConfig.data, 100);
                    chartConfig.data = normalizedData;
                    d3.select(`#${chartId}`).datum(normalizedData).call(chartConfig.chart);
                    
                    // Show visual feedback
                    showFeedback(chartId, 'Data normalized to max value of 100', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error normalizing data: ' + error.message, 'error');
                }
            } else {
                showFeedback(chartId, 'No chart config found', 'error');
            }
        };

        window.generateRandomData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const randomData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.random() * 50 + 10)),
                        label: `Random: ${Math.round(Math.random() * 50 + 10)}`
                    }))
                }));
                
                chartConfig.data = randomData;
                d3.select(`#${chartId}`).datum(randomData).call(chartConfig.chart);
            }
        };

        // ========================================
        // 🏢 ENTERPRISE FEATURE FUNCTIONS v0.8.0
        // ========================================

        window.toggleBreakdownAnalysis = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Enable breakdown analysis using the correct API
                chartConfig.chart.enableBreakdown('category', {
                    minGroupSize: 2,
                    sortStrategy: 'value',
                    showOthers: true,
                    maxGroups: 5
                });
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, '🔍 Breakdown analysis enabled! Click bars to explore hierarchical data', 'success');
                console.log(`📊 Enterprise: Breakdown analysis enabled for ${chartId}`);
            }
        };

        window.toggleConditionalFormatting = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Add conditional formatting rules using the correct API
                chartConfig.chart.addFormattingRule('highValue', {
                    condition: (d) => d.stacks.reduce((sum, s) => sum + s.value, 0) > 50,
                    style: {
                        fill: '#27ae60',
                        stroke: '#1e8449',
                        strokeWidth: 2,
                        opacity: 0.9
                    }
                });
                
                chartConfig.chart.addFormattingRule('lowValue', {
                    condition: (d) => d.stacks.reduce((sum, s) => sum + s.value, 0) < 20,
                    style: {
                        fill: '#e74c3c',
                        stroke: '#c0392b',
                        strokeWidth: 2,
                        opacity: 0.7
                    }
                });
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, '🎨 Conditional formatting applied! High values = Green, Low values = Red', 'success');
                console.log(`🎨 Enterprise: Conditional formatting enabled for ${chartId}`);
            }
        };

        window.runEnterprisePerformanceTest = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                showFeedback(chartId, '⚡ Running enterprise performance test with 50 data points...', 'info');
                
                // Generate large dataset for testing
                const testData = [];
                for (let i = 0; i < 50; i++) {
                    testData.push({
                        label: `Item ${i + 1}`,
                        stacks: [
                            { value: Math.random() * 100 + 20, color: `hsl(${i * 7.2}, 70%, 50%)`, label: `Value: ${Math.round(Math.random() * 100 + 20)}` }
                        ],
                        breakdown: i % 5 === 0 ? [
                            { label: `Sub-item A`, stacks: [{ value: Math.random() * 30, color: '#3498db' }] },
                            { label: `Sub-item B`, stacks: [{ value: Math.random() * 30, color: '#2ecc71' }] }
                        ] : undefined
                    });
                }
                
                const startTime = performance.now();
                
                // Apply breakdown and formatting
                chartConfig.chart.enableBreakdown('category', { maxGroups: 10 });
                chartConfig.chart.addFormattingRule('performance', {
                    condition: (d) => d.stacks[0].value > 80,
                    style: { fill: '#f39c12', strokeWidth: 3 }
                });
                
                // Render with performance timing
                d3.select(`#${chartId}`).datum(testData).call(chartConfig.chart);
                
                const endTime = performance.now();
                const renderTime = Math.round(endTime - startTime);
                
                setTimeout(() => {
                    // Restore original data
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                    showFeedback(chartId, `⚡ Performance test completed! Rendered 50 items in ${renderTime}ms`, 'success');
                }, 2000);
            }
        };

        window.exploreBreakdowns = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                console.group(`📊 Enterprise Data Explorer - ${chartId}`);
                console.log('Chart Configuration:', chartConfig);
                console.log('Data Structure:');
                
                chartConfig.data.forEach((item, index) => {
                    const total = item.stacks.reduce((sum, s) => sum + s.value, 0);
                    console.log(`  ${index + 1}. ${item.label}: ${total} total`);
                    
                    if (item.breakdown && item.breakdown.length > 0) {
                        console.log(`    📋 Breakdown (${item.breakdown.length} items):`);
                        item.breakdown.forEach((breakdownItem, bIndex) => {
                            const breakdownTotal = breakdownItem.stacks.reduce((sum, s) => sum + s.value, 0);
                            console.log(`      ${bIndex + 1}. ${breakdownItem.label}: ${breakdownTotal}`);
                        });
                    } else {
                        console.log(`    📋 No breakdown data available`);
                    }
                });
                
                console.groupEnd();
                showFeedback(chartId, '📊 Data structure logged to console! Check developer tools', 'info');
            }
        };

        // ========================================
        // 🏢 ENTERPRISE v0.8.0 FUNCTIONS
        // ========================================

        // Enterprise Breakdown Analysis
        window.toggleBreakdownAnalysis = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.enableBreakdown();
                chartConfig.chart.enableBreakdown(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, 
                    `🏢 Breakdown Analysis ${!currentState ? 'ENABLED' : 'DISABLED'} - Click bars to explore hierarchical data`, 
                    'success'
                );
            }
        };

        // Enterprise Performance Test
        window.runEnterprisePerformanceTest = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const startTime = performance.now();
                showFeedback(chartId, '🚀 Running enterprise performance benchmark...', 'info');
                
                // Generate large dataset for performance testing
                const performanceData = [];
                for (let i = 0; i < 50; i++) {
                    performanceData.push({
                        label: `Enterprise Item ${i + 1}`,
                        stacks: [
                            { value: Math.random() * 100000 - 50000, color: '#3498db' }
                        ],
                        breakdown: [
                            { label: `Breakdown A`, stacks: [{ value: Math.random() * 25000, color: '#2ecc71' }] },
                            { label: `Breakdown B`, stacks: [{ value: Math.random() * 25000, color: '#e74c3c' }] }
                        ]
                    });
                }
                
                // Render with performance data
                d3.select(`#${chartId}`).datum(performanceData).call(chartConfig.chart);
                
                const endTime = performance.now();
                const renderTime = Math.round(endTime - startTime);
                
                setTimeout(() => {
                    // Restore original data
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                    showFeedback(chartId, 
                        `⚡ Performance Test Complete: ${renderTime}ms for 50 enterprise items with breakdowns`, 
                        'success'
                    );
                }, 2000);
            }
        };

        // Enterprise Data Breakdown Explorer
        window.exploreBreakdowns = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                let hasBreakdowns = false;
                chartConfig.data.forEach(item => {
                    if (item.breakdown && item.breakdown.length > 0) {
                        hasBreakdowns = true;
                        console.log(`📊 ${item.label} breakdown:`, item.breakdown);
                    }
                });
                
                if (hasBreakdowns) {
                    showFeedback(chartId, 
                        '🔍 Enterprise breakdown data explored - Check console for detailed breakdown information', 
                        'success'
                    );
                } else {
                    showFeedback(chartId, 
                        '📊 No breakdown data available - Enable breakdown analysis to see hierarchical details', 
                        'info'
                    );
                }
            }
        };

        // Visual feedback function
        window.showFeedback = function(chartId, message, type) {
            let feedbackDiv = document.getElementById(`feedback-${chartId}`);
            if (!feedbackDiv) {
                feedbackDiv = document.createElement('div');
                feedbackDiv.id = `feedback-${chartId}`;
                feedbackDiv.style.cssText = 'margin: 10px 0; padding: 8px; border-radius: 4px; font-size: 14px; font-weight: bold;';
                
                // Find the chart container and add feedback after the controls
                const chartContainer = document.querySelector(`#${chartId}`).closest('.chart-container');
                const controls = chartContainer.querySelector('.controls') || chartContainer.querySelector('.export-controls');
                if (controls) {
                    controls.parentNode.insertBefore(feedbackDiv, controls.nextSibling);
                }
            }
            
            // Style based on type
            if (type === 'success') {
                feedbackDiv.style.background = '#27ae60';
                feedbackDiv.style.color = 'white';
            } else if (type === 'error') {
                feedbackDiv.style.background = '#e74c3c';
                feedbackDiv.style.color = 'white';
            } else {
                feedbackDiv.style.background = '#f39c12';
                feedbackDiv.style.color = 'white';
            }
            
            feedbackDiv.textContent = message;
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                feedbackDiv.style.opacity = '0';
                setTimeout(() => {
                    if (feedbackDiv.parentNode) {
                        feedbackDiv.parentNode.removeChild(feedbackDiv);
                    }
                }, 300);
            }, 3000);
        };

        // Utility functions
        function convertToCSV(data) {
            const headers = ['Label', 'Stack_Index', 'Value', 'Color', 'Stack_Label'];
            const rows = [headers.join(',')];
            
            data.forEach(item => {
                item.stacks.forEach((stack, index) => {
                    rows.push([
                        `"${item.label}"`,
                        index,
                        stack.value,
                        `"${stack.color}"`,
                        `"${stack.label}"`
                    ].join(','));
                });
            });
            
            return rows.join('\n');
        }

        function downloadData(data, filename, mimeType) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Enhanced feature control functions
        window.toggleStaggered = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentStagger = chartConfig.chart.staggeredAnimations();
                chartConfig.chart.staggeredAnimations(!currentStagger);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, 
                    `Staggered animations ${!currentStagger ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.clearBrushSelection = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Clear brush selection programmatically
                d3.select(`#${chartId}`).selectAll('.waterfall-brush').call(d3.brush().move, null);
                
                // Hide selection info
                const infoDiv = document.getElementById('selection-info');
                if (infoDiv) infoDiv.style.display = 'none';
                
                showFeedback(chartId, 'Selection cleared', 'success');
            }
        };

        window.changeScaleType = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const scaleTypes = ['auto', 'linear', 'ordinal'];
                const currentIndex = scaleTypes.indexOf(chartConfig.currentScaleType || 'auto');
                const nextIndex = (currentIndex + 1) % scaleTypes.length;
                const newScaleType = scaleTypes[nextIndex];
                
                chartConfig.currentScaleType = newScaleType;
                chartConfig.chart.scaleType(newScaleType);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, `Scale type: ${newScaleType}`, 'success');
            }
        };

        window.updateAdvancedData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Generate new random data with enhanced values
                const newData = chartConfig.data.map((item, i) => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.random() * 100 + 20)),
                        label: `${stack.label.split(':')[0]}: ${Math.round(Math.random() * 100 + 20)}`
                    }))
                }));
                
                chartConfig.data = newData;
                d3.select(`#${chartId}`).datum(newData).call(chartConfig.chart);
                
                showFeedback(chartId, 'Data updated with enhanced animations', 'success');
            }
        };

        // Interactive feature toggle functions
        window.toggleAccessibility = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.accessibility();
                chartConfig.chart.accessibility(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`accessibility-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Accessibility' : 'Enable Accessibility';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #2c3e50, #34495e)';
                }
                
                showFeedback(chartId, 
                    `Accessibility ${!currentState ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.toggleTooltips = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.tooltips();
                chartConfig.chart.tooltips(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`tooltips-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Tooltips' : 'Enable Tooltips';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)' : 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)';
                }
                
                showFeedback(chartId, 
                    `Tooltips ${!currentState ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.toggleZoom = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.zoom();
                chartConfig.chart.zoom(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`zoom-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Zoom & Pan' : 'Enable Zoom & Pan';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #e67e22, #f39c12)';
                }
                
                showFeedback(chartId, 
                    `Zoom & Pan ${!currentState ? 'enabled - Use mouse wheel to zoom, drag to pan' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.changeTooltipTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.chart.tooltipConfig({ theme: themeName });
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, `Tooltip theme: ${themeName}`, 'success');
            }
        };

        // Trend Line Functions
        window.setTrendLine = function(chartId, trendType) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.currentTrendType = trendType;
                
                // Update button states
                ['linear', 'moving-average', 'polynomial', 'none'].forEach(type => {
                    const btnId = type === 'moving-average' ? 'moving-btn' : 
                                  type === 'polynomial' ? 'polynomial-btn' : 
                                  type === 'linear' ? 'linear-btn' : 'none-btn';
                    const btn = document.getElementById(btnId);
                    if (btn) {
                        if (type === trendType) {
                            btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)';
                            btn.style.color = 'white';
                        } else {
                            // Reset to original colors
                            if (type === 'linear') btn.style.background = 'linear-gradient(45deg, #3498db, #2980b9)';
                            else if (type === 'moving-average') btn.style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                            else if (type === 'polynomial') btn.style.background = 'linear-gradient(45deg, #f39c12, #e67e22)';
                            else btn.style.background = 'linear-gradient(45deg, #95a5a6, #7f8c8d)';
                        }
                    }
                });

                // Configure chart
                if (trendType === 'none') {
                    chartConfig.chart.showTrendLine(false);
                } else {
                    chartConfig.chart
                        .showTrendLine(true)
                        .trendLineType(trendType)
                        .trendLineColor(chartConfig.trendSettings.color)
                        .trendLineWidth(chartConfig.trendSettings.width)
                        .trendLineStyle(chartConfig.trendSettings.style);
                }

                // Update chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update info display
                updateTrendInfo(chartId, trendType);
                
                showFeedback(chartId, `Trend line: ${trendType === 'none' ? 'disabled' : trendType}`, 'success');
            }
        };

        window.changeTrendColor = function(chartId, color) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.color = color;
                chartConfig.chart.trendLineColor(color);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line color: ${color}`, 'success');
            }
        };

        window.changeTrendWidth = function(chartId, width) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.width = parseInt(width);
                chartConfig.chart.trendLineWidth(parseInt(width));
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line width: ${width}px`, 'success');
            }
        };

        window.changeTrendStyle = function(chartId, style) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.style = style;
                chartConfig.chart.trendLineStyle(style);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line style: ${style}`, 'success');
            }
        };

        window.changeTrendWindow = function(chartId, window) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.window = parseInt(window);
                
                if (chartConfig.currentTrendType === 'moving-average') {
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                document.getElementById('window-value').textContent = window;
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, `Moving average window: ${window}`, 'success');
            }
        };

        window.changeTrendDegree = function(chartId, degree) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.degree = parseInt(degree);
                
                if (chartConfig.currentTrendType === 'polynomial') {
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                document.getElementById('degree-value').textContent = degree;
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, `Polynomial degree: ${degree}`, 'success');
            }
        };

        window.animateTrendChange = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Create a smooth transition effect
                const svg = d3.select(`#${chartId}`);
                const trendLine = svg.select('.trend-line');
                
                if (!trendLine.empty()) {
                    const totalLength = trendLine.node().getTotalLength();
                    
                    trendLine
                        .attr('stroke-dasharray', totalLength + ' ' + totalLength)
                        .attr('stroke-dashoffset', totalLength)
                        .transition()
                        .duration(2000)
                        .ease(d3.easeElastic)
                        .attr('stroke-dashoffset', 0)
                        .on('end', function() {
                            d3.select(this).attr('stroke-dasharray', 'none');
                        });
                        
                    showFeedback(chartId, 'Trend line animated!', 'success');
                } else {
                    showFeedback(chartId, 'Enable a trend line first to see animation', 'info');
                }
            }
        };

        window.generateTrendData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Generate new trend-oriented data with growth pattern
                const baseValue = 40;
                const growth = 1.15; // 15% growth trend
                const volatility = 0.3; // 30% volatility
                
                const newData = [];
                for (let i = 0; i < 8; i++) {
                    const trend = baseValue * Math.pow(growth, i / 2);
                    const noise = (Math.random() - 0.5) * volatility * trend;
                    const revenue = Math.round(trend + noise);
                    const profit = Math.round(revenue * (0.25 + Math.random() * 0.15));
                    
                    newData.push({
                        label: `Q${(i % 4) + 1} ${2023 + Math.floor(i / 4)}`,
                        stacks: [
                            { value: revenue, color: "#3498db", label: `Revenue: ${revenue}M` },
                            { value: profit, color: "#2ecc71", label: `Profit: ${profit}M` }
                        ]
                    });
                }
                
                chartConfig.data = newData;
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, 'New trend data generated!', 'success');
            }
        };

        function updateTrendInfo(chartId, trendType) {
            const infoDiv = document.getElementById('trend-info');
            if (infoDiv && chartId === 'chartTrend') {
                const chartConfig = charts[chartId];
                let infoText = '';
                
                switch (trendType) {
                    case 'linear':
                        infoText = '<strong>Linear Trend:</strong> Shows a straight-line trend through the data points using least squares regression. Best for identifying consistent growth or decline patterns.';
                        break;
                    case 'moving-average':
                        const window = chartConfig.trendSettings.window;
                        infoText = `<strong>Moving Average (${window}-period):</strong> Smooths out short-term fluctuations to reveal underlying trends. Each point represents the average of ${window} consecutive data points.`;
                        break;
                    case 'polynomial':
                        const degree = chartConfig.trendSettings.degree;
                        infoText = `<strong>Polynomial Trend (degree ${degree}):</strong> Fits a curved line that can capture more complex patterns in the data. Higher degrees can show turning points and cycles.`;
                        break;
                    case 'none':
                    default:
                        infoText = '<strong>Current:</strong> No trend line selected. Choose a trend type above to see overlays on your data.';
                        break;
                }
                
                infoDiv.innerHTML = infoText;
            }
        }

        // Responsive chart functionality - improved for touch devices
        function makeChartsResponsive() {
            // Wait for charts to be fully rendered first
            const checkChartsReady = () => {
                const chartElements = document.querySelectorAll('svg[id^="chart"]');
                let allChartsReady = true;
                
                chartElements.forEach(svg => {
                    // Check if chart has actual content (bars, not just empty SVG)
                    const hasContent = svg.querySelector('.bar-group') || svg.querySelector('rect') || svg.querySelector('g');
                    if (!hasContent) {
                        allChartsReady = false;
                    }
                });
                
                if (!allChartsReady) {
                    // Charts not ready yet, check again in 200ms
                    setTimeout(checkChartsReady, 200);
                    return;
                }
                
                // Charts are ready, apply responsive behavior
                chartElements.forEach(svg => {
                    const chartId = svg.id;
                    const container = svg.parentElement;
                    
                    // Get original dimensions from the rendered chart
                    const bbox = svg.getBBox ? svg.getBBox() : { width: 1100, height: 400 };
                    const originalWidth = parseInt(svg.getAttribute('width')) || bbox.width || 1100;
                    const originalHeight = parseInt(svg.getAttribute('height')) || bbox.height || 400;
                    
                    function resizeChart() {
                        const containerWidth = container.clientWidth;
                        const availableWidth = containerWidth - 40; // 20px padding on each side
                        
                        // For tablets and mobile, ensure chart is visible
                        if (availableWidth < originalWidth && availableWidth > 320) {
                            // Set responsive styles without changing chart dimensions
                            svg.style.width = '100%';
                            svg.style.maxWidth = `${availableWidth}px`;
                            svg.style.height = 'auto';
                            svg.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
                            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                        } else if (availableWidth >= originalWidth) {
                            // Reset to original size for desktop
                            svg.style.width = `${originalWidth}px`;
                            svg.style.maxWidth = '100%';
                            svg.style.height = `${originalHeight}px`;
                            svg.removeAttribute('viewBox');
                            svg.removeAttribute('preserveAspectRatio');
                        }
                    }
                    
                    // Set initial responsive styles
                    svg.style.maxWidth = '100%';
                    svg.style.display = 'block';
                    svg.style.margin = '0 auto';
                    
                    // Initial resize
                    resizeChart();
                    
                    // Add resize listener (debounced)
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(resizeChart, 150);
                    });
                    
                    // Add orientation change listener for mobile devices
                    window.addEventListener('orientationchange', () => {
                        setTimeout(resizeChart, 300); // Delay for orientation change
                    });
                });
            };
            
            // Start checking for charts
            checkChartsReady();
        }
        
        // Initialize responsive charts after a longer delay to ensure full initialization
        setTimeout(makeChartsResponsive, 1000);
        
        // Fallback: Ensure charts are visible even if responsive JS fails
        setTimeout(() => {
            const chartElements = document.querySelectorAll('svg[id^="chart"]');
            chartElements.forEach(svg => {
                if (!svg.style.maxWidth) {
                    svg.style.maxWidth = '100%';
                    svg.style.height = 'auto';
                    svg.style.display = 'block';
                    svg.style.margin = '0 auto';
                }
                
                // Force visibility for touch devices
                if ('ontouchstart' in window) {
                    svg.style.visibility = 'visible';
                    svg.style.opacity = '1';
                    svg.setAttribute('viewBox', `0 0 ${svg.getAttribute('width') || 1100} ${svg.getAttribute('height') || 400}`);
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                }
            });
        }, 2000);
        
        // Log successful initialization
        console.log('🌊 MintWaterfall v0.8.0 Enterprise Edition initialized!');
        console.log('📊 Enterprise Features: Breakdown Analysis, Conditional Formatting, Performance Benchmarking');
        console.log('Charts:', Object.keys(charts));
        console.log('Available themes:', Object.keys(themes));
        console.log('Data processor loaded with', Object.keys(dataProcessor).length, 'methods');
        console.log('Animation system loaded with', Object.keys(animationSystem).length, 'features');
        console.log('🏢 Enterprise Features: Advanced breakdown analysis, hierarchical data support, conditional formatting');
        console.log('🎯 Interactive Features: Accessibility (WCAG 2.1 AA), Professional Tooltips, Export System, Zoom & Pan, Responsive Design');
        console.log('♿ Accessibility: Tab navigation, Arrow keys, Screen reader support, Focus management');
        console.log('💡 Tooltips: Smart positioning, Multiple themes, Rich content, Performance optimized');
        console.log('📤 Export: SVG, PNG, JSON, CSV formats available with enterprise data');
        console.log('🔍 Zoom & Pan: Mouse wheel zoom, drag to pan, zoom controls, touch support');
        console.log('📱 Responsive: Mobile-first design, Adaptive charts, Flexible layouts, Enterprise ready');
        
        } // End of initializeCharts()
        
        function initializeBasicCharts() {
            console.log('🔄 Basic fallback initialization...');
            
            // Test D3 first
            if (typeof d3 === 'undefined') {
                console.error('❌ D3 not available!');
                return;
            }
            
            console.log('✅ D3 available:', d3.version);
            
            // Create simple test charts for chart1 and chart2
            ['chart1', 'chart2'].forEach(chartId => {
                const element = document.getElementById(chartId);
                if (!element) {
                    console.error(`❌ Element ${chartId} not found`);
                    return;
                }
                
                console.log(`🔧 Creating basic chart for ${chartId}`);
                
                // Clear any existing content
                d3.select(`#${chartId}`).selectAll("*").remove();
                
                // Create a simple SVG with test bars
                const svg = d3.select(`#${chartId}`)
                    .append("svg")
                    .attr("width", 1100)
                    .attr("height", 400)
                    .style("background", "#f8f9fa");
                
                // Add test data bars
                const testData = [
                    { label: "Q1", value: 70 },
                    { label: "Q2", value: 30 },
                    { label: "Q3", value: 35 },
                    { label: "Q4", value: 40 }
                ];
                
                const xScale = d3.scaleBand()
                    .domain(testData.map(d => d.label))
                    .range([80, 1020])
                    .padding(0.1);
                
                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(testData, d => d.value)])
                    .range([320, 60]);
                
                svg.selectAll("rect")
                    .data(testData)
                    .enter()
                    .append("rect")
                    .attr("x", d => xScale(d.label))
                    .attr("y", d => yScale(d.value))
                    .attr("width", xScale.bandwidth())
                    .attr("height", d => 320 - yScale(d.value))
                    .attr("fill", "#3498db");
                
                svg.selectAll("text")
                    .data(testData)
                    .enter()
                    .append("text")
                    .attr("x", d => xScale(d.label) + xScale.bandwidth() / 2)
                    .attr("y", 350)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#2c3e50")
                    .text(d => d.label);
                
                console.log(`✅ Basic chart created for ${chartId}`);
            });
        }

    </script>
</body>
</html>
