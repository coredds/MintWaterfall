<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MintWaterfall - D3.js Waterfall Chart Component</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 10px;
            background: #147B58;
            color: white;
            min-height: 100vh;
            line-height: 1.6;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin: 10px auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
            max-width: 1200px;
            text-align: center;
            width: 100%;
        }

        /* Responsive container for charts */
        .chart-wrapper {
            width: 100%;
            overflow-x: auto;
            margin: 15px 0;
            /* Remove fixed min-height to prevent empty space */
        }

        /* Ensure SVG charts are visible and responsive */
        svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            /* Prevent iOS Safari from hiding SVG content */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        .waterfall-container {
            background: white;
        }

        /* Grid styling */
        .grid-line {
            stroke: rgba(224, 224, 224, 0.5); /* 50% transparency */
            stroke-width: 1;
        }

        /* Axis styling */
        .x-axis, .y-axis {
            font-size: 12px;
        }

        .x-axis text, .y-axis text {
            fill: #333;
        }

        .x-axis path, .y-axis path,
        .x-axis line, .y-axis line {
            stroke: #666;
            stroke-width: 1;
        }

        /* Bar styling */
        .bar-group rect {
            stroke: none;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .bar-group rect:hover {
            opacity: 0.8;
        }

        /* Label styling */
        .total-label {
            font-size: 12px;
            font-weight: bold;
            fill: #333;
        }

        .stack-label {
            font-size: 10px;
            fill: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }

        /* Connector styling */
        .connector {
            stroke: #666;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }

        /* Tooltip styling */
        .mintwaterfall-tooltip {
            position: absolute;
            visibility: hidden;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 250px;
            line-height: 1.4;
        }

        .mintwaterfall-tooltip .tooltip-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 6px;
            color: #4CAF50;
        }

        .mintwaterfall-tooltip .tooltip-value {
            font-size: 16px;
            font-weight: bold;
            margin: 4px 0;
        }

        .mintwaterfall-tooltip .tooltip-detail {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 4px;
        }

        /* Controls - Responsive */
        .controls {
            margin: 20px 0;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        button {
            background: linear-gradient(45deg, #147B58, #1a9d6b);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(20, 123, 88, 0.3);
            min-width: 120px;
            white-space: nowrap;
        }

        button:hover {
            background: linear-gradient(45deg, #1a9d6b, #20b377);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(20, 123, 88, 0.4);
        }

        /* Feature controls - override inline styles */
        .feature-controls {
            margin: 15px 0 !important;
            padding: 15px !important;
            background: #f8f9fa !important;
            border-radius: 8px !important;
            border-left: 4px solid #147B58 !important;
            text-align: center;
        }

        .feature-controls h4 {
            margin: 0 0 10px 0 !important;
            color: #147B58 !important;
            font-size: 16px;
        }

        .feature-controls > div {
            display: flex !important;
            flex-wrap: wrap !important;
            gap: 10px !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .control-group {
            background: rgba(20, 123, 88, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(20, 123, 88, 0.2);
            text-align: center;
        }

        .control-group h4 {
            margin: 0 0 10px 0;
            color: #147B58;
            font-size: 16px;
        }

        .feature-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        button:active {
            transform: translateY(0px);
        }

        .theme-selector {
            margin: 10px 0;
        }

        .theme-selector select {
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: white;
            color: #333;
            font-family: 'Roboto', sans-serif;
        }

        .export-controls {
            margin: 15px 0;
            text-align: center;
        }

        .export-btn {
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
            margin: 3px;
            padding: 8px 16px;
            font-size: 12px;
        }

        .export-btn:hover {
            background: linear-gradient(45deg, #9b59b6, #a569bd);
        }

        .animation-btn {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
        }

        .animation-btn:hover {
            background: linear-gradient(45deg, #f39c12, #f1c40f);
        }

        /* Responsive Typography */
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            line-height: 1.2;
        }

        h2 {
            color: #333;
            border-bottom: 3px solid #147B58;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: clamp(1.4rem, 3vw, 1.8rem);
            line-height: 1.3;
        }

        h3 {
            color: #147B58;
            margin: 20px 0 15px 0;
            font-weight: 500;
            font-size: clamp(1.2rem, 2.5vw, 1.4rem);
            line-height: 1.4;
        }

        p {
            font-size: clamp(0.9rem, 2vw, 1rem);
            line-height: 1.6;
            margin: 10px 0;
        }

        /* Responsive Breakpoints */
        /* iPad and tablet styles */
        @media (max-width: 1024px) and (min-width: 769px) {
            .chart-container {
                padding: 20px;
                margin: 15px auto;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                /* Remove min-height for tablets */
            }
            
            svg {
                width: 100% !important;
                max-width: 900px !important;
                height: auto !important;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .chart-container {
                padding: 15px;
                margin: 5px auto;
                border-radius: 10px;
            }
            
            .controls {
                gap: 8px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 13px;
                min-width: 100px;
            }
            
            .feature-controls {
                margin: 10px 0 !important;
                padding: 10px !important;
            }
            
            .control-group {
                padding: 12px;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                /* Remove min-height for mobile */
            }
        }

        @media (max-width: 480px) {
            .chart-container {
                padding: 10px;
                border-radius: 8px;
            }
            
            button {
                padding: 6px 12px;
                font-size: 12px;
                min-width: 80px;
            }
            
            .control-group {
                padding: 10px;
            }
            
            .control-group h4 {
                font-size: 14px;
            }
            
            .feature-controls {
                margin: 5px 0 !important;
                padding: 8px !important;
            }
            
            .feature-controls h4 {
                margin: 0 0 5px 0 !important;
                font-size: 14px !important;
            }
            
            .chart-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin: 10px 0; /* Reduce margin on mobile */
                /* Remove min-height for small mobile */
            }
            
            svg {
                min-width: 320px; /* Minimum width for mobile */
                width: auto !important;
                height: auto !important;
            }
        }
    </style>
</head>
<body>
    <h1>MintWaterfall Chart Showcase</h1>
    
    <!-- Chart 1: Revenue Analysis -->
    <div class="chart-container">
        <h2>Revenue Analysis - Interactive Features Demo</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Enable accessibility, tooltips, and export features - Tab + Arrow keys navigation - Smart tooltips - Export ready
        </p>
        <div class="theme-selector">
            <label>Theme: </label>
            <select onchange="changeTheme('chart1', this.value)">
                <option value="default" selected>Default</option>
                <option value="dark">Dark</option>
                <option value="corporate">Corporate</option>
                <option value="accessible">Accessible</option>
                <option value="colorful">Colorful</option>
            </select>
        </div>
        
        <!-- Interactive Feature Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #147B58;">
            <h4 style="margin: 0 0 10px 0; color: #147B58;">Interactive Features</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;">
                <button onclick="toggleAccessibility('chart1')" id="accessibility-btn-chart1" style="background: linear-gradient(45deg, #2c3e50, #34495e);">Enable Accessibility</button>
                <button onclick="toggleTooltips('chart1')" id="tooltips-btn-chart1" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Enable Tooltips</button>
                <button onclick="toggleZoom('chart1')" id="zoom-btn-chart1" style="background: linear-gradient(45deg, #e67e22, #f39c12);">Enable Zoom & Pan</button>
                <select onchange="changeTooltipTheme('chart1', this.value)" id="tooltip-theme-chart1" style="padding: 8px; border-radius: 6px;">
                    <option value="default">Default Tooltip</option>
                    <option value="light">Light Tooltip</option>
                    <option value="minimal">Minimal Tooltip</option>
                    <option value="corporate">Corporate Tooltip</option>
                </select>
            </div>
        </div>
        <div class="chart-wrapper">
            <svg id="chart1" width="1100" height="400"></svg>
        </div>
        <div class="controls">
            <button onclick="toggleStacked('chart1')">Switch to Waterfall</button>
            <button onclick="toggleTotal('chart1')">Toggle Total</button>
            <button onclick="updateData('chart1')">Update Data</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart1', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart1', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart1', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart1', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 2: Cost Analysis -->
    <div class="chart-container">
        <h2>Cost Analysis - Interactive Features + Animation Demo</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 10px;">
            Test interactive features in waterfall mode - Full accessibility support - Professional tooltips
        </p>
        
        <!-- Interactive Feature Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #147B58;">
            <h4 style="margin: 0 0 10px 0; color: #147B58;">Interactive Features</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;">
                <button onclick="toggleAccessibility('chart2')" id="accessibility-btn-chart2" style="background: linear-gradient(45deg, #2c3e50, #34495e);">Enable Accessibility</button>
                <button onclick="toggleTooltips('chart2')" id="tooltips-btn-chart2" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Enable Tooltips</button>
                <button onclick="toggleZoom('chart2')" id="zoom-btn-chart2" style="background: linear-gradient(45deg, #e67e22, #f39c12);">Enable Zoom & Pan</button>
                <select onchange="changeTooltipTheme('chart2', this.value)" id="tooltip-theme-chart2" style="padding: 8px; border-radius: 6px;">
                    <option value="default">Default Tooltip</option>
                    <option value="light">Light Tooltip</option>
                    <option value="minimal">Minimal Tooltip</option>
                    <option value="corporate">Corporate Tooltip</option>
                </select>
            </div>
        </div>
        <div class="chart-wrapper">
            <svg id="chart2" width="1100" height="400"></svg>
        </div>
        <div class="controls">
            <button onclick="toggleStacked('chart2')">Switch to Stacked</button>
            <button class="animation-btn" onclick="animateChart('chart2')">Animate</button>
            <button onclick="sortData('chart2')">Sort by Total</button>
            <button onclick="resetData('chart2')">Reset Order</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart2', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart2', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart2', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart2', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 3: Performance Data -->
    <div class="chart-container">
        <h2>Multi-Category Performance - Stacked</h2>
        <div class="theme-selector">
            <label>Theme: </label>
            <select onchange="changeTheme('chart3', this.value)">
                <option value="default">Default</option>
                <option value="dark">Dark</option>
                <option value="corporate">Corporate</option>
                <option value="accessible">Accessible</option>
                <option value="colorful" selected>Colorful</option>
            </select>
        </div>
        <svg id="chart3" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart3')">Switch to Waterfall</button>
            <button onclick="animateWithEasing('chart3', 'bounce')">Bounce Effect</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chart3', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chart3', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chart3', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chart3', 'csv')">Export CSV</button>
        </div>
    </div>

    <!-- Chart 4: Project Timeline -->
    <div class="chart-container">
        <h2>Project Timeline - Mixed Values</h2>
        <svg id="chart4" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart4')">Switch to Waterfall</button>
            <button onclick="toggleTotal('chart4')">Toggle Total</button>
            <button class="animation-btn" onclick="animateChart('chart4')">Animate</button>
        </div>
    </div>

    <!-- Chart 5: Complex Data -->
    <div class="chart-container">
        <h2>Complex Breakdown - Many Stacks</h2>
        <svg id="chart5" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chart5')">Switch to Waterfall</button>
            <button onclick="generateRandomData('chart5')">Generate Data</button>
        </div>
    </div>

    <!-- Enhanced Features Demo Chart -->
    <div class="chart-container">
        <h2>Enhanced Features Demo - Brush Selection & Staggered Animations</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Drag to select data ranges - Staggered animations - Advanced scales
        </p>
        <svg id="chartAdvanced" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStaggered('chartAdvanced')">Toggle Staggered Animation</button>
            <button onclick="clearBrushSelection('chartAdvanced')">Clear Selection</button>
            <button onclick="changeScaleType('chartAdvanced')">Toggle Scale Type</button>
            <button onclick="updateAdvancedData('chartAdvanced')">Update Data</button>
        </div>
        <div id="selection-info" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 4px; display: none;">
            <strong>Selection Summary:</strong>
            <div id="selection-details"></div>
        </div>
    </div>

    <!-- Trend Line Demo Chart -->
    <div class="chart-container">
        <h2>ðŸ“ˆ Trend Line Overlays - Interactive Demonstration</h2>
        <p style="text-align: center; color: #666; font-style: italic; margin-bottom: 20px;">
            Visualize trends with linear, moving average, and polynomial overlays - Real-time configuration
        </p>
        
        <!-- Trend Line Controls -->
        <div class="feature-controls" style="margin: 15px 0; padding: 20px; background: linear-gradient(135deg, #f8f9fa, #e3f2fd); border-radius: 12px; border-left: 5px solid #147B58;">
            <h4 style="margin: 0 0 15px 0; color: #147B58; font-size: 18px;">ðŸ“Š Trend Line Configuration</h4>
            
            <div class="control-group" style="margin-bottom: 15px;">
                <h4>Trend Line Type</h4>
                <div class="feature-buttons">
                    <button onclick="setTrendLine('chartTrend', 'linear')" id="linear-btn" style="background: linear-gradient(45deg, #3498db, #2980b9);">Linear Trend</button>
                    <button onclick="setTrendLine('chartTrend', 'moving-average')" id="moving-btn" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">Moving Average</button>
                    <button onclick="setTrendLine('chartTrend', 'polynomial')" id="polynomial-btn" style="background: linear-gradient(45deg, #f39c12, #e67e22);">Polynomial</button>
                    <button onclick="setTrendLine('chartTrend', 'none')" id="none-btn" style="background: linear-gradient(45deg, #95a5a6, #7f8c8d);">No Trend</button>
                </div>
            </div>
            
            <div class="control-group" style="margin-bottom: 15px;">
                <h4>Styling Options</h4>
                <div class="feature-buttons">
                    <select onchange="changeTrendColor('chartTrend', this.value)" id="color-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; margin-right: 10px;">
                        <option value="#e74c3c">Red</option>
                        <option value="#3498db">Blue</option>
                        <option value="#2ecc71">Green</option>
                        <option value="#f39c12">Orange</option>
                        <option value="#9b59b6">Purple</option>
                        <option value="#1abc9c">Teal</option>
                        <option value="#34495e">Dark Gray</option>
                    </select>
                    <select onchange="changeTrendWidth('chartTrend', this.value)" id="width-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; margin-right: 10px;">
                        <option value="2">Thin (2px)</option>
                        <option value="3" selected>Medium (3px)</option>
                        <option value="4">Thick (4px)</option>
                        <option value="5">Extra Thick (5px)</option>
                    </select>
                    <select onchange="changeTrendStyle('chartTrend', this.value)" id="style-select" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd;">
                        <option value="solid">Solid Line</option>
                        <option value="dashed">Dashed Line</option>
                        <option value="dotted">Dotted Line</option>
                    </select>
                </div>
            </div>
            
            <div class="control-group">
                <h4>Advanced Settings</h4>
                <div class="feature-buttons">
                    <label style="margin-right: 15px; color: #147B58; font-weight: 500;">
                        Moving Average Window: 
                        <input type="range" min="2" max="5" value="3" onchange="changeTrendWindow('chartTrend', this.value)" id="window-slider" style="margin-left: 5px;">
                        <span id="window-value">3</span>
                    </label>
                    <label style="margin-right: 15px; color: #147B58; font-weight: 500;">
                        Polynomial Degree: 
                        <input type="range" min="2" max="4" value="2" onchange="changeTrendDegree('chartTrend', this.value)" id="degree-slider" style="margin-left: 5px;">
                        <span id="degree-value">2</span>
                    </label>
                    <button onclick="animateTrendChange('chartTrend')" style="background: linear-gradient(45deg, #8e44ad, #9b59b6);">Animate Trend Change</button>
                </div>
            </div>
        </div>
        
        <svg id="chartTrend" width="1100" height="400"></svg>
        <div class="controls">
            <button onclick="toggleStacked('chartTrend')">Switch Mode</button>
            <button onclick="generateTrendData('chartTrend')">Generate New Data</button>
            <button class="animation-btn" onclick="animateChart('chartTrend')">Animate Chart</button>
        </div>
        <div class="export-controls">
            <button class="export-btn" onclick="exportChart('chartTrend', 'svg')">Export SVG</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'png')">Export PNG</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'json')">Export JSON</button>
            <button class="export-btn" onclick="exportChart('chartTrend', 'csv')">Export CSV</button>
        </div>
        
        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db;">
            <h4 style="color: #3498db; margin: 0 0 10px 0;">ðŸ’¡ Trend Line Information</h4>
            <div id="trend-info" style="color: #666; font-size: 14px; line-height: 1.5;">
                <strong>Current:</strong> No trend line selected. Choose a trend type above to see overlays on your data.
            </div>
        </div>
    </div>

    <script type="module">
        // Import all MintWaterfall modules including interactive features
        import { waterfallChart } from './mintwaterfall-chart.js';
        import { themes, applyTheme } from './mintwaterfall-themes.js';
        import { dataProcessor } from './mintwaterfall-data.js';
        import { animationSystem } from './mintwaterfall-animations.js';
        import { createTooltipSystem } from './mintwaterfall-tooltip.js';
        import { createAccessibilitySystem } from './mintwaterfall-accessibility.js';
        import { createExportSystem } from './mintwaterfall-export.js';
        import { createZoomSystem, createZoomControls } from './mintwaterfall-zoom.js';

        // Create interactive system instances
        const tooltipSystem = createTooltipSystem();
        const accessibilitySystem = createAccessibilitySystem();
        const exportSystem = createExportSystem();
        const zoomSystem = createZoomSystem();

        // Sample data
        let revenueData = [
            {
                label: "Q1 Sales",
                stacks: [
                    { value: 45, color: "#3498db", label: "Direct: 45" },
                    { value: 25, color: "#2ecc71", label: "Online: 25" }
                ]
            },
            {
                label: "Q2 Growth",
                stacks: [
                    { value: 30, color: "#e74c3c", label: "Expansion: 30" }
                ]
            },
            {
                label: "Q3 Expansion",
                stacks: [
                    { value: 20, color: "#f39c12", label: "New Markets: 20" },
                    { value: 15, color: "#9b59b6", label: "Products: 15" }
                ]
            },
            {
                label: "Q4 Holiday",
                stacks: [
                    { value: 40, color: "#1abc9c", label: "Seasonal: 40" }
                ]
            },
            {
                label: "Q5 Enterprise",
                stacks: [
                    { value: 35, color: "#e67e22", label: "B2B: 35" },
                    { value: 18, color: "#95a5a6", label: "Partnerships: 18" }
                ]
            },
            {
                label: "Q6 International",
                stacks: [
                    { value: 28, color: "#34495e", label: "Export: 28" }
                ]
            },
            {
                label: "Q7 Digital",
                stacks: [
                    { value: 22, color: "#8e44ad", label: "Mobile: 22" },
                    { value: 16, color: "#d35400", label: "Web: 16" }
                ]
            }
        ];

        let costData = [
            {
                label: "Marketing",
                stacks: [
                    { value: 15, color: "#e74c3c", label: "Digital: 15K" },
                    { value: 10, color: "#c0392b", label: "Print: 10K" }
                ]
            },
            {
                label: "Development",
                stacks: [
                    { value: 20, color: "#e67e22", label: "Frontend: 20K" },
                    { value: 15, color: "#d35400", label: "Backend: 15K" }
                ]
            },
            {
                label: "Operations",
                stacks: [
                    { value: 8, color: "#f39c12", label: "Staff: 8K" },
                    { value: 7, color: "#f1c40f", label: "Tools: 7K" }
                ]
            },
            {
                label: "Infrastructure",
                stacks: [
                    { value: 12, color: "#9b59b6", label: "Servers: 12K" },
                    { value: 8, color: "#8e44ad", label: "Network: 8K" }
                ]
            },
            {
                label: "Support",
                stacks: [
                    { value: 7, color: "#34495e", label: "Help Desk: 7K" },
                    { value: 5, color: "#2c3e50", label: "Training: 5K" }
                ]
            },
            {
                label: "Quality Assurance",
                stacks: [
                    { value: 10, color: "#27ae60", label: "Testing: 10K" },
                    { value: 8, color: "#16a085", label: "Review: 8K" }
                ]
            }
        ];

        let performanceData = [
            {
                label: "Product A",
                stacks: [
                    { value: 35, color: "#3498db", label: "Sales: 35M" },
                    { value: 15, color: "#2ecc71", label: "Profit: 15M" },
                    { value: 8, color: "#f39c12", label: "Growth: 8%" }
                ]
            },
            {
                label: "Product B",
                stacks: [
                    { value: 28, color: "#3498db", label: "Sales: 28M" },
                    { value: 22, color: "#2ecc71", label: "Profit: 22M" },
                    { value: 12, color: "#f39c12", label: "Growth: 12%" }
                ]
            },
            {
                label: "Product C",
                stacks: [
                    { value: 45, color: "#3498db", label: "Sales: 45M" },
                    { value: 18, color: "#2ecc71", label: "Profit: 18M" },
                    { value: 6, color: "#f39c12", label: "Growth: 6%" }
                ]
            },
            {
                label: "Product D",
                stacks: [
                    { value: 32, color: "#3498db", label: "Sales: 32M" },
                    { value: 14, color: "#2ecc71", label: "Profit: 14M" },
                    { value: 18, color: "#f39c12", label: "Growth: 18%" }
                ]
            },
            {
                label: "Product E",
                stacks: [
                    { value: 41, color: "#3498db", label: "Sales: 41M" },
                    { value: 19, color: "#2ecc71", label: "Profit: 19M" },
                    { value: 14, color: "#f39c12", label: "Growth: 14%" }
                ]
            },
            {
                label: "Product F",
                stacks: [
                    { value: 29, color: "#3498db", label: "Sales: 29M" },
                    { value: 16, color: "#2ecc71", label: "Profit: 16M" },
                    { value: 9, color: "#f39c12", label: "Growth: 9%" }
                ]
            },
            {
                label: "Product G",
                stacks: [
                    { value: 38, color: "#3498db", label: "Sales: 38M" },
                    { value: 21, color: "#2ecc71", label: "Profit: 21M" },
                    { value: 11, color: "#f39c12", label: "Growth: 11%" }
                ]
            }
        ];

        let projectData = [
            {
                label: "Planning",
                stacks: [
                    { value: 50, color: "#3498db", label: "Research: 50h" },
                    { value: 30, color: "#2ecc71", label: "Design: 30h" }
                ]
            },
            {
                label: "Development",
                stacks: [
                    { value: 120, color: "#e74c3c", label: "Backend: 120h" },
                    { value: 80, color: "#f39c12", label: "Frontend: 80h" },
                    { value: 40, color: "#9b59b6", label: "Testing: 40h" }
                ]
            },
            {
                label: "Integration",
                stacks: [
                    { value: 35, color: "#1abc9c", label: "API: 35h" },
                    { value: 20, color: "#34495e", label: "Database: 20h" }
                ]
            },
            {
                label: "Quality Assurance",
                stacks: [
                    { value: 45, color: "#e67e22", label: "Testing: 45h" },
                    { value: 25, color: "#95a5a6", label: "Review: 25h" }
                ]
            },
            {
                label: "Deployment",
                stacks: [
                    { value: 25, color: "#8e44ad", label: "Setup: 25h" },
                    { value: 15, color: "#d35400", label: "Config: 15h" }
                ]
            },
            {
                label: "Documentation",
                stacks: [
                    { value: 30, color: "#c0392b", label: "User Guide: 30h" },
                    { value: 20, color: "#16a085", label: "Tech Docs: 20h" }
                ]
            },
            {
                label: "Maintenance",
                stacks: [
                    { value: -20, color: "#e67e22", label: "Issues: -20h" },
                    { value: 30, color: "#27ae60", label: "Updates: 30h" }
                ]
            }
        ];

        let complexData = [
            {
                label: "Region A",
                stacks: [
                    { value: 25, color: "#3498db", label: "Q1: 25" },
                    { value: 30, color: "#2ecc71", label: "Q2: 30" },
                    { value: 22, color: "#e74c3c", label: "Q3: 22" },
                    { value: 35, color: "#f39c12", label: "Q4: 35" },
                    { value: 18, color: "#9b59b6", label: "Bonus: 18" }
                ]
            },
            {
                label: "Region B",
                stacks: [
                    { value: 40, color: "#3498db", label: "Q1: 40" },
                    { value: 28, color: "#2ecc71", label: "Q2: 28" },
                    { value: 32, color: "#e74c3c", label: "Q3: 32" },
                    { value: 45, color: "#f39c12", label: "Q4: 45" }
                ]
            },
            {
                label: "Region C",
                stacks: [
                    { value: 20, color: "#3498db", label: "Q1: 20" },
                    { value: 35, color: "#2ecc71", label: "Q2: 35" },
                    { value: 28, color: "#e74c3c", label: "Q3: 28" },
                    { value: 40, color: "#f39c12", label: "Q4: 40" },
                    { value: 15, color: "#9b59b6", label: "Special: 15" },
                    { value: 12, color: "#1abc9c", label: "Extra: 12" }
                ]
            },
            {
                label: "Region D",
                stacks: [
                    { value: 33, color: "#3498db", label: "Q1: 33" },
                    { value: 26, color: "#2ecc71", label: "Q2: 26" },
                    { value: 38, color: "#e74c3c", label: "Q3: 38" },
                    { value: 42, color: "#f39c12", label: "Q4: 42" }
                ]
            },
            {
                label: "Region E",
                stacks: [
                    { value: 29, color: "#3498db", label: "Q1: 29" },
                    { value: 34, color: "#2ecc71", label: "Q2: 34" },
                    { value: 31, color: "#e74c3c", label: "Q3: 31" },
                    { value: 37, color: "#f39c12", label: "Q4: 37" },
                    { value: 14, color: "#9b59b6", label: "Growth: 14" }
                ]
            },
            {
                label: "Region F",
                stacks: [
                    { value: 36, color: "#3498db", label: "Q1: 36" },
                    { value: 24, color: "#2ecc71", label: "Q2: 24" },
                    { value: 39, color: "#e74c3c", label: "Q3: 39" },
                    { value: 44, color: "#f39c12", label: "Q4: 44" }
                ]
            },
            {
                label: "Region G",
                stacks: [
                    { value: 27, color: "#3498db", label: "Q1: 27" },
                    { value: 32, color: "#2ecc71", label: "Q2: 32" },
                    { value: 25, color: "#e74c3c", label: "Q3: 25" },
                    { value: 41, color: "#f39c12", label: "Q4: 41" },
                    { value: 16, color: "#9b59b6", label: "Bonus: 16" },
                    { value: 11, color: "#1abc9c", label: "Extra: 11" }
                ]
            }
        ];

        // Trend line demo data - optimized for trend visualization
        let trendData = [
            {
                label: "Q1 2023",
                stacks: [
                    { value: 45, color: "#3498db", label: "Revenue: 45M" },
                    { value: 12, color: "#2ecc71", label: "Profit: 12M" }
                ]
            },
            {
                label: "Q2 2023",
                stacks: [
                    { value: 52, color: "#3498db", label: "Revenue: 52M" },
                    { value: 18, color: "#2ecc71", label: "Profit: 18M" }
                ]
            },
            {
                label: "Q3 2023",
                stacks: [
                    { value: 48, color: "#3498db", label: "Revenue: 48M" },
                    { value: 15, color: "#2ecc71", label: "Profit: 15M" }
                ]
            },
            {
                label: "Q4 2023",
                stacks: [
                    { value: 65, color: "#3498db", label: "Revenue: 65M" },
                    { value: 25, color: "#2ecc71", label: "Profit: 25M" }
                ]
            },
            {
                label: "Q1 2024",
                stacks: [
                    { value: 58, color: "#3498db", label: "Revenue: 58M" },
                    { value: 22, color: "#2ecc71", label: "Profit: 22M" }
                ]
            },
            {
                label: "Q2 2024",
                stacks: [
                    { value: 72, color: "#3498db", label: "Revenue: 72M" },
                    { value: 30, color: "#2ecc71", label: "Profit: 30M" }
                ]
            },
            {
                label: "Q3 2024",
                stacks: [
                    { value: 68, color: "#3498db", label: "Revenue: 68M" },
                    { value: 28, color: "#2ecc71", label: "Profit: 28M" }
                ]
            },
            {
                label: "Q4 2024",
                stacks: [
                    { value: 85, color: "#3498db", label: "Revenue: 85M" },
                    { value: 38, color: "#2ecc71", label: "Profit: 38M" }
                ]
            }
        ];

        // Chart configurations with interactive features
        const charts = {
            chart1: {
                chart: waterfallChart()
                    .width(1100)
                    .height(400)
                    .showTotal(true)
                    .totalLabel('Total Revenue')
                    .stacked(true)
                    .accessibility(false)
                    .tooltips(false),
                data: revenueData,
                currentTheme: 'default',
                accessibilityEnabled: false,
                tooltipsEnabled: false,
                currentTooltipTheme: 'default'
            },
            chart2: {
                chart: waterfallChart()
                    .width(1100)
                    .height(400)
                    .showTotal(true)
                    .totalLabel('Total Budget')
                    .stacked(false)
                    .accessibility(false)
                    .tooltips(false),
                data: costData,
                currentTheme: 'default',
                accessibilityEnabled: false,
                tooltipsEnabled: false,
                currentTooltipTheme: 'default'
            },
            chart3: {
                chart: waterfallChart()
                    .width(1100)
                    .height(400)
                    .showTotal(true)
                    .totalLabel('Total Performance')
                    .stacked(true),
                data: performanceData,
                currentTheme: 'colorful'
            },
            chart4: {
                chart: waterfallChart()
                    .width(1100)
                    .height(400)
                    .showTotal(true)
                    .totalLabel('Project Total')
                    .stacked(true),
                data: projectData,
                currentTheme: 'default'
            },
            chart5: {
                chart: waterfallChart()
                    .width(1100)
                    .height(400)
                    .showTotal(true)
                    .totalLabel('Grand Total')
                    .stacked(true),
                data: complexData,
                currentTheme: 'default'
            },
            chartAdvanced: {
                chart: waterfallChart()
                    .width(1100)
                    .height(400)
                    .showTotal(true)
                    .totalLabel('Enhanced Total')
                    .stacked(true)
                    .enableBrush(true)
                    .staggeredAnimations(true)
                    .staggerDelay(150),
                data: [...revenueData], // Clone revenue data
                currentTheme: 'default',
                currentScaleType: 'auto'
            },
            chartTrend: {
                chart: waterfallChart()
                    .width(1100)
                    .height(400)
                    .showTotal(true)
                    .totalLabel('Total with Trend')
                    .stacked(true)
                    .showTrendLine(false)
                    .trendLineType('linear')
                    .trendLineColor('#e74c3c')
                    .trendLineWidth(3)
                    .trendLineStyle('solid'),
                data: [...trendData], // Use trend-optimized data
                currentTheme: 'default',
                currentTrendType: 'none',
                trendSettings: {
                    color: '#e74c3c',
                    width: 3,
                    style: 'solid',
                    window: 3,
                    degree: 2
                }
            }
        };

        // Initialize charts
        Object.keys(charts).forEach(chartId => {
            const { chart, data, currentTheme } = charts[chartId];
            
            // Add event listeners
            chart.on('barClick', function(event, d) {
                const total = d.stacks.reduce((sum, s) => sum + s.value, 0);
                console.log(`Clicked on ${d.label}: ${total}`);
                alert(`Clicked on ${d.label}: ${total}`);
            });

            // Enhanced features for advanced chart
            if (chartId === 'chartAdvanced') {
                chart.on('brushSelection', function(event, selectionData) {
                    const infoDiv = document.getElementById('selection-info');
                    const detailsDiv = document.getElementById('selection-details');
                    
                    if (selectionData.data.length > 0) {
                        infoDiv.style.display = 'block';
                        detailsDiv.innerHTML = `
                            <div>Selected: ${selectionData.data.length} items</div>
                            <div>Total Value: ${selectionData.summary.sum.toFixed(2)}</div>
                            <div>Average: ${selectionData.summary.average.toFixed(2)}</div>
                            <div>Range: ${selectionData.summary.min.toFixed(2)} - ${selectionData.summary.max.toFixed(2)}</div>
                        `;
                    } else {
                        infoDiv.style.display = 'none';
                    }
                });
            }

            // Apply initial theme if specified
            if (currentTheme && currentTheme !== 'default') {
                // Apply theme colors to data
                const theme = themes[currentTheme];
                const themedData = data.map((item, itemIndex) => ({
                    ...item,
                    stacks: item.stacks.map((stack, stackIndex) => ({
                        ...stack,
                        color: theme.colors[stackIndex % theme.colors.length]
                    }))
                }));
                
                // Update chart configuration
                chart.totalColor(theme.totalColor);
                charts[chartId].data = themedData;
                
                // Render with themed data
                d3.select(`#${chartId}`).datum(themedData).call(chart);
            } else {
                // Render with default data
                d3.select(`#${chartId}`).datum(data).call(chart);
            }
        });

        // Interactive Feature Control Functions
        window.toggleAccessibility = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const newState = !chartConfig.accessibilityEnabled;
                chartConfig.accessibilityEnabled = newState;
                
                // Update chart configuration
                chartConfig.chart.accessibility(newState);
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text
                const button = document.getElementById(`accessibility-btn-${chartId}`);
                if (button) {
                    button.textContent = newState ? 'Disable Accessibility' : 'Enable Accessibility';
                    button.style.background = newState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #2c3e50, #34495e)';
                }
                
                console.log(`Chart ${chartId}: Accessibility ${newState ? 'enabled' : 'disabled'}`);
            }
        };

        window.toggleTooltips = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const newState = !chartConfig.tooltipsEnabled;
                chartConfig.tooltipsEnabled = newState;
                
                // Update chart configuration
                chartConfig.chart.tooltips(newState);
                
                // Configure tooltip theme if enabling
                if (newState) {
                    const tooltipConfig = {
                        theme: chartConfig.currentTooltipTheme,
                        content: undefined // Use default content
                    };
                    chartConfig.chart.tooltipConfig(tooltipConfig);
                }
                
                // Re-render chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text
                const button = document.getElementById(`tooltips-btn-${chartId}`);
                if (button) {
                    button.textContent = newState ? 'Disable Tooltips' : 'Enable Tooltips';
                    button.style.background = newState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)';
                }
                
                console.log(`Chart ${chartId}: Tooltips ${newState ? 'enabled' : 'disabled'}`);
            }
        };

        window.changeTooltipTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.currentTooltipTheme = themeName;
                
                // Update tooltip configuration if tooltips are enabled
                if (chartConfig.tooltipsEnabled) {
                    const tooltipConfig = {
                        theme: themeName,
                        content: undefined // Use default content
                    };
                    chartConfig.chart.tooltipConfig(tooltipConfig);
                    
                    // Re-render chart to apply new tooltip theme
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                console.log(`Chart ${chartId}: Tooltip theme changed to ${themeName}`);
            }
        };

        // Global functions for UI controls
        window.changeTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig && themes[themeName]) {
                // Update the chart's current theme
                chartConfig.currentTheme = themeName;
                
                // Get the theme object
                const theme = themes[themeName];
                
                // Apply theme colors to the data
                const themedData = chartConfig.data.map((item, itemIndex) => ({
                    ...item,
                    stacks: item.stacks.map((stack, stackIndex) => ({
                        ...stack,
                        color: theme.colors[stackIndex % theme.colors.length]
                    }))
                }));
                
                // Update the chart configuration
                chartConfig.chart.totalColor(theme.totalColor);
                
                // Update the data and re-render
                chartConfig.data = themedData;
                d3.select(`#${chartId}`).datum(themedData).call(chartConfig.chart);
            }
        };

        window.exportChart = function(chartId, format) {
            try {
                const svg = d3.select(`#${chartId}`).node();
                const chartName = `mintwaterfall-${chartId}-${format}`;
                
                if (format === 'svg') {
                    // Export SVG with proper styling
                    const svgClone = svg.cloneNode(true);
                    
                    // Add inline styles to ensure proper rendering
                    const styleElement = document.createElementNS("http://www.w3.org/2000/svg", "style");
                    styleElement.textContent = `
                        .grid-line { stroke: rgba(224, 224, 224, 0.5); stroke-width: 1; }
                        .x-axis, .y-axis { font-size: 12px; font-family: Arial, sans-serif; }
                        .x-axis text, .y-axis text { fill: #333; }
                        .x-axis path, .y-axis path, .x-axis line, .y-axis line { stroke: #666; stroke-width: 1; }
                        .total-label { font-size: 12px; font-weight: bold; fill: #333; font-family: Arial, sans-serif; }
                        .stack-label { font-size: 10px; fill: white; font-family: Arial, sans-serif; }
                        .connector { stroke: #666; stroke-width: 1; stroke-dasharray: 3,3; }
                    `;
                    svgClone.insertBefore(styleElement, svgClone.firstChild);
                    
                    // Set proper SVG attributes
                    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                    
                    const svgData = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const svgUrl = URL.createObjectURL(svgBlob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = svgUrl;
                    downloadLink.download = `${chartName}.svg`;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(svgUrl);
                } else if (format === 'png') {
                    // Export PNG by converting SVG to canvas
                    const svgClone = svg.cloneNode(true);
                    
                    // Add inline styles for proper PNG rendering
                    const styleElement = document.createElementNS("http://www.w3.org/2000/svg", "style");
                    styleElement.textContent = `
                        .grid-line { stroke: rgba(224, 224, 224, 0.5); stroke-width: 1; }
                        .x-axis, .y-axis { font-size: 12px; font-family: Arial, sans-serif; }
                        .x-axis text, .y-axis text { fill: #333; }
                        .x-axis path, .y-axis path, .x-axis line, .y-axis line { stroke: #666; stroke-width: 1; }
                        .total-label { font-size: 12px; font-weight: bold; fill: #333; font-family: Arial, sans-serif; }
                        .stack-label { font-size: 10px; fill: white; font-family: Arial, sans-serif; }
                        .connector { stroke: #666; stroke-width: 1; stroke-dasharray: 3,3; }
                    `;
                    svgClone.insertBefore(styleElement, svgClone.firstChild);
                    
                    // Set proper SVG attributes
                    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                    
                    const svgData = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);
                    const img = new Image();
                    
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = parseInt(svg.getAttribute('width')) || 800;
                        canvas.height = parseInt(svg.getAttribute('height')) || 400;
                        
                        // Fill with white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw the SVG image
                        ctx.drawImage(img, 0, 0);
                        
                        // Download the PNG
                        canvas.toBlob(function(blob) {
                            const pngUrl = URL.createObjectURL(blob);
                            const downloadLink = document.createElement('a');
                            downloadLink.href = pngUrl;
                            downloadLink.download = `${chartName}.png`;
                            document.body.appendChild(downloadLink);
                            downloadLink.click();
                            document.body.removeChild(downloadLink);
                            URL.revokeObjectURL(pngUrl);
                        }, 'image/png');
                        
                        URL.revokeObjectURL(url);
                    };
                    
                    img.onerror = function() {
                        // Fallback: download as SVG instead
                        const svgUrl2 = URL.createObjectURL(svgBlob);
                        const downloadLink = document.createElement('a');
                        downloadLink.href = svgUrl2;
                        downloadLink.download = `${chartName}-fallback.svg`;
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        URL.revokeObjectURL(svgUrl2);
                        alert('PNG export failed, downloaded as SVG instead');
                        URL.revokeObjectURL(url);
                    };
                    
                    img.src = url;
                } else if (format === 'json') {
                    const data = JSON.stringify(charts[chartId].data, null, 2);
                    downloadData(data, `${chartName}.json`, 'application/json');
                } else if (format === 'csv') {
                    const csvData = convertToCSV(charts[chartId].data);
                    downloadData(csvData, `${chartName}.csv`, 'text/csv');
                } else {
                    alert(`${format.toUpperCase()} export not implemented`);
                }
            } catch (error) {
                console.error('Export error:', error);
                alert(`Export failed: ${error.message}`);
            }
        };

        window.toggleStacked = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentStacked = chartConfig.chart.stacked();
                const newMode = !currentStacked;
                
                // Debug: temporary alert to check values
                console.log(`Chart ${chartId}: Current stacked: ${currentStacked}, New mode: ${newMode}`);
                
                chartConfig.chart.stacked(newMode);
                
                // Force a complete re-render
                d3.select(`#${chartId}`).selectAll("*").remove();
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update button text to show next action
                const button = document.querySelector(`button[onclick="toggleStacked('${chartId}')"]`);
                if (button) {
                    const nextModeName = newMode ? 'Waterfall' : 'Stacked';
                    button.textContent = `Switch to ${nextModeName}`;
                }
            }
        };

        window.toggleTotal = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentTotal = chartConfig.chart.showTotal();
                chartConfig.chart.showTotal(!currentTotal);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
            }
        };

        window.updateData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const updatedData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.abs(stack.value) + (Math.random() - 0.5) * 20))
                    }))
                }));
                
                chartConfig.data = updatedData;
                d3.select(`#${chartId}`).datum(updatedData).call(chartConfig.chart);
            }
        };

        window.animateChart = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Store original data and settings
                const originalData = JSON.parse(JSON.stringify(chartConfig.data));
                const originalDuration = chartConfig.chart.duration();
                const originalEase = chartConfig.chart.ease();
                
                // Create animation data with larger values for dramatic effect
                const animationData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: stack.value * 1.3, // Increase by 30%
                        label: stack.label
                    }))
                }));
                
                // First animation: bounce effect with larger values
                chartConfig.chart.duration(800).ease(d3.easeBounce);
                d3.select(`#${chartId}`).datum(animationData).call(chartConfig.chart);
                
                // Second animation: return to original with elastic effect
                setTimeout(() => {
                    chartConfig.chart.duration(1000).ease(d3.easeElastic);
                    d3.select(`#${chartId}`).datum(originalData).call(chartConfig.chart);
                }, 900);
                
                // Reset to original settings
                setTimeout(() => {
                    chartConfig.chart.duration(originalDuration).ease(originalEase);
                }, 2000);
            }
        };

        window.animateWithEasing = function(chartId, easingType) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                let easing;
                if (easingType === 'bounce') {
                    easing = d3.easeBounceOut;
                } else if (easingType === 'elastic') {
                    easing = d3.easeElasticOut;
                } else {
                    easing = d3.easeQuadInOut;
                }
                
                try {
                    // Store original data
                    const originalData = JSON.parse(JSON.stringify(chartConfig.data));
                    
                    // Create modified data with different values to animate from
                    const animationData = chartConfig.data.map(item => ({
                        ...item,
                        stacks: item.stacks.map(stack => ({
                            ...stack,
                            value: stack.value * 0.1 // Start with 10% of original values
                        }))
                    }));
                    
                    // First, quickly set to the reduced values
                    chartConfig.chart.duration(0);
                    d3.select(`#${chartId}`).datum(animationData).call(chartConfig.chart);
                    
                    // Then animate back to original values with the easing
                    setTimeout(() => {
                        chartConfig.chart.duration(1500).ease(easing);
                        d3.select(`#${chartId}`).datum(originalData).call(chartConfig.chart);
                        
                        // Reset to normal animation settings after
                        setTimeout(() => {
                            chartConfig.chart.duration(750).ease(d3.easeQuadInOut);
                        }, 1600);
                    }, 50);
                    
                    showFeedback(chartId, `Applied ${easingType} easing animation`, 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error applying easing: ' + error.message, 'error');
                }
            } else {
                showFeedback(chartId, 'No chart config found', 'error');
            }
        };

        window.sortData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Store original data if not already stored
                if (!chartConfig.originalData) {
                    chartConfig.originalData = JSON.parse(JSON.stringify(chartConfig.data));
                }
                
                const sortedData = dataProcessor.sortData(chartConfig.data, 'total', 'descending');
                chartConfig.data = sortedData;
                d3.select(`#${chartId}`).datum(sortedData).call(chartConfig.chart);
                
                showFeedback(chartId, 'Sorted by total value (waterfall order affects cumulative totals)', 'success');
            }
        };

        window.resetData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig && chartConfig.originalData) {
                chartConfig.data = JSON.parse(JSON.stringify(chartConfig.originalData));
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
            } else {
                showFeedback(chartId, 'No original data to reset to', 'error');
            }
        };

        window.normalizeData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                try {
                    const normalizedData = dataProcessor.normalizeValues(chartConfig.data, 100);
                    chartConfig.data = normalizedData;
                    d3.select(`#${chartId}`).datum(normalizedData).call(chartConfig.chart);
                    
                    // Show visual feedback
                    showFeedback(chartId, 'Data normalized to max value of 100', 'success');
                } catch (error) {
                    showFeedback(chartId, 'Error normalizing data: ' + error.message, 'error');
                }
            } else {
                showFeedback(chartId, 'No chart config found', 'error');
            }
        };

        window.generateRandomData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const randomData = chartConfig.data.map(item => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.random() * 50 + 10)),
                        label: `Random: ${Math.round(Math.random() * 50 + 10)}`
                    }))
                }));
                
                chartConfig.data = randomData;
                d3.select(`#${chartId}`).datum(randomData).call(chartConfig.chart);
            }
        };

        // Visual feedback function
        window.showFeedback = function(chartId, message, type) {
            let feedbackDiv = document.getElementById(`feedback-${chartId}`);
            if (!feedbackDiv) {
                feedbackDiv = document.createElement('div');
                feedbackDiv.id = `feedback-${chartId}`;
                feedbackDiv.style.cssText = 'margin: 10px 0; padding: 8px; border-radius: 4px; font-size: 14px; font-weight: bold;';
                
                // Find the chart container and add feedback after the controls
                const chartContainer = document.querySelector(`#${chartId}`).closest('.chart-container');
                const controls = chartContainer.querySelector('.controls') || chartContainer.querySelector('.export-controls');
                if (controls) {
                    controls.parentNode.insertBefore(feedbackDiv, controls.nextSibling);
                }
            }
            
            // Style based on type
            if (type === 'success') {
                feedbackDiv.style.background = '#27ae60';
                feedbackDiv.style.color = 'white';
            } else if (type === 'error') {
                feedbackDiv.style.background = '#e74c3c';
                feedbackDiv.style.color = 'white';
            } else {
                feedbackDiv.style.background = '#f39c12';
                feedbackDiv.style.color = 'white';
            }
            
            feedbackDiv.textContent = message;
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                feedbackDiv.style.opacity = '0';
                setTimeout(() => {
                    if (feedbackDiv.parentNode) {
                        feedbackDiv.parentNode.removeChild(feedbackDiv);
                    }
                }, 300);
            }, 3000);
        };

        // Utility functions
        function convertToCSV(data) {
            const headers = ['Label', 'Stack_Index', 'Value', 'Color', 'Stack_Label'];
            const rows = [headers.join(',')];
            
            data.forEach(item => {
                item.stacks.forEach((stack, index) => {
                    rows.push([
                        `"${item.label}"`,
                        index,
                        stack.value,
                        `"${stack.color}"`,
                        `"${stack.label}"`
                    ].join(','));
                });
            });
            
            return rows.join('\n');
        }

        function downloadData(data, filename, mimeType) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Enhanced feature control functions
        window.toggleStaggered = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentStagger = chartConfig.chart.staggeredAnimations();
                chartConfig.chart.staggeredAnimations(!currentStagger);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, 
                    `Staggered animations ${!currentStagger ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.clearBrushSelection = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Clear brush selection programmatically
                d3.select(`#${chartId}`).selectAll('.waterfall-brush').call(d3.brush().move, null);
                
                // Hide selection info
                const infoDiv = document.getElementById('selection-info');
                if (infoDiv) infoDiv.style.display = 'none';
                
                showFeedback(chartId, 'Selection cleared', 'success');
            }
        };

        window.changeScaleType = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const scaleTypes = ['auto', 'linear', 'ordinal'];
                const currentIndex = scaleTypes.indexOf(chartConfig.currentScaleType || 'auto');
                const nextIndex = (currentIndex + 1) % scaleTypes.length;
                const newScaleType = scaleTypes[nextIndex];
                
                chartConfig.currentScaleType = newScaleType;
                chartConfig.chart.scaleType(newScaleType);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, `Scale type: ${newScaleType}`, 'success');
            }
        };

        window.updateAdvancedData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Generate new random data with enhanced values
                const newData = chartConfig.data.map((item, i) => ({
                    ...item,
                    stacks: item.stacks.map(stack => ({
                        ...stack,
                        value: Math.max(5, Math.round(Math.random() * 100 + 20)),
                        label: `${stack.label.split(':')[0]}: ${Math.round(Math.random() * 100 + 20)}`
                    }))
                }));
                
                chartConfig.data = newData;
                d3.select(`#${chartId}`).datum(newData).call(chartConfig.chart);
                
                showFeedback(chartId, 'Data updated with enhanced animations', 'success');
            }
        };

        // Interactive feature toggle functions
        window.toggleAccessibility = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.accessibility();
                chartConfig.chart.accessibility(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`accessibility-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Accessibility' : 'Enable Accessibility';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #2c3e50, #34495e)';
                }
                
                showFeedback(chartId, 
                    `Accessibility ${!currentState ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.toggleTooltips = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.tooltips();
                chartConfig.chart.tooltips(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`tooltips-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Tooltips' : 'Enable Tooltips';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)' : 
                        'linear-gradient(45deg, #8e44ad, #9b59b6)';
                }
                
                showFeedback(chartId, 
                    `Tooltips ${!currentState ? 'enabled' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.toggleZoom = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                const currentState = chartConfig.chart.zoom();
                chartConfig.chart.zoom(!currentState);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                const button = document.getElementById(`zoom-btn-${chartId}`);
                if (button) {
                    button.textContent = !currentState ? 'Disable Zoom & Pan' : 'Enable Zoom & Pan';
                    button.style.background = !currentState ? 
                        'linear-gradient(45deg, #27ae60, #2ecc71)' : 
                        'linear-gradient(45deg, #e67e22, #f39c12)';
                }
                
                showFeedback(chartId, 
                    `Zoom & Pan ${!currentState ? 'enabled - Use mouse wheel to zoom, drag to pan' : 'disabled'}`, 
                    'success'
                );
            }
        };

        window.changeTooltipTheme = function(chartId, themeName) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.chart.tooltipConfig({ theme: themeName });
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                showFeedback(chartId, `Tooltip theme: ${themeName}`, 'success');
            }
        };

        // Trend Line Functions
        window.setTrendLine = function(chartId, trendType) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.currentTrendType = trendType;
                
                // Update button states
                ['linear', 'moving-average', 'polynomial', 'none'].forEach(type => {
                    const btnId = type === 'moving-average' ? 'moving-btn' : 
                                  type === 'polynomial' ? 'polynomial-btn' : 
                                  type === 'linear' ? 'linear-btn' : 'none-btn';
                    const btn = document.getElementById(btnId);
                    if (btn) {
                        if (type === trendType) {
                            btn.style.background = 'linear-gradient(45deg, #27ae60, #2ecc71)';
                            btn.style.color = 'white';
                        } else {
                            // Reset to original colors
                            if (type === 'linear') btn.style.background = 'linear-gradient(45deg, #3498db, #2980b9)';
                            else if (type === 'moving-average') btn.style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                            else if (type === 'polynomial') btn.style.background = 'linear-gradient(45deg, #f39c12, #e67e22)';
                            else btn.style.background = 'linear-gradient(45deg, #95a5a6, #7f8c8d)';
                        }
                    }
                });

                // Configure chart
                if (trendType === 'none') {
                    chartConfig.chart.showTrendLine(false);
                } else {
                    chartConfig.chart
                        .showTrendLine(true)
                        .trendLineType(trendType)
                        .trendLineColor(chartConfig.trendSettings.color)
                        .trendLineWidth(chartConfig.trendSettings.width)
                        .trendLineStyle(chartConfig.trendSettings.style);
                }

                // Update chart
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                // Update info display
                updateTrendInfo(chartId, trendType);
                
                showFeedback(chartId, `Trend line: ${trendType === 'none' ? 'disabled' : trendType}`, 'success');
            }
        };

        window.changeTrendColor = function(chartId, color) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.color = color;
                chartConfig.chart.trendLineColor(color);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line color: ${color}`, 'success');
            }
        };

        window.changeTrendWidth = function(chartId, width) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.width = parseInt(width);
                chartConfig.chart.trendLineWidth(parseInt(width));
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line width: ${width}px`, 'success');
            }
        };

        window.changeTrendStyle = function(chartId, style) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.style = style;
                chartConfig.chart.trendLineStyle(style);
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                showFeedback(chartId, `Trend line style: ${style}`, 'success');
            }
        };

        window.changeTrendWindow = function(chartId, window) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.window = parseInt(window);
                
                if (chartConfig.currentTrendType === 'moving-average') {
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                document.getElementById('window-value').textContent = window;
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, `Moving average window: ${window}`, 'success');
            }
        };

        window.changeTrendDegree = function(chartId, degree) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                chartConfig.trendSettings.degree = parseInt(degree);
                
                if (chartConfig.currentTrendType === 'polynomial') {
                    d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                }
                
                document.getElementById('degree-value').textContent = degree;
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, `Polynomial degree: ${degree}`, 'success');
            }
        };

        window.animateTrendChange = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Create a smooth transition effect
                const svg = d3.select(`#${chartId}`);
                const trendLine = svg.select('.trend-line');
                
                if (!trendLine.empty()) {
                    const totalLength = trendLine.node().getTotalLength();
                    
                    trendLine
                        .attr('stroke-dasharray', totalLength + ' ' + totalLength)
                        .attr('stroke-dashoffset', totalLength)
                        .transition()
                        .duration(2000)
                        .ease(d3.easeElastic)
                        .attr('stroke-dashoffset', 0)
                        .on('end', function() {
                            d3.select(this).attr('stroke-dasharray', 'none');
                        });
                        
                    showFeedback(chartId, 'Trend line animated!', 'success');
                } else {
                    showFeedback(chartId, 'Enable a trend line first to see animation', 'info');
                }
            }
        };

        window.generateTrendData = function(chartId) {
            const chartConfig = charts[chartId];
            if (chartConfig) {
                // Generate new trend-oriented data with growth pattern
                const baseValue = 40;
                const growth = 1.15; // 15% growth trend
                const volatility = 0.3; // 30% volatility
                
                const newData = [];
                for (let i = 0; i < 8; i++) {
                    const trend = baseValue * Math.pow(growth, i / 2);
                    const noise = (Math.random() - 0.5) * volatility * trend;
                    const revenue = Math.round(trend + noise);
                    const profit = Math.round(revenue * (0.25 + Math.random() * 0.15));
                    
                    newData.push({
                        label: `Q${(i % 4) + 1} ${2023 + Math.floor(i / 4)}`,
                        stacks: [
                            { value: revenue, color: "#3498db", label: `Revenue: ${revenue}M` },
                            { value: profit, color: "#2ecc71", label: `Profit: ${profit}M` }
                        ]
                    });
                }
                
                chartConfig.data = newData;
                d3.select(`#${chartId}`).datum(chartConfig.data).call(chartConfig.chart);
                
                updateTrendInfo(chartId, chartConfig.currentTrendType);
                showFeedback(chartId, 'New trend data generated!', 'success');
            }
        };

        function updateTrendInfo(chartId, trendType) {
            const infoDiv = document.getElementById('trend-info');
            if (infoDiv && chartId === 'chartTrend') {
                const chartConfig = charts[chartId];
                let infoText = '';
                
                switch (trendType) {
                    case 'linear':
                        infoText = '<strong>Linear Trend:</strong> Shows a straight-line trend through the data points using least squares regression. Best for identifying consistent growth or decline patterns.';
                        break;
                    case 'moving-average':
                        const window = chartConfig.trendSettings.window;
                        infoText = `<strong>Moving Average (${window}-period):</strong> Smooths out short-term fluctuations to reveal underlying trends. Each point represents the average of ${window} consecutive data points.`;
                        break;
                    case 'polynomial':
                        const degree = chartConfig.trendSettings.degree;
                        infoText = `<strong>Polynomial Trend (degree ${degree}):</strong> Fits a curved line that can capture more complex patterns in the data. Higher degrees can show turning points and cycles.`;
                        break;
                    case 'none':
                    default:
                        infoText = '<strong>Current:</strong> No trend line selected. Choose a trend type above to see overlays on your data.';
                        break;
                }
                
                infoDiv.innerHTML = infoText;
            }
        }

        // Responsive chart functionality - improved for touch devices
        function makeChartsResponsive() {
            // Wait for charts to be fully rendered first
            const checkChartsReady = () => {
                const chartElements = document.querySelectorAll('svg[id^="chart"]');
                let allChartsReady = true;
                
                chartElements.forEach(svg => {
                    // Check if chart has actual content (bars, not just empty SVG)
                    const hasContent = svg.querySelector('.bar-group') || svg.querySelector('rect') || svg.querySelector('g');
                    if (!hasContent) {
                        allChartsReady = false;
                    }
                });
                
                if (!allChartsReady) {
                    // Charts not ready yet, check again in 200ms
                    setTimeout(checkChartsReady, 200);
                    return;
                }
                
                // Charts are ready, apply responsive behavior
                chartElements.forEach(svg => {
                    const chartId = svg.id;
                    const container = svg.parentElement;
                    
                    // Get original dimensions from the rendered chart
                    const bbox = svg.getBBox ? svg.getBBox() : { width: 1100, height: 400 };
                    const originalWidth = parseInt(svg.getAttribute('width')) || bbox.width || 1100;
                    const originalHeight = parseInt(svg.getAttribute('height')) || bbox.height || 400;
                    
                    function resizeChart() {
                        const containerWidth = container.clientWidth;
                        const availableWidth = containerWidth - 40; // 20px padding on each side
                        
                        // For tablets and mobile, ensure chart is visible
                        if (availableWidth < originalWidth && availableWidth > 320) {
                            // Set responsive styles without changing chart dimensions
                            svg.style.width = '100%';
                            svg.style.maxWidth = `${availableWidth}px`;
                            svg.style.height = 'auto';
                            svg.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
                            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                        } else if (availableWidth >= originalWidth) {
                            // Reset to original size for desktop
                            svg.style.width = `${originalWidth}px`;
                            svg.style.maxWidth = '100%';
                            svg.style.height = `${originalHeight}px`;
                            svg.removeAttribute('viewBox');
                            svg.removeAttribute('preserveAspectRatio');
                        }
                    }
                    
                    // Set initial responsive styles
                    svg.style.maxWidth = '100%';
                    svg.style.display = 'block';
                    svg.style.margin = '0 auto';
                    
                    // Initial resize
                    resizeChart();
                    
                    // Add resize listener (debounced)
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(resizeChart, 150);
                    });
                    
                    // Add orientation change listener for mobile devices
                    window.addEventListener('orientationchange', () => {
                        setTimeout(resizeChart, 300); // Delay for orientation change
                    });
                });
            };
            
            // Start checking for charts
            checkChartsReady();
        }
        
        // Initialize responsive charts after a longer delay to ensure full initialization
        setTimeout(makeChartsResponsive, 1000);
        
        // Fallback: Ensure charts are visible even if responsive JS fails
        setTimeout(() => {
            const chartElements = document.querySelectorAll('svg[id^="chart"]');
            chartElements.forEach(svg => {
                if (!svg.style.maxWidth) {
                    svg.style.maxWidth = '100%';
                    svg.style.height = 'auto';
                    svg.style.display = 'block';
                    svg.style.margin = '0 auto';
                }
                
                // Force visibility for touch devices
                if ('ontouchstart' in window) {
                    svg.style.visibility = 'visible';
                    svg.style.opacity = '1';
                    svg.setAttribute('viewBox', `0 0 ${svg.getAttribute('width') || 1100} ${svg.getAttribute('height') || 400}`);
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                }
            });
        }, 2000);
        
        // Log successful initialization
        console.log('MintWaterfall v0.6.0 initialized with Interactive Features!');
        console.log('Charts:', Object.keys(charts));
        console.log('Available themes:', Object.keys(themes));
        console.log('Data processor loaded with', Object.keys(dataProcessor).length, 'methods');
        console.log('Animation system loaded with', Object.keys(animationSystem).length, 'features');
        console.log('Interactive Features: Accessibility (WCAG 2.1 AA), Professional Tooltips, Export System, Zoom & Pan, Responsive Design');
        console.log('Accessibility: Tab navigation, Arrow keys, Screen reader support');
        console.log('Tooltips: Smart positioning, Multiple themes, Rich content');
        console.log('Export: SVG, PNG, JSON, CSV formats available');
        console.log('Zoom & Pan: Mouse wheel zoom, drag to pan, zoom controls');
        console.log('Responsive: Mobile-first design, Adaptive charts, Flexible layouts');

    </script>
</body>
</html>
